<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farey Sector Formula - Complete Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0f1a; color: #e2e8f0; line-height: 1.6; font-size: 14px; }
        
        .nav-links { background: linear-gradient(90deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%); padding: 8px 15px; border-bottom: 1px solid #4338ca; overflow-x: auto; white-space: nowrap; position: sticky; top: 0; z-index: 500; }
        .nav-links::-webkit-scrollbar { height: 4px; }
        .nav-links::-webkit-scrollbar-track { background: #1e1b4b; }
        .nav-links::-webkit-scrollbar-thumb { background: #6366f1; border-radius: 2px; }
        .nav-links a { display: inline-block; padding: 4px 10px; margin: 2px 3px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 4px; color: #a5b4fc; text-decoration: none; font-size: 11px; font-weight: 500; transition: all 0.2s; }
        .nav-links a:hover { background: rgba(99, 102, 241, 0.4); color: #e0e7ff; border-color: #6366f1; transform: translateY(-1px); }
        .nav-links-label { color: #64748b; font-size: 10px; margin-right: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; overflow-y: auto; padding: 20px; }
        .modal-overlay.active { display: flex; justify-content: center; align-items: flex-start; }
        .modal-content { background: #1e293b; border-radius: 12px; max-width: 900px; width: 100%; border: 1px solid #475569; margin: 20px auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 18px; border-bottom: 1px solid #334155; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border-radius: 12px 12px 0 0; }
        .modal-header h3 { margin: 0; font-size: 1.1em; }
        .modal-close { background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 16px; }
        .modal-body { padding: 18px; max-height: 75vh; overflow-y: auto; }
        
        .container { max-width: 1800px; margin: 0 auto; padding: 15px; }
        h1 { color: #f8fafc; font-size: 1.5em; margin-bottom: 4px; }
        .subtitle { color: #94a3b8; margin-bottom: 15px; font-size: 0.9em; }
        h2 { color: #f1f5f9; font-size: 1.1em; margin: 20px 0 12px 0; border-bottom: 1px solid #334155; padding-bottom: 6px; }
        h3 { color: #cbd5e1; font-size: 1em; margin: 12px 0 8px 0; }
        h4 { color: #94a3b8; font-size: 0.9em; margin: 8px 0 6px 0; }
        
        .formula-box { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        .formula-main { font-size: 1.3em; font-weight: bold; font-family: 'Cambria Math', serif; text-align: center; margin: 8px 0; }
        
        .control-panel { background: #1e293b; padding: 12px 15px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #334155; }
        .control-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .control-row:last-child { margin-bottom: 0; }
        .control-group { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: #0f172a; border-radius: 5px; }
        .control-group.highlight { border: 1px solid #6366f1; background: #1e1b4b; }
        label { font-weight: 600; color: #cbd5e1; font-size: 0.8em; white-space: nowrap; }
        input[type="number"], input[type="text"], select, textarea { padding: 6px 8px; font-size: 13px; border: 1px solid #475569; border-radius: 5px; background: #1e293b; color: #e2e8f0; }
        input[type="number"] { width: 70px; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }
        select { min-width: 90px; }
        button { padding: 8px 14px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { opacity: 0.9; }
        button.secondary { background: #334155; border: 1px solid #475569; }
        button.small { padding: 5px 10px; font-size: 11px; }
        .info-badge { background: #334155; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; color: #94a3b8; }
        .info-badge strong { color: #e2e8f0; }
        .info-badge.success { background: #14532d; border: 1px solid #16a34a; }
        .info-badge.warning { background: #713f12; border: 1px solid #a16207; }
        
        .mode-selector { display: flex; gap: 4px; }
        .mode-btn { padding: 6px 12px; background: #1e293b; border: 1px solid #475569; border-radius: 5px; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .mode-btn.active { background: #6366f1; border-color: #6366f1; color: white; }
        
        .tabs { display: flex; gap: 3px; margin-bottom: 12px; flex-wrap: wrap; }
        .tab { padding: 6px 12px; background: #1e293b; border: 1px solid #334155; border-radius: 5px 5px 0 0; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .tab.active { background: #334155; color: #f1f5f9; border-bottom-color: #334155; }
        .tab:hover { color: #e2e8f0; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .panel { background: #1e293b; border-radius: 8px; padding: 15px; border: 1px solid #334155; margin-bottom: 15px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
        .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        @media (max-width: 1200px) { .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; } }
        
        .chart-box { background: #0f172a; border-radius: 6px; padding: 12px; border: 1px solid #334155; }
        .chart-box h4 { margin-top: 0; }
        canvas { max-width: 100%; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.8em; }
        thead { background: #334155; }
        th { padding: 8px; text-align: left; font-weight: 600; color: #e2e8f0; }
        td { padding: 6px 8px; border-bottom: 1px solid #334155; }
        tbody tr:hover { background: #334155; }
        .table-scroll { max-height: 350px; overflow-y: auto; }
        
        .detail-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .detail-card { background: #0f172a; padding: 12px; border-radius: 6px; border: 1px solid #334155; }
        .detail-card h5 { color: #94a3b8; font-size: 0.75em; margin-bottom: 6px; text-transform: uppercase; }
        .detail-card .value { font-size: 1.2em; font-weight: bold; color: #6366f1; }
        .detail-card .sub { font-size: 0.8em; color: #64748b; margin-top: 3px; }
        
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
        .stat-card { background: #0f172a; padding: 10px; border-radius: 5px; border: 1px solid #334155; text-align: center; }
        .stat-value { font-size: 1.1em; font-weight: bold; color: #6366f1; }
        .stat-label { font-size: 0.7em; color: #94a3b8; margin-top: 3px; }
        
        .theorem-box { background: #1e1b4b; border-left: 3px solid #6366f1; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .derivation-box { background: #422006; border-left: 3px solid #f59e0b; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .rh-box { background: #450a0a; border-left: 3px solid #ef4444; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .connection-box { background: #14532d; border-left: 3px solid #22c55e; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        
        .ring-canvas { background: #0f172a; border-radius: 6px; border: 1px solid #334155; cursor: crosshair; }
        .point-tooltip { position: absolute; background: #1e293b; border: 1px solid #6366f1; padding: 8px 12px; border-radius: 6px; font-size: 0.8em; pointer-events: none; z-index: 100; display: none; min-width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .point-tooltip.visible { display: block; }
        .point-tooltip h5 { color: #6366f1; margin: 0 0 6px 0; font-size: 1em; }
        .point-tooltip .row { display: flex; justify-content: space-between; margin: 2px 0; }
        .point-tooltip .label { color: #94a3b8; }
        .point-tooltip .val { color: #e2e8f0; font-weight: 600; }
        
        .color-legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 8px; padding: 8px; background: #0f172a; border-radius: 5px; font-size: 0.75em; }
        .color-legend-item { display: flex; align-items: center; gap: 5px; }
        .color-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #475569; }
        
        .progress-bar { width: 100%; height: 5px; background: #334155; border-radius: 3px; overflow: hidden; margin: 8px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); transition: width 0.3s; }
        
        .matrix-display { font-family: 'Courier New', monospace; background: #0f172a; padding: 10px; border-radius: 5px; display: inline-block; margin: 5px; }
        .matrix-bracket { font-size: 2em; line-height: 1; }
        
        .residue-list { max-height: 180px; overflow-y: auto; background: #0f172a; padding: 8px; border-radius: 5px; font-family: monospace; font-size: 0.8em; }
        .residue-item { display: inline-block; padding: 3px 8px; margin: 3px; background: #334155; border-radius: 3px; cursor: default; transition: background 0.2s; }
        .residue-item:hover { background: #475569; }
        .residue-item.prime { background: #854d0e; color: #fbbf24; border: 1px solid #f59e0b; }
        .residue-item.prime:hover { background: #a16207; }
        .residue-item.twin { background: #166534; color: #4ade80; }
        
        .latex-output { background: #0f172a; padding: 12px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; border: 1px solid #334155; max-height: 250px; overflow-y: auto; }
        
        .cf-path { font-family: monospace; background: #334155; padding: 2px 6px; border-radius: 3px; margin: 2px; display: inline-block; }
        
        .screenshot-btn { position: absolute; top: 8px; right: 8px; padding: 4px 8px; background: rgba(99,102,241,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn { position: absolute; top: 8px; right: 90px; padding: 4px 8px; background: rgba(168,85,247,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn:hover { background: rgba(168,85,247,1); }
        .chart-wrapper { position: relative; }
        .composite-export-btn { margin-top: 10px; padding: 10px 16px; font-size: 13px; background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%); }
        .composite-export-btn:hover { opacity: 0.95; }
        #compositeCanvas { display: none; max-width: 100%; margin-top: 10px; }
        .composite-info { background: #1e1b4b; border: 1px solid #8b5cf6; padding: 10px 12px; border-radius: 5px; margin-top: 10px; font-size: 0.85em; color: #cbd5e1; }
        
        .screenshot-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; justify-content: center; align-items: center; flex-direction: column; padding: 20px; }
        .screenshot-overlay.active { display: flex; }
        .screenshot-preview { max-width: 90%; max-height: 60vh; border: 2px solid #6366f1; border-radius: 8px; }
        .screenshot-actions { margin-top: 20px; display: flex; gap: 10px; }
        .screenshot-actions button { padding: 12px 24px; font-size: 14px; }
        
        .heatmap-cell { display: inline-block; width: 20px; height: 20px; margin: 1px; border-radius: 2px; }
        
        .euler-term { display: inline-block; padding: 4px 8px; margin: 3px; background: #1e293b; border-radius: 4px; border: 1px solid #334155; font-family: monospace; }
        .euler-term.prime { border-color: #f59e0b; }
    </style>
</head>
<body>
<div class="nav-links">
    <span class="nav-links-label">Projects:</span>
    <a href="https://wessengetachew.github.io/2025/" target="_blank">2025</a>
    <a href="https://wessengetachew.github.io/Transform/" target="_blank">Transform</a>
    <a href="https://wessengetachew.github.io/finite/" target="_blank">Finite</a>
    <a href="https://wessengetachew.github.io/Primes/" target="_blank">Primes</a>
    <a href="https://wessengetachew.github.io/Farey/" target="_blank">Farey</a>
    <a href="https://wessengetachew.github.io/Composite/" target="_blank">Composite</a>
    <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank">Ethiopian</a>
    <a href="https://wessengetachew.github.io/2pir/" target="_blank">2πr</a>
    <a href="https://wessengetachew.github.io/1-2/" target="_blank">1-2</a>
    <a href="https://wessengetachew.github.io/Rational-/" target="_blank">Rational</a>
    <a href="https://wessengetachew.github.io/Infinitemoduli/" target="_blank">Infinite Moduli</a>
    <a href="https://wessengetachew.github.io/Pythagorean-/" target="_blank">Pythagorean</a>
    <a href="https://wessengetachew.github.io/Phase/" target="_blank">Phase</a>
    <a href="https://wessengetachew.github.io/Gemini/" target="_blank">Gemini</a>
    <a href="https://wessengetachew.github.io/Rebuild/" target="_blank">Rebuild</a>
    <a href="https://wessengetachew.github.io/Goldbach/" target="_blank">Goldbach</a>
</div>
<div class="container">
    <h1>Farey Sector Formula - Complete Research Platform</h1>
    <p class="subtitle">Comprehensive analysis with RH connections, modular arithmetic, and advanced visualizations</p>
    
    <div class="formula-box">
        <div class="formula-main">C(n, N) = 3N² / (π² n(n+1))</div>
        <p style="text-align:center; font-size:0.85em; opacity:0.9;">Asymptotic count of coprime pairs (r, m) with r/m in sector S_n = (1/(n+1), 1/n]</p>
    </div>
    
    <div class="control-panel">
        <div class="control-row">
            <label>Mode:</label>
            <div class="mode-selector">
                <div class="mode-btn active" onclick="setMode('exact')" id="mode-exact">Exact</div>
                <div class="mode-btn" onclick="setMode('hybrid')" id="mode-hybrid">Hybrid</div>
                <div class="mode-btn" onclick="setMode('formula')" id="mode-formula">Formula</div>
            </div>
            <span class="info-badge" id="modeDescription">Exact enumeration</span>
        </div>
        <div class="control-row">
            <div class="control-group highlight">
                <label>N:</label>
                <input type="number" id="nMin" value="100" min="2"> to
                <input type="number" id="nMax" value="100" min="2">
            </div>
            <div class="control-group highlight">
                <label>Sectors:</label>
                <input type="number" id="sectorMin" value="1" min="1"> to
                <input type="number" id="sectorMax" value="15" min="1">
            </div>
            <button onclick="computeAll()">Compute</button>
            <button class="secondary" onclick="cancelComputation()">Cancel</button>
            <button class="secondary" onclick="exportAllData()">Export All</button>
            <button class="composite-export-btn" onclick="exportCompositeTab()" title="Export all visible charts to single 4K image">4K Composite Export</button>
        </div>
        <div class="progress-bar" id="progressBar" style="display:none;"><div class="progress-fill" id="progressFill"></div></div>
        <div id="statusArea"></div>
    </div>
    
    <div class="tabs">
        <div class="tab active" onclick="switchTab('main')">Main</div>
        <div class="tab" onclick="switchTab('theory')">Theory</div>
        <div class="tab" onclick="switchTab('theoryviz')">Theory Viz</div>
        <div class="tab" onclick="switchTab('gaps')">Gaps</div>
        <div class="tab" onclick="switchTab('franel')">Franel-Landau</div>
        <div class="tab" onclick="switchTab('dedekind')">Dedekind</div>
        <div class="tab" onclick="switchTab('cf')">Continued Fractions</div>
        <div class="tab" onclick="switchTab('psl')">PSL(2,Z)</div>
        <div class="tab" onclick="switchTab('euler')">Euler Product</div>
        <div class="tab" onclick="switchTab('modular')">Modular</div>
        <div class="tab" onclick="switchTab('3d')">3D View</div>
        <div class="tab" onclick="switchTab('hyperbolic')">Hyperbolic</div>
        <div class="tab" onclick="switchTab('animation')">Animation</div>
        <div class="tab" onclick="switchTab('smith')">Smith Chart</div>
        <div class="tab" onclick="switchTab('stats')">Statistics</div>
        <div class="tab" onclick="switchTab('primes')">Primes</div>
        <div class="tab" onclick="switchTab('primorial')">Primorial Sieve</div>
        <div class="tab" onclick="switchTab('research')">Research</div>
    </div>
    
    <!-- MAIN TAB -->
    <div id="tab-main" class="tab-content active">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #6366f1;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Main Sector Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#6366f1;">C(n,N) = 3N² / (π² n(n+1))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;"><strong>Definition:</strong> Sectors are defined by consecutive Farey bounds: sector S_n spans the interval (1/(n+1), 1/n], a decreasing sequence of intervals that partition [0,1]. <strong>Formula Purpose:</strong> This asymptotic formula provides increasingly accurate predictions of the count of coprime pairs (r,m) with r/m in sector S_n, where N is the maximum denominator. As N grows, the accuracy of this prediction improves significantly. The formula shows how the Farey sequence distributes its fractions across the unit interval with mathematical precision.</p>
        </div>
        <div class="stat-grid" id="mainStats"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Exact vs Predicted</h4><canvas id="mainCountChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Relative Error %</h4><canvas id="mainErrorChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px;">
            <h4>Sector Data <span style="font-weight:normal; color:#64748b;">(click row to see primes)</span></h4>
            <div class="table-scroll"><table id="mainTable"><thead><tr><th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th><th>Primes</th><th>Composites</th></tr></thead><tbody></tbody></table></div>
        </div>
        <div class="panel chart-wrapper">
            <h4>Sector Ring <span style="font-weight:normal; color:#64748b;">(click points to see tree path)</span></h4>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Sector: <input type="number" id="viewSector" value="1" min="1" onchange="drawMainRing()"></label>
                <label>Color: <select id="colorMode" onchange="drawMainRing()"><option value="sector">Sector</option><option value="prime">Prime</option><option value="denominator">Denom</option><option value="gap">Gap</option></select></label>
                <label><input type="checkbox" id="showAllSectors" onchange="drawMainRing()"> All</label>
                <button class="secondary" onclick="openSectorModal(+document.getElementById('viewSector').value)">View Sector Details</button>
            </div>
            <div style="text-align:center;position:relative;"><canvas id="mainRing" class="ring-canvas" width="600" height="600"></canvas><div class="point-tooltip" id="pointTooltip"></div></div>
            <div class="color-legend" id="colorLegend"></div>
            <div style="margin-top:10px;"><button onclick="screenshotFullTab('main')">Screenshot Full Main Tab</button></div>
        </div>
        
        <div class="panel chart-wrapper">
            <h4>Sector Tree Path <span style="font-weight:normal; color:#64748b;">(Stern-Brocot navigation)</span></h4>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Tree Depth: <input type="number" id="treeDepth" value="8" min="3" max="15" onchange="drawSectorTree()"></label>
                <label><input type="checkbox" id="showTreeLabels" checked onchange="drawSectorTree()"> Labels</label>
                <label><input type="checkbox" id="showTreeGrid" onchange="drawSectorTree()"> Grid</label>
                <label><input type="checkbox" id="animatePath" checked> Animate</label>
                <button class="secondary" onclick="clearTreePath()">Clear Path</button>
            </div>
            <div style="text-align:center;position:relative;">
                <canvas id="sectorTreeCanvas" class="ring-canvas" width="900" height="500"></canvas>
            </div>
            <div id="treePathInfo" style="margin-top:10px; padding:10px; background:#0f172a; border-radius:5px; font-family:monospace; font-size:0.9em;">
                <span style="color:#64748b;">Click a point on the ring above to see its tree path</span>
            </div>
            <div class="color-legend">
                <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Tree nodes</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Path to target</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Target fraction</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>L (left)</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>R (right)</div>
            </div>
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('main')" style="padding:12px 24px; font-size:14px;">Screenshot Full Main Tab</button>
            <button class="secondary" onclick="exportMainTabData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Main Tab Data</button>
        </div>
    </div>
    
    <!-- THEORY TAB -->
    <div id="tab-theory" class="tab-content">
        <div class="panel">
            <h2 style="text-align:center; font-size:1.3em; margin-bottom:8px;">Directional Density of Coprime Lattice Points in Farey Sectors</h2>
            <p style="text-align:center; color:#94a3b8; font-style:italic; margin-bottom:20px;">Wessen Getachew</p>
            
            <div class="theorem-box" style="background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%); border-left-color: #8b5cf6;">
                <h4 style="color:#e0e7ff; margin-top:0;">Abstract</h4>
                <p style="margin:0; font-size:0.95em;">We study the distribution of coprime integer pairs (a,b) with bounded height whose rational slope lies in a fixed Farey sector S_n = (1/(n+1), 1/n]. Using classical summatory totient estimates together with a geometric decomposition of rational directions, we derive an explicit asymptotic formula for the number of primitive lattice points in each sector. This result provides a localized refinement of the global coprime density 1/zeta(2), revealing directional structure in the distribution of visible lattice points.</p>
            </div>
            
            <h3 style="margin-top:20px;">1. Introduction and Motivation</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #f59e0b; margin:10px 0;">
                <p>The probability that two randomly chosen integers are coprime is 1/zeta(2) = 6/pi^2 approximately 0.6079, a classical result with interpretations in analytic number theory and geometry of numbers. Geometrically, this corresponds to the density of visible lattice points in Z^2.</p>
                <p style="margin-top:8px;">Farey sequences organize rational numbers in [0,1] by increasing denominator and naturally partition rational directions into intervals. While global coprime density is well understood, we focus on <strong>directional coprime density</strong> - how primitive lattice points distribute across specific rational slope bands.</p>
            </div>
            
            <h3 style="margin-top:20px;">2. Definitions</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Farey Sector</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        S_n = (1/(n+1), 1/n]
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Intervals partitioning (0,1], bounded by consecutive Farey fractions.</p>
                </div>
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Primitive Lattice Point</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        (a,b) in Z^2 where gcd(a,b) = 1, b >= 1
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Pairs with coprime coordinates representing visible lattice points.</p>
                </div>
            </div>
            
            <h3>3. Main Result</h3>
            <div class="derivation-box" style="background: linear-gradient(135deg, #422006 0%, #5a3a1a 100%); border-left-color: #fbbf24;">
                <strong style="color:#fcd34d; font-size:1.1em;">Farey Sector Density Theorem</strong>
                <p style="margin:12px 0 0 0;">Let n be fixed. As N approaches infinity, the number of coprime integer pairs with slope in the Farey sector S_n satisfies:</p>
                <div style="background:#0f172a; padding:12px; border-radius:5px; font-family:monospace; font-size:1em; margin:10px 0; text-align:center;">
                    <strong>C(n,N) ~ (3/pi^2) * N^2 / (n(n+1))</strong>
                </div>
                <p style="margin:10px 0 0 0; font-size:0.9em;">Where C(n,N) counts pairs (a,b) with 1 <= b <= N, gcd(a,b)=1, and a/b in S_n.</p>
            </div>
            
            <h3 style="margin-top:20px;">4. Proof Sketch</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #22c55e; margin:10px 0;">
                <p><strong>Step 1:</strong> The condition a/b in S_n = (1/(n+1), 1/n] is equivalent to b/(n+1) < a <= b/n.</p>
                <p style="margin:8px 0;"><strong>Step 2:</strong> For each b, the number of integers a in this range is b/(n(n+1)) + O(1).</p>
                <p style="margin:8px 0;"><strong>Step 3:</strong> Restricting to coprime pairs: Sum over b<=N of phi(b)/(n(n+1)) + O(N)</p>
                <p style="margin:8px 0;"><strong>Step 4:</strong> Apply the classical summatory totient estimate:</p>
                <div style="background:#0a0f1a; padding:8px; margin:8px 0; border-radius:4px; font-family:monospace;">
                    Sum of phi(b) = (3/pi^2)N^2 + O(N log N)
                </div>
                <p style="margin:8px 0;"><strong>Conclusion:</strong> C(n,N) = (1/(n(n+1))) * ((3/pi^2)N^2 + O(N log N))</p>
            </div>
            
            <h3 style="margin-top:20px;">5. Computational Verification</h3>
            <table style="width:100%; margin-top:10px; border-collapse:collapse; font-size:0.85em;">
                <thead><tr style="background:#334155;"><th style="padding:8px;">Sector n</th><th>Width 1/(n(n+1))</th><th>Asymptotic Factor</th><th>Global Fraction</th></tr></thead>
                <tbody>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">1</td><td style="padding:8px;">1/2</td><td style="padding:8px;">3/(2pi^2)</td><td style="padding:8px;">approximately 0.1519</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">2</td><td style="padding:8px;">1/6</td><td style="padding:8px;">3/(6pi^2)</td><td style="padding:8px;">approximately 0.0506</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">3</td><td style="padding:8px;">1/12</td><td style="padding:8px;">3/(12pi^2)</td><td style="padding:8px;">approximately 0.0253</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">n</td><td style="padding:8px;">1/(n(n+1))</td><td style="padding:8px;">3/(pi^2 n(n+1))</td><td style="padding:8px;">1/n(n+1) * 6/pi^2</td></tr>
                </tbody>
            </table>
            <p style="margin-top:10px; font-size:0.85em; color:#94a3b8;">Numerical experiments confirm convergence to predicted asymptotics at rates consistent with O(N log N) error decay. Interactive visualizations above display accumulation of primitive lattice points within each Farey sector.</p>
            
            <h3 style="margin-top:20px;">6. Key Theoretical Connections</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Euler and Coprime Density</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Global density 1/zeta(2) = 6/pi^2 emerges as sum of sectoral contributions.</p>
                </div>
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Franel-Landau Connection</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Farey gap distribution relates to RH via: Sum|F_k - k/|F_N|| = O(N^(1/2+epsilon)) iff RH</p>
                </div>
            </div>
            
            <h3>7. Conclusion</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #3b82f6; margin:10px 0;">
                <p style="margin:0;">Farey sectors provide a natural geometric decomposition of rational directions. By combining this structure with classical coprime density results, we obtain an explicit directional refinement of visible lattice point counts. This framework enables anisotropic analysis of arithmetic distributions and provides foundation for modular constraints, higher-dimensional generalizations, and computational number theory.</p>
            </div>
            
            <p style="margin-top:20px; text-align:center; color:#64748b; font-size:0.85em;">Acknowledgments: Foundational work of Euler, Mertens, and others on totient summation and Farey geometry.</p>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('theory')">Screenshot Full Theory Tab</button></div>
        </div>
    </div>
    
    <!-- THEORY VIZ TAB -->
    <div id="tab-theoryviz" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Interactive Theory Visualization</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Visual exploration of the Farey Sector Density Theorem with interactive elements</p>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Max Sectors:</label>
                    <input type="number" id="tvMaxSectors" value="8" min="3" max="20" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Max N:</label>
                    <input type="number" id="tvMaxN" value="150" min="20" max="500" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Lattice Size:</label>
                    <input type="number" id="tvLatticeSize" value="22" min="10" max="40" onchange="drawTheoryViz()">
                </div>
                <div class="control-group">
                    <label>Highlight Sector:</label>
                    <input type="number" id="tvHighlightSector" value="2" min="1" max="10" onchange="drawTheoryViz()">
                </div>
                <button onclick="drawTheoryViz()">Refresh All</button>
                <button class="secondary" onclick="animateTheoryViz()">Animate Growth</button>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Sector Partition of (0,1]</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowSectorValues" checked onchange="drawSectorPartition()"> Values</label>
                    <label><input type="checkbox" id="tvShowSectorWidths" onchange="drawSectorPartition()"> Widths</label>
                    <label>Style: <select id="tvPartitionStyle" onchange="drawSectorPartition()"><option value="bar">Bar</option><option value="arc">Arc</option><option value="number">Number Line</option></select></label>
                </div>
                <canvas id="sectorPartitionCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="sectorPartitionLegend"></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Cone: C(n,N) ~ N²/n(n+1)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sectors to show: <input type="number" id="tvConeSectors" value="4" min="1" max="10" onchange="drawDensityCone()"></label>
                    <label><input type="checkbox" id="tvShowConeRef" checked onchange="drawDensityCone()"> 6/π² ref</label>
                    <label><input type="checkbox" id="tvLogScale" onchange="drawDensityCone()"> Log Y</label>
                </div>
                <canvas id="densityConeCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="densityConeLegend"></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Summatory Totient: Σφ(b) ~ 3N²/π²</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowTotientActual" checked onchange="drawTotientSum()"> Actual</label>
                    <label><input type="checkbox" id="tvShowTotientPredicted" checked onchange="drawTotientSum()"> Predicted</label>
                    <label><input type="checkbox" id="tvShowTotientError" onchange="drawTotientSum()"> Error</label>
                    <label><input type="checkbox" id="tvTotientFill" onchange="drawTotientSum()"> Fill</label>
                </div>
                <canvas id="totientSumCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual Σφ(b)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Asymptotic 3N²/π²</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Visible Lattice Points by Direction</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowHidden" checked onchange="drawLatticeViz()"> Hidden pts</label>
                    <label><input type="checkbox" id="tvShowSectorLines" checked onchange="drawLatticeViz()"> Sector lines</label>
                    <label><input type="checkbox" id="tvColorBySector" onchange="drawLatticeViz()"> Color by sector</label>
                    <label>Point size: <input type="range" id="tvPointSize" min="2" max="8" value="4" onchange="drawLatticeViz()"></label>
                </div>
                <canvas id="latticeVizCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Visible (gcd=1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Hidden (gcd>1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Sector Boundary</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Proof Visualization: Step-by-Step Accumulation</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sector n: <input type="number" id="tvProofSector" value="2" min="1" max="10" onchange="drawProofSteps()"></label>
                    <label><input type="checkbox" id="tvShowContribBars" checked onchange="drawProofSteps()"> Contrib bars</label>
                    <label><input type="checkbox" id="tvShowProofPredicted" checked onchange="drawProofSteps()"> Predicted</label>
                </div>
                <canvas id="proofStepsCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Cumulative count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted asymptotic</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>φ(b)/(n(n+1)) contribution</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Convergence Rate Analysis</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Analysis type: <select id="tvConvergenceType" onchange="drawConvergenceAnalysis()"><option value="relative">Relative Error</option><option value="absolute">Absolute Error</option><option value="ratio">Actual/Predicted</option></select></label>
                    <label><input type="checkbox" id="tvShowConvergenceTrend" checked onchange="drawConvergenceAnalysis()"> Trend line</label>
                </div>
                <canvas id="convergenceCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="convergenceLegend"></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Sector Density Heatmap: C(n,N) across parameters</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>N range: <input type="number" id="tvHeatmapNMin" value="20" min="10" max="100"> to <input type="number" id="tvHeatmapNMax" value="150" min="50" max="300"></label>
                <label>Sectors: <input type="number" id="tvHeatmapSectors" value="10" min="3" max="15"></label>
                <label>Color: <select id="tvHeatmapColor" onchange="drawDensityHeatmap()"><option value="viridis">Viridis</option><option value="plasma">Plasma</option><option value="coolwarm">Cool-Warm</option></select></label>
                <button onclick="drawDensityHeatmap()">Generate</button>
            </div>
            <canvas id="densityHeatmapCanvas" width="1100" height="300"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#440154"></div>Low density</div><div class="color-legend-item"><div class="color-swatch" style="background:#21918c"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#fde725"></div>High density</div></div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Theorem Summary:</strong> For fixed sector n, as N approaches infinity: C(n,N) = (3/π²) × N² / (n(n+1)) + O(N log N). This follows from summing φ(b)/(n(n+1)) over denominators b ≤ N and applying the classical totient summation formula.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('theoryviz')">Screenshot Full Theory Viz Tab</button></div>
    </div>
    
    <!-- GAPS TAB -->
    <div id="tab-gaps" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Farey Gap Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.2em;text-align:center;color:#8b5cf6;">gap(a/b, c/d) = |c/d - a/b| = 1/(b*d)</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">For consecutive Farey fractions a/b and c/d, the gap between them equals exactly 1/(b*d). This elegant formula shows that gaps decrease as denominators grow. The distribution reveals how fractions cluster and spread across the unit interval.</p>
        </div>
        <div class="stat-grid" id="gapStats" style="margin-top:12px;"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Gap Distribution (Color = Size)</h4><canvas id="gapDistChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Gap vs Denominator Product</h4><canvas id="gapVsDenomChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px; background:#0f172a;">
            <h4>Largest Gaps <span style="font-weight:normal;color:#64748b;">(sorted by gap size)</span></h4>
            <div class="table-scroll">
                <table id="gapTable">
                    <thead><tr><th>#</th><th>Left Fraction</th><th>Right Fraction</th><th>Actual Gap</th><th>Theoretical 1/(bd)</th><th>Match</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        <div class="connection-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> Every gap exactly equals 1/(bd) where b and d are the denominators of consecutive Farey fractions. This is a consequence of the mediant property: for neighbors a/b and c/d, we have |ad - bc| = 1.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('gaps')">Screenshot Full Gaps Tab</button></div>
    </div>
    
    <!-- FRANEL-LANDAU TAB -->
    <div id="tab-franel" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #06b6d4;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Franel-Landau Theorem</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#06b6d4;">Σ|δ_k| = O(N^(1/2+ε)) ⟺ Riemann Hypothesis</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Define δ_k = F_k - k/|F_N| as the k-th Farey fraction deviation. The growth rate of Σ|δ_k| is directly equivalent to the Riemann Hypothesis. If RH is true, the sum grows slower than N^(1/2+ε) for any ε > 0. This provides a concrete computational test for RH properties through Farey sequence analysis. <strong style="color:#f87171;">Note: These computations illustrate known equivalences but do not constitute a proof or disproof of RH.</strong></p>
        </div>
        <div class="stat-grid" id="franelStats" style="margin-top:12px;"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Deviation δ_k vs k</h4><canvas id="franelDeviationChart"></canvas></div>
                <div class="chart-box"><h4>Cumulative |δ| / N^α</h4><canvas id="franelCumulativeChart"></canvas></div>
            </div>
            <div class="chart-box" style="margin-top:15px;"><h4>Σ|δ| / N^α for various α</h4><canvas id="franelAlphaChart"></canvas></div>
            <div class="derivation-box" style="margin-top:15px;"><strong>Interpretation:</strong> If RH is true, the normalized sum should stay bounded. Divergence for alpha <= 1/2 would contradict RH.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('franel')">Screenshot Full Franel Tab</button></div>
    </div>
    
    <!-- DEDEKIND TAB -->
    <div id="tab-dedekind" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #f59e0b;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Dedekind Sums</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#f59e0b;">s(h,k) = Σ_{j=1}^{k-1} ((j/k))((hj/k))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Dedekind sums are arithmetic functions encoding properties of coprime pairs (h,k). They satisfy reciprocity formulas: s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk)). These sums connect to modular forms and are fundamental in algebraic number theory.</p>
        </div>
        <div class="panel">
            <h3>Dedekind Sums</h3>
            <div class="theorem-box"><strong>Definition:</strong> s(h,k) = Σ_{j=1}^{k-1} ((j/k))((hj/k)) where ((x)) = x - ⌊x⌋ - 1/2 if x∉ℤ, else 0</div>
            <div class="control-row" style="margin:12px 0;"><label>Max k: <input type="number" id="dedekindMaxK" value="20" min="2" onchange="computeDedekind()"></label></div>
            <div class="grid-2">
                <div class="chart-box"><h4>s(h,k) Heatmap</h4><canvas id="dedekindHeatmap" width="400" height="400"></canvas></div>
                <div class="chart-box"><h4>s(1,k) vs k</h4><canvas id="dedekindChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Dedekind Sum Table</h4><div class="table-scroll"><table id="dedekindTable"><thead><tr><th>h</th><th>k</th><th>s(h,k)</th><th>12k·s(h,k)</th><th>gcd</th></tr></thead><tbody></tbody></table></div></div>
            <div class="connection-box" style="margin-top:12px;"><strong>Reciprocity:</strong> s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk))</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('dedekind')">Screenshot Full Dedekind Tab</button></div>
        </div>
    </div>
    
    <!-- CONTINUED FRACTIONS TAB -->
    <div id="tab-cf" class="tab-content">
        <div class="panel">
            <h3>Continued Fractions</h3>
            <div class="theorem-box"><strong>Stern-Brocot Encoding:</strong> Path L^a R^b L^c... encodes CF [0; a, b, c, ...]</div>
            <div class="control-row" style="margin:12px 0;"><label>Sector: <input type="number" id="cfSector" value="2" min="1" onchange="updateCFDisplay()"></label><label>Max terms: <input type="number" id="cfMaxTerms" value="50" onchange="updateCFDisplay()"></label></div>
            <div class="panel" style="background:#0f172a;"><h4>Continued Fraction Expansions</h4><div class="table-scroll"><table id="cfTable"><thead><tr><th>r/m</th><th>CF [a0; a1, a2, ...]</th><th>Path</th><th>Length</th><th>Sum(a_i)</th></tr></thead><tbody></tbody></table></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>CF Length Distribution</h4><canvas id="cfLengthChart"></canvas></div>
                <div class="chart-box"><h4>First Partial Quotient</h4><canvas id="cfFirstChart"></canvas></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('cf')">Screenshot Full CF Tab</button></div>
        </div>
    </div>
    
    <!-- PSL(2,Z) TAB -->
    <div id="tab-psl" class="tab-content">
        <div class="panel">
            <h3>PSL(2,ℤ) Matrices</h3>
            <div class="theorem-box"><strong>Farey Neighbor Property:</strong> For consecutive Farey fractions a/b, c/d: |ad - bc| = 1, giving matrix [a,c; b,d] ∈ SL(2,ℤ)</div>
            <div class="control-row" style="margin:12px 0;"><label>Max denom: <input type="number" id="pslMaxDenom" value="12" min="3" onchange="computePSL()"></label></div>
            <div class="panel" style="background:#0f172a;"><h4>Neighbor Matrices</h4><div id="pslMatrices" style="max-height:300px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Ford Circles</h4><canvas id="fordCanvas" width="500" height="250"></canvas></div>
                <div class="chart-box"><h4>Determinant Verification</h4><div id="pslVerification"></div></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('psl')">Screenshot Full PSL Tab</button></div>
        </div>
    </div>
    
    <!-- EULER PRODUCT TAB -->
    <div id="tab-euler" class="tab-content">
        <div class="panel">
            <h3>Euler Product for ζ(2)</h3>
            <div class="theorem-box"><strong>Euler:</strong> ζ(2) = Σ 1/n² = ∏_p 1/(1-1/p²) = π²/6, hence 6/π² = ∏_p (1-1/p²)</div>
            <div class="control-row" style="margin:12px 0;"><label>Primes up to: <input type="number" id="eulerMaxP" value="50" min="5" onchange="computeEulerProduct()"></label></div>
            <div class="stat-grid" id="eulerStats"></div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Product Terms</h4><div id="eulerTerms" style="max-height:200px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Partial Product → 6/π²</h4><canvas id="eulerProductChart"></canvas></div>
                <div class="chart-box"><h4>Partial Sum → π²/6</h4><canvas id="eulerSumChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:12px;"><strong>Connection:</strong> The coprime probability 6/pi^2 emerges from excluding multiples of each prime p with probability 1/p^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('euler')">Screenshot Full Euler Tab</button></div>
        </div>
    </div>
    
    <!-- MODULAR TAB -->
    <div id="tab-modular" class="tab-content">
        <div class="panel">
            <h3>Modular Arithmetic Analysis</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Filter mod k: <input type="number" id="modK" value="6" min="2" onchange="updateModularAnalysis()"></label>
                <label>Residue a: <input type="number" id="modA" value="1" min="0" onchange="updateModularAnalysis()"></label>
                <button onclick="updateModularAnalysis()">Apply Filter</button>
            </div>
            <div class="stat-grid" id="modularStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Residue Class Distribution</h4><canvas id="residueClassChart"></canvas></div>
                <div class="chart-box"><h4>Prime Channel Ownership</h4><canvas id="primeChannelChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Lifting Tower: m → 2m, 3m, ...</h4>
                <div id="liftingDisplay"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('modular')">Screenshot Full Modular Tab</button></div>
        </div>
    </div>
    
    <!-- 3D VIEW TAB -->
    <div id="tab-3d" class="tab-content">
        <div class="panel">
            <h3>3D Sector Cone</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Rotate X: <input type="range" id="rot3dX" min="-90" max="90" value="30" onchange="draw3D()"></label>
                <label>Rotate Z: <input type="range" id="rot3dZ" min="0" max="360" value="45" onchange="draw3D()"></label>
                <label>Perspective: <input type="range" id="perspective3d" min="100" max="1000" value="500" onchange="draw3D()"></label>
            </div>
            <div style="text-align:center;"><canvas id="canvas3d" class="ring-canvas" width="700" height="600"></canvas></div>
            <div class="derivation-box" style="margin-top:12px;">Third axis represents denominator m. Points at height m have coprime numerators r with r/m in the sector range. The cone structure shows density increasing with m^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('3d')">Screenshot Full 3D Tab</button></div>
        </div>
    </div>
    
    <!-- HYPERBOLIC TAB -->
    <div id="tab-hyperbolic" class="tab-content">
        <div class="panel">
            <h3>Hyperbolic Plane / Poincaré Disk</h3>
            <div class="theorem-box"><strong>Farey Tessellation:</strong> The hyperbolic plane is tessellated by ideal triangles with vertices at Farey fractions on ∂H.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Max denom: <input type="number" id="hypMaxDenom" value="15" min="3" onchange="drawHyperbolic()"></label>
                <label>Highlight sector: <input type="number" id="hypSector" value="2" min="1" onchange="drawHyperbolic()"></label>
            </div>
            <div style="text-align:center;"><canvas id="hypCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('hyperbolic')">Screenshot Full Hyperbolic Tab</button></div>
        </div>
    </div>
    
    <!-- ANIMATION TAB -->
    <div id="tab-animation" class="tab-content">
        <div class="panel">
            <h3>Farey Sequence Growth</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Animate to N: <input type="number" id="animMaxN" value="50" min="5"></label>
                <label>Speed (ms): <input type="number" id="animSpeed" value="200" min="50"></label>
                <button onclick="startAnimation()">Start</button>
                <button class="secondary" onclick="stopAnimation()">Stop</button>
                <span id="animStatus" class="info-badge">Ready</span>
            </div>
            <div style="text-align:center;"><canvas id="animCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div class="stat-grid" id="animStats" style="margin-top:12px;"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('animation')">Screenshot Full Animation Tab</button></div>
        </div>
    </div>
    
    <!-- SMITH CHART TAB -->
    <div id="tab-smith" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Smith Chart Transform (Cayley Map)</h3>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Cayley Transform</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">Γ = (z - 1)/(z + 1)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Input z</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">z = R·e^(iθ), θ = 2πr/M + α</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Properties</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">Conformal • Angle-preserving</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Sector:</label>
                    <input type="number" id="smithSector" value="2" min="1" max="15" onchange="drawSmithChart()">
                </div>
                <div class="control-group highlight">
                    <label>Phase α:</label>
                    <input type="range" id="smithPhase" min="0" max="360" value="90" onchange="updateSmithPhaseLabel(); drawSmithChart()">
                    <span id="smithPhaseLabel">90°</span>
                </div>
                <div class="control-group">
                    <label>Radius Mode:</label>
                    <select id="smithRadiusMode" onchange="drawSmithChart()">
                        <option value="unit">Unit (R=1)</option>
                        <option value="index">By Index</option>
                        <option value="modulus" selected>By Modulus</option>
                        <option value="custom">Custom Scale</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Scale:</label>
                    <input type="number" id="smithCustomScale" value="1.0" min="0.1" max="5" step="0.1" onchange="drawSmithChart()">
                </div>
            </div>
            <div class="control-row">
                <label><input type="checkbox" id="smithShowGrid" checked onchange="drawSmithChart()"> Smith Grid</label>
                <label><input type="checkbox" id="smithShowConstR" checked onchange="drawSmithChart()"> Constant-R Circles</label>
                <label><input type="checkbox" id="smithShowConstX" checked onchange="drawSmithChart()"> Constant-X Arcs</label>
                <label><input type="checkbox" id="smithShowLabels" onchange="drawSmithChart()"> Point Labels</label>
                <label><input type="checkbox" id="smithColorByPrime" onchange="drawSmithChart()"> Color by Prime</label>
                <label><input type="checkbox" id="smithShowAllSectors" onchange="drawSmithChart()"> All Sectors</label>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Smith Chart (Cayley Transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Transformed points</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime moduli</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Constant-R</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#475569"></div>Constant-X</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Original z-plane (Pre-transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithOriginalCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>z = R·e^(iθ)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Unit circle</div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;background:#0f172a;">
            <h4>Transform Mathematics</h4>
            <div class="grid-3" style="gap:15px;">
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Cayley Transform</strong>
                    <div style="font-family:monospace;font-size:0.9em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Γ = (z - 1)/(z + 1)<br>
                        z = R·e^(iθ)
                    </div>
                </div>
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Real Part</strong>
                    <div style="font-family:monospace;font-size:0.85em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Re(Γ) = (AC + B²)/(C² + B²)<br>
                        A = Rcosθ - 1, B = Rsinθ<br>
                        C = Rcosθ + 1
                    </div>
                </div>
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Imaginary Part</strong>
                    <div style="font-family:monospace;font-size:0.85em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Im(Γ) = B(C - A)/(C² + B²)<br>
                        Special (R=1):<br>
                        Γ(θ) = i·tan(θ/2)
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Transform Data</h4>
            <div class="table-scroll" style="max-height:250px;">
                <table id="smithDataTable">
                    <thead><tr><th>r/m</th><th>θ (rad)</th><th>R</th><th>z = Re^iθ</th><th>Γ = (z-1)/(z+1)</th><th>|Γ|</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('smith')">Screenshot Full Smith Tab</button></div>
    </div>
    
    <!-- STATISTICS TAB -->
    <div id="tab-stats" class="tab-content">
        <div class="panel">
            <h3>Statistical Analysis</h3>
            <div class="grid-2">
                <div class="chart-box"><h4>Random vs Actual Distribution</h4><canvas id="randomCompareChart"></canvas></div>
                <div class="chart-box"><h4>Cross-Sector Correlation</h4><canvas id="correlationChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Error Term O(N log N)</h4><canvas id="errorTermChart"></canvas></div>
                <div class="chart-box"><h4>Local Density Analysis</h4><canvas id="localDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Correlation Matrix</h4>
                <div id="correlationMatrix"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('stats')">Screenshot Full Statistics Tab</button></div>
        </div>
    </div>
    
    <!-- PRIMES TAB -->
    <div id="tab-primes" class="tab-content">
        <div class="panel">
            <h3>Prime Analysis</h3>
            <div class="stat-grid" id="primeStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Twin Prime Gap Markers</h4><canvas id="twinPrimeChart"></canvas></div>
                <div class="chart-box"><h4>Prime vs Composite Moduli</h4><canvas id="primeVsCompositeChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Prime k-tuple Correlations</h4><canvas id="ktupleChart"></canvas></div>
                <div class="chart-box"><h4>Prime Denominator Density</h4><canvas id="primeDenomDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Twin Prime Gaps in Farey Sequence</h4>
                <div id="twinPrimeList" class="residue-list"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('primes')">Screenshot Full Primes Tab</button></div>
        </div>
    </div>
    
    <!-- PRIMORIAL SIEVE TAB -->
    <div id="tab-primorial" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Primorial Sieve & Farey Sector Connection</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Exploring how primorial residue classes connect to Farey sector distribution</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Primorial Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">φ(P_k)/P_k = ∏(1-1/p)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Unified Formula</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">C(n,N,a,k) = 3N²/(π²n(n+1)φ(k))</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">30×2ⁿ Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">φ(30×2ⁿ)/(30×2ⁿ) = 4/15</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Primorial Base:</label>
                    <select id="primorialBase" onchange="updatePrimorialSieve()">
                        <option value="6">P₂ = 6 (2×3)</option>
                        <option value="30" selected>P₃ = 30 (2×3×5)</option>
                        <option value="210">P₄ = 210 (2×3×5×7)</option>
                        <option value="2310">P₅ = 2310 (2×3×5×7×11)</option>
                    </select>
                </div>
                <div class="control-group highlight">
                    <label>Power 2ⁿ:</label>
                    <input type="number" id="primorialPower" value="0" min="0" max="6" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Max N:</label>
                    <input type="number" id="primorialN" value="200" min="50" max="1000" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Sectors:</label>
                    <input type="number" id="primorialSectors" value="8" min="3" max="15" onchange="updatePrimorialSieve()">
                </div>
                <button onclick="updatePrimorialSieve()">Compute</button>
                <button class="secondary" onclick="animateLiftingTree()">Animate Lifting</button>
            </div>
        </div>
        
        <div class="stat-grid" id="primorialStats"></div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Sector × Residue Heatmap</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="heatmapNormalize" checked onchange="drawSectorResidueHeatmap()"> Normalize rows</label>
                    <label><input type="checkbox" id="heatmapShowValues" onchange="drawSectorResidueHeatmap()"> Show values</label>
                    <label>Color: <select id="heatmapColorScheme" onchange="drawSectorResidueHeatmap()"><option value="purple">Purple</option><option value="heat">Heat</option><option value="viridis">Viridis</option></select></label>
                </div>
                <canvas id="sectorResidueHeatmap" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#1e1b4b"></div>Low</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#c4b5fd"></div>High</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Constant Verification: φ(k×2ⁿ)/(k×2ⁿ)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Show up to 2^<input type="number" id="densityMaxPower" value="8" min="1" max="12" onchange="drawDensityConstant()"></label>
                    <label><input type="checkbox" id="densityShowTheory" checked onchange="drawDensityConstant()"> Theory line</label>
                </div>
                <canvas id="densityConstantCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual φ(m)/m</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Constant = φ(P_k)/P_k</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Lifting Tree: Residue Class Splitting</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Levels: <input type="number" id="liftingLevels" value="4" min="2" max="6" onchange="drawLiftingTree()"></label>
                    <label>Highlight sector: <input type="number" id="liftingSector" value="2" min="1" max="10" onchange="drawLiftingTree()"></label>
                    <label><input type="checkbox" id="liftingShowCounts" checked onchange="drawLiftingTree()"> Counts</label>
                </div>
                <canvas id="liftingTreeCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Residue class</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>In sector</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Split children</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Unified Formula Verification</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Residue class a: <select id="unifiedResidueClass" onchange="drawUnifiedFormulaChart()"></select></label>
                    <label><input type="checkbox" id="unifiedShowAll" onchange="drawUnifiedFormulaChart()"> All classes</label>
                </div>
                <canvas id="unifiedFormulaCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual C(n,N,a,k)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted 3N²/(π²n(n+1)φ(k))</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Prime Distribution Across Residue Classes</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="primeDistShowExpected" checked onchange="drawPrimeDistribution()"> Expected line</label>
                    <label><input type="checkbox" id="primeDistBySector" onchange="drawPrimeDistribution()"> Split by sector</label>
                </div>
                <canvas id="primeDistributionCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected (uniform)</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Sector Uniformity Test</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Test sector: <input type="number" id="uniformitySector" value="2" min="1" max="10" onchange="drawUniformityTest()"></label>
                    <label><input type="checkbox" id="uniformityShowChiSq" checked onchange="drawUniformityTest()"> χ² stat</label>
                </div>
                <canvas id="uniformityTestCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Actual per class</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected C(n,N)/φ(k)</div></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Primorial Comparison: φ(P_k)/P_k → 6/π² Convergence</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>Show primorials up to P_<input type="number" id="primorialCompareMax" value="8" min="3" max="12" onchange="drawPrimorialComparison()"></label>
                <label><input type="checkbox" id="primorialShowProduct" checked onchange="drawPrimorialComparison()"> Show ∏(1-1/p²)</label>
                <label><input type="checkbox" id="primorialShowRatio" onchange="drawPrimorialComparison()"> Show ratio</label>
            </div>
            <canvas id="primorialComparisonCanvas" width="1100" height="350"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>φ(P_k)/P_k</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>∏(1-1/p²) partial</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/π²</div></div>
        </div>
        
        <div class="panel" style="margin-top:15px;background:#0f172a;">
            <h4>Coprime Residue Classes for Current Modulus</h4>
            <div id="residueClassList" class="residue-list" style="max-height:150px;"></div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Sector × Residue Data Table</h4>
            <div class="table-scroll" style="max-height:300px;">
                <table id="sectorResidueTable">
                    <thead><tr><th>Sector</th><th>Total</th><th>Per Class Avg</th><th>χ² Stat</th><th>Uniform?</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> The unified formula C(n,N,a,k) = 3N²/(π²n(n+1)φ(k)) combines Farey sector distribution with primorial residue filtering. This shows that coprimes distribute uniformly across residue classes within each sector, and the density φ(30×2ⁿ)/(30×2ⁿ) = 4/15 remains constant under power-of-2 scaling.
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('primorial')" style="padding:12px 24px; font-size:14px;">Screenshot Full Primorial Tab</button>
            <button class="secondary" onclick="exportPrimorialData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Primorial Data</button>
        </div>
    </div>
    
    <!-- RESEARCH TAB -->
    <div id="tab-research" class="tab-content">
        <div class="panel">
            <h3>Research Tools</h3>
            
            <h4>Custom Formula Tester</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>Formula C(n,N) = </label>
                <input type="text" id="customFormula" value="3*N*N/(Math.PI*Math.PI*n*(n+1))" style="width:300px;">
                <button onclick="testCustomFormula()">Test</button>
            </div>
            <div class="chart-box" style="margin-top:12px;"><h4>Custom vs Standard</h4><canvas id="customFormulaChart"></canvas></div>
            
            <h4 style="margin-top:20px;">Batch Parameter Sweep</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>N range: <input type="number" id="batchNMin" value="50"> to <input type="number" id="batchNMax" value="200"> step <input type="number" id="batchNStep" value="10"></label>
                <button onclick="runBatchSweep()">Run Sweep</button>
            </div>
            <div class="table-scroll" style="margin-top:12px;"><table id="batchTable"><thead><tr><th>N</th><th>|F_N|</th><th>Σ|δ|</th><th>Σ|δ|/√N</th><th>Max Gap</th><th>Mean Gap</th></tr></thead><tbody></tbody></table></div>
            
            <h4 style="margin-top:20px;">Publication Export</h4>
            <div class="control-row" style="margin:12px 0;">
                <button onclick="exportLatexFigures()">LaTeX Figures</button>
                <button onclick="exportCSVAll()">Full CSV</button>
                <button onclick="exportJSON()">JSON Data</button>
            </div>
            <div class="latex-output" id="latexFigures"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('research')">Screenshot Full Research Tab</button></div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="pointModal"><div class="modal-content" style="max-width:450px;"><div class="modal-header"><h3 id="pointModalTitle">Point</h3><button class="modal-close" onclick="closePointModal()">x</button></div><div class="modal-body" id="pointModalBody"></div></div></div>

<div class="modal-overlay" id="sectorModal"><div class="modal-content" style="max-width:700px;"><div class="modal-header"><h3 id="sectorModalTitle">Sector Details</h3><button class="modal-close" onclick="closeSectorModal()">x</button></div><div class="modal-body" id="sectorModalBody"></div></div></div>

<div class="screenshot-overlay" id="screenshotOverlay">
    <h3 style="color:#f1f5f9; margin-bottom:20px;">Screenshot Preview (with Legend)</h3>
    <img id="screenshotPreview" class="screenshot-preview">
    <div class="screenshot-actions">
        <button onclick="downloadScreenshot()">Download PNG</button>
        <button onclick="copyScreenshot()">Copy to Clipboard</button>
        <button class="secondary" onclick="closeScreenshotOverlay()">Close</button>
    </div>
</div>

<script>
const state = {
    mode: 'exact', nMin: 100, nMax: 100, sectorMin: 1, sectorMax: 15,
    sectors: [], residuesBySector: {}, allResidues: [], gaps: [], farey: [],
    computing: false, charts: {}, ringPoints: [], animationId: null
};

const sectorColors = ['#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899','#f43f5e','#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6','#06b6d4','#0ea5e9','#3b82f6'];
function getSectorColor(n) { return sectorColors[(n-1) % sectorColors.length]; }

// Canvas state
let currentScreenshotData = null;

function downloadScreenshot() {
    if (!currentScreenshotData) return;
    const a = document.createElement('a');
    a.href = currentScreenshotData;
    a.download = 'farey_chart_' + Date.now() + '.png';
    a.click();
}

async function copyScreenshot() {
    if (!currentScreenshotData) return;
    try {
        const blob = await (await fetch(currentScreenshotData)).blob();
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        alert('Copied to clipboard!');
    } catch (e) {
        alert('Copy failed: ' + e.message);
    }
}

function closeScreenshotOverlay() {
    document.getElementById('screenshotOverlay').classList.remove('active');
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = 'Sector ' + n + ': (1/' + (n+1) + ', 1/' + n + ']';
    
    let primesHtml = primes.length > 0 
        ? primes.map(p => '<span class="residue-item prime" title="m=' + p.m + ' is prime">' + p.r + '/' + p.m + '</span>').join('') 
        : '<span style="color:#64748b">No prime moduli in this sector</span>';
    
    let compositesHtml = composites.length > 0 
        ? composites.slice(0,100).map(c => '<span class="residue-item">' + c.r + '/' + c.m + '</span>').join('') 
        : '<span style="color:#64748b">No composite moduli in this sector</span>';
    
    if (composites.length > 100) {
        compositesHtml += '<span style="color:#64748b; display:block; margin-top:8px;">... and ' + (composites.length - 100) + ' more</span>';
    }
    
    let html = '<div class="stat-grid" style="margin-bottom:15px;">' +
        '<div class="stat-card"><div class="stat-value">' + res.length + '</div><div class="stat-label">Total Pairs</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#f59e0b">' + primes.length + '</div><div class="stat-label">Prime Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#6366f1">' + composites.length + '</div><div class="stat-label">Composite Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector ? fmt(sector.predicted) : '-') + '</div><div class="stat-label">Predicted</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-') + '</div><div class="stat-label">Error</div></div>' +
        '</div>' +
        '<h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (' + primes.length + ')</h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(245,158,11,0.3);">' + primesHtml + '</div>' +
        '<h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (' + composites.length + ') <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(99,102,241,0.3);">' + compositesHtml + '</div>' +
        '<div style="margin-top:15px; display:flex; gap:10px;">' +
        '<button onclick="exportSectorData(' + n + ')">Export Sector CSV</button>' +
        '<button class="secondary" onclick="viewSectorOnRing(' + n + ')">View on Ring</button>' +
        '</div>';
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += r.r + ',' + r.m + ',' + r.value + ',' + r.isPrime + '\n';
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sector_' + n + '_data.csv';
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

function screenshotFullTab(tabName) {
    const tabElement = document.getElementById('tab-' + tabName);
    if (!tabElement) { alert('Tab not found'); return; }
    
    const canvases = tabElement.querySelectorAll('canvas');
    const statGrids = tabElement.querySelectorAll('.stat-grid');
    const tables = tabElement.querySelectorAll('table');
    
    const padding = 40;
    const titleHeight = 80;
    const statsHeight = statGrids.length > 0 ? 100 : 0;
    
    // Calculate canvas section - 2 per row
    const canvasCount = canvases.length;
    const canvasRows = Math.ceil(canvasCount / 2);
    const canvasSectionHeight = canvasRows * 340;
    
    // Check if we have odd number of canvases (will have empty space)
    const hasEmptySpace = canvasCount % 2 === 1;
    
    // Calculate table height
    let tableHeight = 0;
    if (tables.length > 0) {
        const rows = Math.min(tables[0].querySelectorAll('tbody tr').length, 12);
        tableHeight = rows * 24 + 60;
    }
    tableHeight = Math.min(tableHeight, 350);
    
    // Formula panel height (for empty space or bottom)
    const formulaPanelHeight = 200;
    
    const totalWidth = 1000;
    const totalHeight = titleHeight + statsHeight + canvasSectionHeight + tableHeight + formulaPanelHeight + padding * 2;
    
    const composite = document.createElement('canvas');
    composite.width = totalWidth * 2;
    composite.height = totalHeight * 2;
    const ctx = composite.getContext('2d');
    ctx.scale(2, 2);
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    
    let currentY = padding;
    
    // Tab info for formulas
    const tabInfo = {
        'main': {
            title: 'Main Sector Analysis',
            formula: 'C(n, N) = 3N² / (π² n(n+1))',
            description: 'Asymptotic count of coprime pairs (r, m) with r/m in sector Sₙ = (1/(n+1), 1/n]',
            params: ['Coprime density: 6/π² ≈ 0.6079', 'Sector width: 1/(n(n+1))', 'Error term: O(N log N)']
        },
        'theory': {
            title: 'Farey Sector Density Theory',
            formula: 'C(n, N) ~ (3/π²) · N² / n(n+1)',
            description: 'Distribution of coprime integer pairs with bounded height whose rational slope lies in a fixed Farey sector',
            params: ['Σφ(b) = 3N²/π² + O(N log N)', 'Global density: 1/ζ(2) = 6/π²', 'Visible lattice points']
        },
        'theoryviz': {
            title: 'Theory Visualization',
            formula: 'C(n, N) = 3N² / (π² n(n+1))',
            description: 'Interactive visual exploration of the Farey Sector Density Theorem',
            params: ['Summatory totient: Σφ(b) ~ 3N²/π²', 'Sector partition of (0,1]', 'Convergence analysis']
        },
        'gaps': {
            title: 'Farey Gap Analysis',
            formula: 'gap(a/b, c/d) = |c/d - a/b| = 1/(b·d)',
            description: 'For consecutive Farey fractions, the gap equals exactly 1/(b·d)',
            params: ['Mediant property: |ad - bc| = 1', 'Gap decreases with denominator', 'Uniform distribution']
        },
        'franel': {
            title: 'Franel-Landau Theorem',
            formula: 'Σ|δₖ| = O(N^(1/2+ε)) ⟺ RH',
            description: 'Equivalence between Farey sequence deviation growth and the Riemann Hypothesis',
            params: ['δₖ = Fₖ - k/|Fₙ|', 'RH implies bounded Σ|δ|/√N', 'Computational verification']
        },
        'dedekind': {
            title: 'Dedekind Sums',
            formula: 's(h,k) = Σⱼ₌₁ᵏ⁻¹ ((j/k))((hj/k))',
            description: 'Arithmetic functions encoding properties of coprime pairs with reciprocity laws',
            params: ['Reciprocity: s(h,k) + s(k,h) = -1/4 + ...', 'Sawtooth function ((x))', 'Modular forms connection']
        },
        'cf': {
            title: 'Continued Fractions',
            formula: 'r/m = [a₀; a₁, a₂, ...]',
            description: 'Stern-Brocot tree encoding via continued fraction expansion',
            params: ['Path L^a R^b encodes [0; a, b, ...]', 'Convergents approximate r/m', 'Best rational approximations']
        },
        'psl': {
            title: 'PSL(2,ℤ) Matrices',
            formula: '[a,c; b,d] ∈ SL(2,ℤ) with |ad-bc|=1',
            description: 'Farey neighbors correspond to matrices with determinant ±1',
            params: ['Ford circles tangency', 'Hyperbolic tessellation', 'Modular group action']
        },
        'euler': {
            title: 'Euler Product for ζ(2)',
            formula: 'ζ(2) = Πₚ 1/(1-1/p²) = π²/6',
            description: 'The coprime density emerges from excluding prime multiples',
            params: ['6/π² = Πₚ(1-1/p²)', 'Prime sieve interpretation', 'Basel problem solution']
        },
        'modular': {
            title: 'Modular Arithmetic Analysis',
            formula: 'm ≡ a (mod k)',
            description: 'Residue class distribution and prime channel analysis',
            params: ['Lifting tower: m → 2m, 3m, ...', 'Prime channel ownership', 'Residue class uniformity']
        },
        '3d': {
            title: '3D Sector Cone Visualization',
            formula: 'Points at height m have coprime r with r/m ∈ Sₙ',
            description: 'Third axis represents denominator m, showing density growth with m²',
            params: ['Perspective projection', 'Color by prime/composite', 'Rotation controls']
        },
        'hyperbolic': {
            title: 'Hyperbolic Plane / Poincaré Disk',
            formula: 'Farey tessellation of ℍ',
            description: 'The hyperbolic plane is tessellated by ideal triangles with Farey vertices',
            params: ['Geodesics between neighbors', 'Ford circles on boundary', 'PSL(2,ℤ) action']
        },
        'animation': {
            title: 'Farey Sequence Growth Animation',
            formula: '|Fₙ| ~ 3N²/π²',
            description: 'Watch the Farey sequence grow as N increases',
            params: ['Progressive density increase', 'Prime/composite distribution', 'Mediant insertion']
        },
        'smith': {
            title: 'Smith Chart Transform',
            formula: 'Γ = (Z-1)/(Z+1)',
            description: 'Map Farey fractions to Smith chart coordinates',
            params: ['Impedance transformation', 'Reflection coefficient', 'Complex plane mapping']
        },
        'stats': {
            title: 'Statistical Analysis',
            formula: 'Expected: 6N²/π², Actual: |coprimes|',
            description: 'Statistical comparison of actual vs theoretical distributions',
            params: ['Cross-sector correlation', 'Error term analysis', 'Local density variation']
        },
        'primes': {
            title: 'Prime Analysis',
            formula: 'φ(p) = p-1 for prime p',
            description: 'Prime denominator distribution and twin prime patterns',
            params: ['Prime vs composite ratio', 'k-tuple correlations', 'Gap patterns at primes']
        },
        'primorial': {
            title: 'Primorial Sieve & Farey Connection',
            formula: 'C(n,N,a,k) = 3N²/(π²n(n+1)φ(k))',
            description: 'Unified formula connecting Farey sector distribution with primorial residue classes',
            params: ['φ(30×2ⁿ)/(30×2ⁿ) = 4/15 constant', 'Sector × Residue uniformity', 'φ(P_k)/P_k → approaches 6/π²']
        },
        'research': {
            title: 'Research Tools',
            formula: 'Custom: C(n,N) = f(n,N)',
            description: 'Tools for testing custom formulas and batch parameter sweeps',
            params: ['LaTeX export', 'CSV/JSON data export', 'Parameter sweep analysis']
        }
    };
    
    const info = tabInfo[tabName] || { title: tabName, formula: '', description: '', params: [] };
    
    // Header with gradient
    const gradient = ctx.createLinearGradient(0, 0, totalWidth, titleHeight);
    gradient.addColorStop(0, '#1e1b4b');
    gradient.addColorStop(1, '#312e81');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, totalWidth, titleHeight);
    
    // Title
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 24px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Farey Sector Formula - ' + info.title, padding, currentY + 30);
    
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText('N = ' + state.nMax + ' | Sectors ' + state.sectorMin + '-' + state.sectorMax + ' | ' + new Date().toLocaleString(), padding, currentY + 55);
    
    // Formula badge
    ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
    const formulaWidth = ctx.measureText(info.formula).width + 30;
    ctx.fillRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.strokeStyle = '#6366f1';
    ctx.strokeRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.fillStyle = '#e0e7ff';
    ctx.font = 'bold 14px "Cambria Math", serif';
    ctx.textAlign = 'right';
    ctx.fillText(info.formula, totalWidth - padding - 5, currentY + 38);
    
    currentY = titleHeight;
    
    // Stats section
    if (statGrids.length > 0) {
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(padding, currentY + 10, totalWidth - padding * 2, statsHeight - 20);
        ctx.strokeStyle = '#334155';
        ctx.strokeRect(padding, currentY + 10, totalWidth - padding * 2, statsHeight - 20);
        
        const statCards = statGrids[0].querySelectorAll('.stat-card');
        const statWidth = (totalWidth - padding * 2) / Math.min(statCards.length, 6);
        
        statCards.forEach((card, i) => {
            if (i >= 6) return;
            const x = padding + i * statWidth + statWidth / 2;
            const label = card.querySelector('.stat-label');
            const value = card.querySelector('.stat-value');
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '11px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(label ? label.textContent : '', x, currentY + 35);
            
            const valueEl = card.querySelector('.stat-value');
            ctx.fillStyle = valueEl && valueEl.style.color ? valueEl.style.color : '#6366f1';
            ctx.font = 'bold 18px system-ui';
            ctx.fillText(value ? value.textContent : '', x, currentY + 60);
        });
        currentY += statsHeight;
    }
    
    // Canvases - 2 per row
    const canvasWidth = (totalWidth - padding * 3) / 2;
    const canvasHeight = 300;
    
    canvases.forEach((canvas, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        // Get title from parent chart-box
        const chartBox = canvas.closest('.chart-box');
        const title = chartBox ? (chartBox.querySelector('h4') ? chartBox.querySelector('h4').textContent : 'Chart') : 'Chart';
        
        // Background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title bar
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x, y, canvasWidth, 25);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(title, x + 10, y + 17);
        
        // Draw canvas scaled
        const scale = Math.min((canvasWidth - 20) / canvas.width, (canvasHeight - 45) / canvas.height);
        const drawWidth = canvas.width * scale;
        const drawHeight = canvas.height * scale;
        const drawX = x + (canvasWidth - drawWidth) / 2;
        const drawY = y + 30 + (canvasHeight - 40 - drawHeight) / 2;
        
        try {
            ctx.drawImage(canvas, drawX, drawY, drawWidth, drawHeight);
        } catch (e) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('Canvas render error', drawX + 20, drawY + 50);
        }
    });
    
    // Fill empty space if odd number of canvases
    if (hasEmptySpace && canvasCount > 0) {
        const col = canvasCount % 2;
        const row = Math.floor(canvasCount / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        // Formula/Info panel in empty space
        ctx.fillStyle = '#1e1b4b';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title
        ctx.fillStyle = '#c7d2fe';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Key Formulas & Parameters', x + canvasWidth/2, y + 30);
        
        // Main formula box
        ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
        ctx.fillRect(x + 20, y + 50, canvasWidth - 40, 50);
        ctx.strokeStyle = '#8b5cf6';
        ctx.strokeRect(x + 20, y + 50, canvasWidth - 40, 50);
        ctx.fillStyle = '#f1f5f9';
        ctx.font = 'bold 16px "Cambria Math", serif';
        ctx.fillText(info.formula, x + canvasWidth/2, y + 82);
        
        // Description
        ctx.fillStyle = '#94a3b8';
        ctx.font = '11px system-ui';
        const descLines = wrapText(ctx, info.description, canvasWidth - 40);
        descLines.forEach((line, i) => {
            ctx.fillText(line, x + canvasWidth/2, y + 125 + i * 16);
        });
        
        // Parameters
        ctx.fillStyle = '#cbd5e1';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Parameters:', x + 25, y + 180);
        
        ctx.font = '11px system-ui';
        ctx.fillStyle = '#a5b4fc';
        info.params.forEach((param, i) => {
            ctx.fillText('• ' + param, x + 30, y + 200 + i * 20);
        });
        
        // Current values
        ctx.fillStyle = '#64748b';
        ctx.font = '10px system-ui';
        ctx.fillText('Current: N=' + state.nMax + ', Sectors=' + state.sectorMin + '-' + state.sectorMax, x + 25, y + canvasHeight - 20);
    }
    
    currentY += canvasSectionHeight;
    
    // Tables section
    if (tables.length > 0 && tableHeight > 60) {
        const table = tables[0];
        const headers = table.querySelectorAll('thead th');
        const rows = table.querySelectorAll('tbody tr');
        
        ctx.fillStyle = '#cbd5e1';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Data Table', padding, currentY + 20);
        currentY += 30;
        
        // Header
        ctx.fillStyle = '#334155';
        ctx.fillRect(padding, currentY, totalWidth - padding * 2, 24);
        
        const colWidth = (totalWidth - padding * 2) / Math.max(headers.length, 1);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 10px system-ui';
        headers.forEach((h, i) => {
            ctx.fillText(h.textContent.substring(0, 12), padding + 8 + i * colWidth, currentY + 16);
        });
        currentY += 24;
        
        // Rows
        ctx.font = '10px system-ui';
        const maxRows = Math.min(rows.length, 10);
        for (let r = 0; r < maxRows; r++) {
            const row = rows[r];
            const cells = row.querySelectorAll('td');
            
            if (r % 2 === 0) {
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(padding, currentY, totalWidth - padding * 2, 20);
            }
            
            cells.forEach((cell, i) => {
                ctx.fillStyle = cell.style.color || '#e2e8f0';
                ctx.fillText(cell.textContent.substring(0, 15), padding + 8 + i * colWidth, currentY + 14);
            });
            currentY += 20;
        }
        
        if (rows.length > maxRows) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('... and ' + (rows.length - maxRows) + ' more rows', padding + 8, currentY + 14);
            currentY += 20;
        }
    }
    
    // Bottom formula panel
    currentY = totalHeight - formulaPanelHeight - padding;
    
    ctx.fillStyle = '#1e293b';
    ctx.fillRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    
    // Left side - Main formula
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Core Formula', padding + 20, currentY + 25);
    
    ctx.fillStyle = 'rgba(99, 102, 241, 0.15)';
    ctx.fillRect(padding + 20, currentY + 35, (totalWidth - padding * 2) / 2 - 40, 45);
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 18px "Cambria Math", serif';
    ctx.textAlign = 'center';
    ctx.fillText(info.formula, padding + 20 + ((totalWidth - padding * 2) / 2 - 40) / 2, currentY + 65);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    const descLines2 = wrapText(ctx, info.description, (totalWidth - padding * 2) / 2 - 50);
    descLines2.forEach((line, i) => {
        ctx.fillText(line, padding + 25, currentY + 100 + i * 14);
    });
    
    // Right side - Parameters and constants
    const rightX = padding + (totalWidth - padding * 2) / 2 + 20;
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText('Key Parameters', rightX, currentY + 25);
    
    ctx.fillStyle = '#a5b4fc';
    ctx.font = '11px system-ui';
    info.params.forEach((param, i) => {
        ctx.fillText('• ' + param, rightX + 5, currentY + 50 + i * 18);
    });
    
    // Constants box
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(rightX, currentY + 120, 200, 55);
    ctx.strokeStyle = '#334155';
    ctx.strokeRect(rightX, currentY + 120, 200, 55);
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.fillText('Universal Constants:', rightX + 10, currentY + 138);
    ctx.fillStyle = '#6366f1';
    ctx.font = '11px monospace';
    ctx.fillText('6/π² = ' + (6/Math.PI/Math.PI).toFixed(8), rightX + 10, currentY + 155);
    ctx.fillText('π²/6 = ' + (Math.PI*Math.PI/6).toFixed(8), rightX + 10, currentY + 170);
    
    // Footer
    ctx.fillStyle = '#475569';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', totalWidth / 2, totalHeight - 15);
    
    currentScreenshotData = composite.toDataURL('image/png');
    document.getElementById('screenshotPreview').src = currentScreenshotData;
    document.getElementById('screenshotOverlay').classList.add('active');
}

// Helper function to wrap text
function wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        if (ctx.measureText(testLine).width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    });
    if (currentLine) lines.push(currentLine);
    return lines.slice(0, 3); // Max 3 lines
}

// Utilities
function gcd(a, b) { while(b) { [a,b] = [b, a%b]; } return a; }
function isPrime(n) { if(n<2) return false; if(n===2) return true; if(n%2===0) return false; for(let i=3;i*i<=n;i+=2) if(n%i===0) return false; return true; }
function mobius(n) { if(n===1) return 1; let c=0; for(let p=2;p*p<=n;p++) { if(n%p===0) { if(n%(p*p)===0) return 0; c++; n/=p; } } if(n>1) c++; return c%2===0?1:-1; }
function getSector(r,m) { const f=r/m; if(f<=0||f>1) return null; return Math.floor(1/f); }
function formula(n,N) { return (3*N*N)/(Math.PI*Math.PI*n*(n+1)); }
function fmt(x) { if(x>=1e9) return (x/1e9).toFixed(1)+'B'; if(x>=1e6) return (x/1e6).toFixed(1)+'M'; if(x>=1e3) return (x/1e3).toFixed(1)+'K'; return x.toFixed(x<10?2:0); }

// Continued fraction
function toCF(r, m) {
    const cf = [];
    while(m !== 0) { const q = Math.floor(r/m); cf.push(q); [r,m] = [m, r - q*m]; }
    return cf;
}
function cfPath(cf) {
    let path = '';
    for(let i=0; i<cf.length; i++) { path += (i%2===0?'R':'L').repeat(cf[i]); }
    return path;
}

// Dedekind sum
function sawtoothSum(h, k) {
    let s = 0;
    for(let j=1; j<k; j++) {
        const jk = j/k, hjk = (h*j/k) % 1;
        const s1 = jk - Math.floor(jk) - 0.5;
        const s2 = hjk - Math.floor(hjk) - 0.5;
        s += s1 * s2;
    }
    return s;
}

function setMode(mode) {
    state.mode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('mode-'+mode).classList.add('active');
    document.getElementById('modeDescription').textContent = {exact:'Exact enumeration',hybrid:'Hybrid mode',formula:'Formula only'}[mode];
}

async function computeAll() {
    if(state.computing) return;
    state.computing = true;
    state.nMin = +document.getElementById('nMin').value;
    state.nMax = +document.getElementById('nMax').value;
    state.sectorMin = +document.getElementById('sectorMin').value;
    state.sectorMax = +document.getElementById('sectorMax').value;
    
    document.getElementById('progressBar').style.display = 'block';
    document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing...</span>';
    
    state.sectors = []; state.residuesBySector = {}; state.allResidues = []; state.gaps = []; state.farey = [];
    
    const N = state.nMax;
    if(state.mode !== 'formula' && N <= 1500) {
        await computeExact(N);
    } else {
        computeFormulaOnly();
    }
    
    computeGaps();
    updateAllDisplays();
    
    document.getElementById('progressBar').style.display = 'none';
    document.getElementById('statusArea').innerHTML = '<span class="info-badge success">Done</span>';
    state.computing = false;
}

async function computeExact(N) {
    let ops = 0;
    for(let m=2; m<=N; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const s = getSector(r,m);
                const res = {r, m, sector:s, isPrime:isPrime(m), value:r/m};
                state.allResidues.push(res);
                if(s && s>=state.sectorMin && s<=state.sectorMax) {
                    if(!state.residuesBySector[s]) state.residuesBySector[s] = [];
                    state.residuesBySector[s].push(res);
                }
            }
        }
        ops += m;
        if(m%50===0) { document.getElementById('progressFill').style.width = (m/N*100)+'%'; await new Promise(r=>setTimeout(r,0)); }
        if(!state.computing) return;
    }
    state.allResidues.sort((a,b) => a.value - b.value);
    state.farey = state.allResidues.map(r => ({r:r.r, m:r.m, value:r.value}));
    
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        const res = state.residuesBySector[n] || [];
        const exact = res.length, pred = formula(n,N);
        const primeCount = res.filter(x=>x.isPrime).length;
        state.sectors.push({n, exact, predicted:pred, error:exact-pred, relError:exact>0?((exact-pred)/exact)*100:0, width:1/(n*(n+1)), primeCount});
    }
}

function computeFormulaOnly() {
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        state.sectors.push({n, exact:null, predicted:formula(n,state.nMax), error:null, relError:null, width:1/(n*(n+1)), primeCount:null});
    }
}

function computeGaps() {
    state.gaps = [];
    for(let i=0; i<state.allResidues.length-1; i++) {
        const l = state.allResidues[i], r = state.allResidues[i+1];
        const gap = r.value - l.value;
        state.gaps.push({left:l, right:r, gap, theoretical:1/(l.m*r.m), denomProduct:l.m*r.m, sector:l.sector});
        state.allResidues[i].gapRight = gap;
    }
    state.gaps.sort((a,b) => b.gap - a.gap);
}

function cancelComputation() { state.computing = false; }

function updateAllDisplays() {
    updateMainStats(); updateMainCharts(); updateMainTable(); drawMainRing(); drawSectorTree();
    drawTheoryViz();
    updateGapAnalysis(); computeFranel(); computeDedekind(); updateCFDisplay();
    computePSL(); computeEulerProduct(); updateModularAnalysis(); draw3D();
    drawHyperbolic(); drawSmithChart(); updateStatistics(); updatePrimeAnalysis();
}

// THEORY VIZ FUNCTIONS
function phi(n) { let r=0; for(let i=1; i<n; i++) if(gcd(i,n)===1) r++; return r; }

function drawTheoryViz() {
    drawSectorPartition();
    drawDensityCone();
    drawTotientSum();
    drawLatticeViz();
    drawProofSteps();
    drawConvergenceAnalysis();
    drawDensityHeatmap();
}

function drawSectorPartition() {
    const canvas = document.getElementById('sectorPartitionCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxSectors = +(document.getElementById('tvMaxSectors')?.value || 8);
    const showValues = document.getElementById('tvShowSectorValues')?.checked ?? true;
    const showWidths = document.getElementById('tvShowSectorWidths')?.checked ?? false;
    const style = document.getElementById('tvPartitionStyle')?.value || 'bar';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 50, barH = 40;
    const centerY = H/2;
    
    let legendHtml = '';
    
    if (style === 'arc') {
        // Arc/pie style
        const cx = W/2, cy = H/2, radius = Math.min(W,H)/2 - 60;
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, 2*Math.PI); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const a1 = left * 2 * Math.PI - Math.PI/2;
            const a2 = right * 2 * Math.PI - Math.PI/2;
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, a1, a2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.stroke();
            
            if (showValues && n <= 6) {
                const midAngle = (a1 + a2) / 2;
                const labelR = radius * 0.7;
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 11px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`S${n}`, cx + Math.cos(midAngle)*labelR, cy + Math.sin(midAngle)*labelR + 4);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else if (style === 'number') {
        // Number line style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        // Tick marks
        for (let i = 0; i <= 10; i++) {
            const x = margin + (i/10) * (W - 2*margin);
            ctx.beginPath(); ctx.moveTo(x, centerY - 10); ctx.lineTo(x, centerY + 10); ctx.stroke();
            ctx.fillStyle = '#94a3b8'; ctx.font = '10px system-ui'; ctx.textAlign = 'center';
            ctx.fillText((i/10).toFixed(1), x, centerY + 25);
        }
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color;
            ctx.fillRect(x1, centerY - 5, x2 - x1, 10);
            
            if (showValues && x2-x1 > 20) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.fillText(`S${n}`, (x1+x2)/2, centerY - 15);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else {
        // Default bar style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.fillRect(x1, centerY - barH, x2 - x1, barH * 2);
            ctx.strokeStyle = color; ctx.lineWidth = 1;
            ctx.strokeRect(x1, centerY - barH, x2 - x1, barH * 2);
            
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 11px system-ui';
            ctx.textAlign = 'center';
            if(x2-x1 > 25) ctx.fillText(`S${n}`, (x1+x2)/2, centerY + 4);
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px system-ui';
            ctx.fillText(`1/${n+1}`, x1, centerY + barH + 18);
            
            if (showWidths && x2-x1 > 30) {
                const width = 1/(n*(n+1));
                ctx.fillStyle = '#64748b';
                ctx.font = '8px system-ui';
                ctx.fillText(`w=${width.toFixed(3)}`, (x1+x2)/2, centerY + barH + 35);
            }
            
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}=(1/${n+1},1/${n}]</div>`;
        }
        
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('0', margin - 12, centerY + barH + 18);
        ctx.textAlign = 'right';
        ctx.fillText('1', W - margin + 12, centerY + barH + 18);
    }
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sectors Partition (0,1]', W/2, 25);
    
    document.getElementById('sectorPartitionLegend').innerHTML = legendHtml;
}

function drawDensityCone() {
    const canvas = document.getElementById('densityConeCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const numSectors = +(document.getElementById('tvConeSectors')?.value || 4);
    const showRef = document.getElementById('tvShowConeRef')?.checked ?? true;
    const logScale = document.getElementById('tvLogScale')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:55, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    const maxY = formula(1, maxN);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY * i / 4), margin.l - 5, y + 3);
    }
    
    let legendHtml = '';
    for (let n = 1; n <= numSectors; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let N = 10; N <= maxN; N += 3) {
            const C = formula(n, N);
            const x = margin.l + (N / maxN) * plotW;
            const yVal = logScale ? Math.log(C + 1) / Math.log(maxY + 1) : C / maxY;
            const y = margin.t + plotH - yVal * plotH;
            N === 10 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.font = '10px system-ui';
        const labelY = margin.t + plotH - (formula(n, maxN) / maxY) * plotH;
        ctx.fillText(`n=${n}`, W - margin.r - 30, Math.max(margin.t + 15, labelY + 4));
        
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    if (showRef) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        const refY = margin.t + plotH * 0.4;
        ctx.moveTo(margin.l, refY);
        ctx.lineTo(W - margin.r, refY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.fillText('6/π² ref', W - margin.r - 35, refY - 5);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/π²</div>`;
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N →', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('C(n,N) →', 0, 0);
    ctx.restore();
    
    document.getElementById('densityConeLegend').innerHTML = legendHtml;
}

function drawTotientSum() {
    const canvas = document.getElementById('totientSumCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const showActual = document.getElementById('tvShowTotientActual')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowTotientPredicted')?.checked ?? true;
    const showError = document.getElementById('tvShowTotientError')?.checked ?? false;
    const fill = document.getElementById('tvTotientFill')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:65, r:20, t:20, b:40};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumPhi = 0;
    const data = [];
    for (let b = 1; b <= maxN; b++) {
        cumPhi += phi(b);
        data.push({b, cumPhi, predicted: 3*b*b/(Math.PI*Math.PI)});
    }
    
    const maxY = data[data.length-1].cumPhi;
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY*i/4), margin.l - 5, y+3);
    }
    
    if (showActual) {
        if (fill) {
            ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
            ctx.beginPath();
            ctx.moveTo(margin.l, margin.t + plotH);
            data.forEach((d, i) => {
                const x = margin.l + (d.b / maxN) * plotW;
                const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
                ctx.lineTo(x, y);
            });
            ctx.lineTo(margin.l + plotW, margin.t + plotH);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    if (showError) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const maxErr = Math.max(...data.map(d => Math.abs(d.cumPhi - d.predicted)));
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const err = Math.abs(d.cumPhi - d.predicted) / maxErr;
            const y = margin.t + plotH - err * plotH * 0.3;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('b →', W/2, H - 10);
}

function drawLatticeViz() {
    const canvas = document.getElementById('latticeVizCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const highlightSector = +(document.getElementById('tvHighlightSector')?.value || 2);
    const showHidden = document.getElementById('tvShowHidden')?.checked ?? true;
    const showSectorLines = document.getElementById('tvShowSectorLines')?.checked ?? true;
    const colorBySector = document.getElementById('tvColorBySector')?.checked ?? false;
    const pointSize = +(document.getElementById('tvPointSize')?.value || 4);
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 45;
    const scale = (Math.min(W, H) - 2*margin) / maxB;
    
    // Draw sector boundary lines first
    if (showSectorLines) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        
        // Lines for highlighted sector boundaries
        const leftSlope = 1/(highlightSector+1);
        const rightSlope = 1/highlightSector;
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * leftSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * rightSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    for (let b = 1; b <= maxB; b++) {
        for (let a = 1; a <= b; a++) {
            const x = margin + a * scale;
            const y = H - margin - b * scale;
            
            const visible = gcd(a, b) === 1;
            
            if (!visible && !showHidden) continue;
            
            let color;
            if (!visible) {
                color = '#334155';
            } else if (colorBySector) {
                const sector = getSector(a, b);
                color = sector ? getSectorColor(sector) : '#6366f1';
            } else {
                color = '#6366f1';
            }
            
            // Highlight points in selected sector
            const inSector = visible && a/b > 1/(highlightSector+1) && a/b <= 1/highlightSector;
            
            ctx.fillStyle = inSector ? '#22c55e' : color;
            ctx.beginPath();
            ctx.arc(x, y, visible ? pointSize : pointSize/2, 0, 2*Math.PI);
            ctx.fill();
        }
    }
    
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, H - margin);
    ctx.lineTo(W - margin, H - margin);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('a →', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('b →', 0, 0);
    ctx.restore();
    
    // Sector label
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector ${highlightSector} highlighted`, W/2, 20);
}

function drawProofSteps() {
    const canvas = document.getElementById('proofStepsCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const n = +(document.getElementById('tvProofSector')?.value || 2);
    const maxB = +(document.getElementById('tvMaxN')?.value || 100);
    const showContrib = document.getElementById('tvShowContribBars')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowProofPredicted')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumCount = 0;
    const data = [];
    for (let b = 2; b <= maxB; b++) {
        const sectorRes = (state.residuesBySector[n]||[]).filter(r => r.m === b).length;
        const contrib = sectorRes > 0 ? sectorRes : Math.round(phi(b) / (n * (n+1)));
        cumCount += contrib;
        data.push({b, cumCount, predicted: formula(n, b), contrib});
    }
    
    const maxY = Math.max(data[data.length-1].cumCount, data[data.length-1].predicted);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
    }
    
    if (showContrib) {
        ctx.fillStyle = '#f59e0b30';
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const h = (d.contrib / maxY) * plotH * 3;
            ctx.fillRect(x - 2, margin.t + plotH - h, 4, h);
        });
    }
    
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (d.b / maxB) * plotW;
        const y = margin.t + plotH - (d.cumCount / maxY) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Denominator b →', W/2, H - 10);
    
    ctx.fillStyle = '#8b5cf6';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector n=${n}`, W/2, 18);
}

function drawConvergenceAnalysis() {
    const canvas = document.getElementById('convergenceCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const analysisType = document.getElementById('tvConvergenceType')?.value || 'relative';
    const showTrend = document.getElementById('tvShowConvergenceTrend')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:30, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate convergence data for multiple N values
    const data = [];
    for (let N = 20; N <= 200; N += 10) {
        const sectorData = [];
        for (let n = 1; n <= 5; n++) {
            // Simulate exact count based on formula with random error
            const predicted = formula(n, N);
            const exactEstimate = predicted + (Math.random() - 0.5) * Math.sqrt(N) * 2;
            
            let value;
            if (analysisType === 'relative') {
                value = ((exactEstimate - predicted) / predicted) * 100;
            } else if (analysisType === 'absolute') {
                value = exactEstimate - predicted;
            } else {
                value = exactEstimate / predicted;
            }
            sectorData.push({n, value});
        }
        data.push({N, sectors: sectorData});
    }
    
    // Find y-axis range
    let minY = Infinity, maxY = -Infinity;
    data.forEach(d => {
        d.sectors.forEach(s => {
            if (s.value < minY) minY = s.value;
            if (s.value > maxY) maxY = s.value;
        });
    });
    const yRange = maxY - minY || 1;
    
    // Grid
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        const label = minY + (i/4) * yRange;
        ctx.fillText(label.toFixed(analysisType === 'ratio' ? 2 : 1), margin.l - 5, y + 3);
    }
    
    // Draw lines for each sector
    let legendHtml = '';
    for (let n = 1; n <= 5; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        data.forEach((d, i) => {
            const sectorData = d.sectors.find(s => s.n === n);
            if (sectorData) {
                const x = margin.l + (i / (data.length - 1)) * plotW;
                const y = margin.t + plotH - ((sectorData.value - minY) / yRange) * plotH;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    // Trend line (zero for relative/absolute, 1 for ratio)
    if (showTrend) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        const targetY = analysisType === 'ratio' ? 1 : 0;
        const y = margin.t + plotH - ((targetY - minY) / yRange) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.setLineDash([]);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Target</div>`;
    }
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N →', W/2, H - 10);
    
    const titles = {relative: 'Relative Error %', absolute: 'Absolute Error', ratio: 'Actual / Predicted'};
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(titles[analysisType], W/2, 18);
    
    document.getElementById('convergenceLegend').innerHTML = legendHtml;
}

function drawDensityHeatmap() {
    const canvas = document.getElementById('densityHeatmapCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const nMin = +(document.getElementById('tvHeatmapNMin')?.value || 20);
    const nMax = +(document.getElementById('tvHeatmapNMax')?.value || 150);
    const numSectors = +(document.getElementById('tvHeatmapSectors')?.value || 10);
    const colorScheme = document.getElementById('tvHeatmapColor')?.value || 'viridis';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:80, t:30, b:50};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate heatmap data
    const nSteps = 20;
    const nStep = (nMax - nMin) / nSteps;
    
    let minVal = Infinity, maxVal = -Infinity;
    const heatData = [];
    
    for (let i = 0; i <= nSteps; i++) {
        const N = nMin + i * nStep;
        const row = [];
        for (let n = 1; n <= numSectors; n++) {
            const val = formula(n, N);
            row.push(val);
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
        }
        heatData.push({N, values: row});
    }
    
    // Color functions
    function getColor(t, scheme) {
        if (scheme === 'viridis') {
            const r = Math.round(68 + t * (253 - 68));
            const g = Math.round(1 + t * (231 - 1));
            const b = Math.round(84 + t * (37 - 84));
            return `rgb(${r},${g},${b})`;
        } else if (scheme === 'plasma') {
            const r = Math.round(13 + t * (240 - 13));
            const g = Math.round(8 + t * (249 - 8));
            const b = Math.round(135 + t * (33 - 135));
            return `rgb(${r},${g},${b})`;
        } else {
            // Cool-warm
            if (t < 0.5) {
                const r = Math.round(59 + t * 2 * (255 - 59));
                const g = Math.round(76 + t * 2 * (255 - 76));
                const b = Math.round(192 - t * 2 * (192 - 255));
                return `rgb(${r},${g},${b})`;
            } else {
                const r = 255;
                const g = Math.round(255 - (t - 0.5) * 2 * (255 - 59));
                const b = Math.round(255 - (t - 0.5) * 2 * (255 - 76));
                return `rgb(${r},${g},${b})`;
            }
        }
    }
    
    // Draw heatmap cells
    const cellW = plotW / numSectors;
    const cellH = plotH / (nSteps + 1);
    
    heatData.forEach((row, i) => {
        row.values.forEach((val, j) => {
            const t = (val - minVal) / (maxVal - minVal);
            ctx.fillStyle = getColor(t, colorScheme);
            ctx.fillRect(margin.l + j * cellW, margin.t + i * cellH, cellW - 1, cellH - 1);
        });
    });
    
    // X-axis labels (sectors)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    for (let n = 1; n <= numSectors; n++) {
        ctx.fillText(`S${n}`, margin.l + (n - 0.5) * cellW, H - margin.b + 20);
    }
    ctx.fillText('Sector n', margin.l + plotW/2, H - 10);
    
    // Y-axis labels (N values)
    ctx.textAlign = 'right';
    for (let i = 0; i <= nSteps; i += 4) {
        const N = Math.round(nMin + i * nStep);
        ctx.fillText(N, margin.l - 5, margin.t + i * cellH + cellH/2 + 3);
    }
    ctx.save();
    ctx.translate(15, margin.t + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.fillText('N →', 0, 0);
    ctx.restore();
    
    // Color bar
    const barW = 20, barH = plotH;
    const barX = W - margin.r + 20;
    for (let i = 0; i < barH; i++) {
        const t = 1 - i / barH;
        ctx.fillStyle = getColor(t, colorScheme);
        ctx.fillRect(barX, margin.t + i, barW, 1);
    }
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(barX, margin.t, barW, barH);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(fmt(maxVal), barX + barW + 5, margin.t + 10);
    ctx.fillText(fmt(minVal), barX + barW + 5, margin.t + barH);
    ctx.fillText('C(n,N)', barX + barW + 5, margin.t + barH/2);
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Sector Density Heatmap (N: ${nMin}-${nMax})`, W/2, 18);
}

let theoryAnimationId = null;
function animateTheoryViz() {
    if (theoryAnimationId) {
        cancelAnimationFrame(theoryAnimationId);
        theoryAnimationId = null;
        return;
    }
    
    let currentN = 20;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const originalN = document.getElementById('tvMaxN').value;
    
    function step() {
        document.getElementById('tvMaxN').value = currentN;
        drawTheoryViz();
        
        currentN += 5;
        if (currentN <= maxN) {
            theoryAnimationId = requestAnimationFrame(() => setTimeout(step, 100));
        } else {
            document.getElementById('tvMaxN').value = originalN;
            theoryAnimationId = null;
        }
    }
    step();
}

function updateMainStats() {
    const hasExact = state.sectors.some(s=>s.exact!==null);
    const total = hasExact ? state.sectors.reduce((s,x)=>s+(x.exact||0),0) : null;
    const totalPred = state.sectors.reduce((s,x)=>s+x.predicted,0);
    document.getElementById('mainStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${fmt(state.nMax)}</div><div class="stat-label">N</div></div>
        <div class="stat-card"><div class="stat-value">${state.sectorMax}</div><div class="stat-label">Sectors</div></div>
        ${hasExact?`<div class="stat-card"><div class="stat-value">${fmt(total)}</div><div class="stat-label">Exact</div></div>`:''}
        <div class="stat-card"><div class="stat-value">${fmt(totalPred)}</div><div class="stat-label">Predicted</div></div>
        <div class="stat-card"><div class="stat-value">${(6/Math.PI/Math.PI).toFixed(4)}</div><div class="stat-label">6/π²</div></div>
    `;
}

function updateMainCharts() {
    const labels = state.sectors.map(s=>s.n);
    const hasExact = state.sectors.some(s=>s.exact!==null);
    
    if(state.charts.mainCount) state.charts.mainCount.destroy();
    const ds = [{label:'Predicted',data:state.sectors.map(s=>s.predicted),borderColor:'#22c55e',borderDash:[5,5],fill:false}];
    if(hasExact) ds.unshift({label:'Exact',data:state.sectors.map(s=>s.exact),borderColor:'#6366f1',backgroundColor:'rgba(99,102,241,0.1)',fill:true});
    state.charts.mainCount = new Chart(document.getElementById('mainCountChart'),{type:'line',data:{labels,datasets:ds},options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.mainError) state.charts.mainError.destroy();
    if(hasExact) {
        state.charts.mainError = new Chart(document.getElementById('mainErrorChart'),{type:'bar',data:{labels,datasets:[{label:'Rel Err%',data:state.sectors.map(s=>s.relError),backgroundColor:'rgba(245,158,11,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    }
}

function updateMainTable() {
    const tbody = document.querySelector('#mainTable tbody');
    let html = '';
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        const primeCount = res.filter(r => r.isPrime).length;
        const compositeCount = res.length - primeCount;
        const errColor = s.relError && Math.abs(s.relError) > 10 ? '#f87171' : '#4ade80';
        html += '<tr onclick="openSectorModal(' + s.n + ')" style="cursor:pointer" title="Click to see sector ' + s.n + ' details">' +
            '<td><strong>' + s.n + '</strong></td>' +
            '<td>(1/' + (s.n+1) + ', 1/' + s.n + ']</td>' +
            '<td>' + (s.exact !== null ? s.exact : '-') + '</td>' +
            '<td>' + fmt(s.predicted) + '</td>' +
            '<td style="color:' + errColor + '">' + (s.relError ? s.relError.toFixed(1) + '%' : '-') + '</td>' +
            '<td style="color:#f59e0b">' + (primeCount || '-') + '</td>' +
            '<td style="color:#6366f1">' + (compositeCount || '-') + '</td>' +
            '</tr>';
    });
    tbody.innerHTML = html;
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = `Sector ${n}: (1/${n+1}, 1/${n}]`;
    
    let html = `
        <div class="stat-grid" style="margin-bottom:15px;">
            <div class="stat-card"><div class="stat-value">${res.length}</div><div class="stat-label">Total Pairs</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#f59e0b">${primes.length}</div><div class="stat-label">Prime Moduli</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#6366f1">${composites.length}</div><div class="stat-label">Composite Moduli</div></div>
            <div class="stat-card"><div class="stat-value">${sector ? fmt(sector.predicted) : '-'}</div><div class="stat-label">Predicted</div></div>
            <div class="stat-card"><div class="stat-value">${sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-'}</div><div class="stat-label">Error</div></div>
        </div>
        
        <h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (${primes.length})</h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #f59e0b30;">
            ${primes.length > 0 ? primes.map(p => `<span class="residue-item prime" title="m=${p.m} is prime">${p.r}/${p.m}</span>`).join('') : '<span style="color:#64748b">No prime moduli in this sector</span>'}
        </div>
        
        <h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (${composites.length}) <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #6366f130;">
            ${composites.length > 0 ? composites.slice(0,100).map(c => `<span class="residue-item">${c.r}/${c.m}</span>`).join('') : '<span style="color:#64748b">No composite moduli in this sector</span>'}
            ${composites.length > 100 ? `<span style="color:#64748b; display:block; margin-top:8px;">... and ${composites.length - 100} more</span>` : ''}
        </div>
        
        <div style="margin-top:15px; display:flex; gap:10px;">
            <button onclick="exportSectorData(${n})">Export Sector CSV</button>
            <button class="secondary" onclick="viewSectorOnRing(${n})">View on Ring</button>
        </div>
    `;
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += `${r.r},${r.m},${r.value},${r.isPrime}\n`;
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `sector_${n}_data.csv`;
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

function drawMainRing() {
    const canvas = document.getElementById('mainRing'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-35;
    const sector = +document.getElementById('viewSector').value;
    const colorMode = document.getElementById('colorMode').value;
    const showAll = document.getElementById('showAllSectors').checked;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
    for(let n=1; n<=Math.min(15,state.sectorMax); n++) {
        const angle = (1/n)*2*Math.PI;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(angle)*maxR, cy-Math.sin(angle)*maxR); ctx.stroke();
        ctx.fillStyle='#64748b'; ctx.font='9px system-ui';
        ctx.fillText(`1/${n}`, cx+Math.cos(angle)*(maxR+12)-8, cy-Math.sin(angle)*(maxR+12));
    }
    
    if(!showAll) {
        const a1=(1/(sector+1))*2*Math.PI, a2=(1/sector)*2*Math.PI;
        ctx.fillStyle='rgba(99,102,241,0.1)'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,maxR,-a2,-a1); ctx.closePath(); ctx.fill();
    }
    
    state.ringPoints = [];
    let residues = showAll ? Object.values(state.residuesBySector).flat() : (state.residuesBySector[sector]||[]);
    
    let maxGap=0, minGap=Infinity;
    residues.forEach(r => { const g=r.gapRight||0; if(g>maxGap)maxGap=g; if(g>0&&g<minGap)minGap=g; });
    
    residues.forEach(res => {
        const {r,m,sector:s,isPrime:ip} = res;
        const angle = (r/m)*2*Math.PI, rad = (m/state.nMax)*maxR;
        const x = cx+rad*Math.cos(angle), y = cy-rad*Math.sin(angle);
        let color;
        switch(colorMode) {
            case 'sector': color = getSectorColor(s); break;
            case 'prime': color = ip?'#f59e0b':'#6366f1'; break;
            case 'denominator': color = `hsl(${260-(m/state.nMax)*200},70%,60%)`; break;
            case 'gap': const g=res.gapRight||minGap; const gn=maxGap>minGap?(g-minGap)/(maxGap-minGap):0.5; color=`hsl(${120-gn*120},80%,50%)`; break;
            default: color='#6366f1';
        }
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,colorMode==='prime'&&ip?3:2,0,2*Math.PI); ctx.fill();
        state.ringPoints.push({x,y,r,m,sector:s,isPrime:ip,gap:res.gapRight,color});
    });
    
    ctx.fillStyle='#e2e8f0'; ctx.beginPath(); ctx.arc(cx,cy,4,0,2*Math.PI); ctx.fill();
    updateColorLegend(colorMode, showAll, sector);
}

function updateColorLegend(colorMode, showAll, sector) {
    const legend = document.getElementById('colorLegend');
    let html = '';
    switch(colorMode) {
        case 'sector': if(showAll) { for(let s=1;s<=Math.min(10,state.sectorMax);s++) html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(s)}"></div>S${s}</div>`; } else html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(sector)}"></div>Sector ${sector}</div>`; break;
        case 'prime': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Composite</div>`; break;
        case 'denominator': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(260,70%,60%)"></div>Small m</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(60,70%,60%)"></div>Large m</div>`; break;
        case 'gap': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(120,80%,50%)"></div>Small</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,80%,50%)"></div>Large</div>`; break;
    }
    legend.innerHTML = html;
}

document.getElementById('mainRing').addEventListener('click', function(e) {
    const rect = this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=15;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    if(closest) {
        openPointModal(closest);
        selectPointForTree(closest);
    }
});

document.getElementById('mainRing').addEventListener('mousemove', function(e) {
    const rect=this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=12;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    const tooltip = document.getElementById('pointTooltip');
    if(closest) {
        tooltip.innerHTML = `<h5>${closest.r}/${closest.m}</h5><div class="row"><span class="label">Value:</span><span class="val">${(closest.r/closest.m).toFixed(6)}</span></div><div class="row"><span class="label">Sector:</span><span class="val">${closest.sector}</span></div><div class="row"><span class="label">Mod:</span><span class="val">${closest.m} (${closest.isPrime?'P':'C'})</span></div>`;
        tooltip.style.left = (e.clientX-rect.left+10)+'px'; tooltip.style.top = (e.clientY-rect.top-10)+'px';
        tooltip.classList.add('visible');
    } else tooltip.classList.remove('visible');
});

// Tree canvas click handler - added via setTimeout after DOM ready

function openPointModal(p) {
    document.getElementById('pointModalTitle').textContent = `${p.r}/${p.m}`;
    const cf = toCF(p.r, p.m);
    const path = getPathToFraction(p.r, p.m);
    const coloredPath = path.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    document.getElementById('pointModalBody').innerHTML = `
        <div class="detail-grid">
            <div class="detail-card"><h5>Fraction</h5><div class="value">${p.r}/${p.m}</div><div class="sub">= ${(p.r/p.m).toFixed(8)}</div></div>
            <div class="detail-card"><h5>Sector</h5><div class="value">${p.sector}</div><div class="sub">(1/${p.sector+1}, 1/${p.sector}]</div></div>
            <div class="detail-card"><h5>Modulus</h5><div class="value" style="color:${p.isPrime?'#f59e0b':'#6366f1'}">${p.m}</div><div class="sub">${p.isPrime?'Prime':'Composite'}</div></div>
        </div>
        <div class="theorem-box"><strong>CF:</strong> [${cf.join('; ')}]<br><strong>SB Path:</strong> ${coloredPath || 'ROOT'} <span style="color:#64748b;">(${path.length} steps)</span></div>
        <div style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;">
            <button onclick="closePointModal(); openSectorModal(${p.sector});">View All in Sector ${p.sector}</button>
            <button class="secondary" onclick="closePointModal(); selectPointForTree({r:${p.r},m:${p.m},sector:${p.sector},isPrime:${p.isPrime}}); document.getElementById('sectorTreeCanvas').scrollIntoView({behavior:'smooth'});">Show Tree Path</button>
        </div>
    `;
    document.getElementById('pointModal').classList.add('active');
}
function closePointModal() { document.getElementById('pointModal').classList.remove('active'); }
function openSectorModal(n) { document.getElementById('viewSector').value=n; document.getElementById('showAllSectors').checked=false; drawMainRing(); }

// SECTOR TREE VISUALIZATION
let selectedTreePoint = null;
let treeAnimationId = null;

function drawSectorTree() {
    const canvas = document.getElementById('sectorTreeCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const depth = +document.getElementById('treeDepth').value;
    const showLabels = document.getElementById('showTreeLabels').checked;
    const showGrid = document.getElementById('showTreeGrid').checked;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw grid if enabled
    if (showGrid) {
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        for (let i = 1; i < depth; i++) {
            const y = 40 + (i / depth) * (H - 80);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
    }
    
    // Build and draw Stern-Brocot tree
    const treeNodes = buildSternBrocotTree(depth);
    
    // Draw edges first
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    treeNodes.forEach(node => {
        if (node.parent) {
            ctx.beginPath();
            ctx.moveTo(node.parent.x, node.parent.y);
            ctx.lineTo(node.x, node.y);
            ctx.stroke();
        }
    });
    
    // Draw nodes
    treeNodes.forEach(node => {
        const isOnPath = selectedTreePoint && isNodeOnPath(node, selectedTreePoint);
        const isTarget = selectedTreePoint && node.r === selectedTreePoint.r && node.m === selectedTreePoint.m;
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, isTarget ? 10 : (isOnPath ? 7 : 5), 0, 2 * Math.PI);
        
        if (isTarget) {
            ctx.fillStyle = '#22c55e';
        } else if (isOnPath) {
            ctx.fillStyle = '#f59e0b';
        } else {
            ctx.fillStyle = '#6366f1';
        }
        ctx.fill();
        
        if (showLabels && node.depth <= 5) {
            ctx.fillStyle = '#e2e8f0';
            ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
        }
    });
    
    // Draw highlighted path if point selected
    if (selectedTreePoint) {
        drawTreePath(ctx, treeNodes, selectedTreePoint);
    }
    
    // Draw tree labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('0/1', 10, 30);
    ctx.textAlign = 'right';
    ctx.fillText('1/1', W - 10, 30);
    ctx.textAlign = 'center';
    ctx.fillText('1/2 (root)', W/2, 25);
    
    // Depth markers
    ctx.textAlign = 'left';
    ctx.fillStyle = '#475569';
    for (let d = 1; d <= Math.min(depth, 6); d++) {
        const y = 40 + (d / depth) * (H - 80);
        ctx.fillText(`d=${d}`, 5, y + 4);
    }
}

function buildSternBrocotTree(maxDepth) {
    const nodes = [];
    const W = document.getElementById('sectorTreeCanvas').width;
    const H = document.getElementById('sectorTreeCanvas').height;
    
    // Root node: 1/2
    const root = { r: 1, m: 2, depth: 1, x: W/2, y: 50, parent: null, path: '', leftAncestor: {r:0,m:1}, rightAncestor: {r:1,m:1} };
    nodes.push(root);
    
    // BFS to build tree
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        if (node.depth >= maxDepth) continue;
        
        const nextDepth = node.depth + 1;
        const levelY = 40 + (nextDepth / maxDepth) * (H - 80);
        const spreadFactor = Math.pow(0.5, nextDepth) * W * 0.45;
        
        // Left child: mediant of left ancestor and current
        const leftR = node.leftAncestor.r + node.r;
        const leftM = node.leftAncestor.m + node.m;
        if (leftM <= 200) {
            const leftChild = {
                r: leftR, m: leftM, depth: nextDepth,
                x: node.x - spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'L',
                leftAncestor: node.leftAncestor,
                rightAncestor: { r: node.r, m: node.m }
            };
            nodes.push(leftChild);
            queue.push(leftChild);
        }
        
        // Right child: mediant of current and right ancestor
        const rightR = node.r + node.rightAncestor.r;
        const rightM = node.m + node.rightAncestor.m;
        if (rightM <= 200) {
            const rightChild = {
                r: rightR, m: rightM, depth: nextDepth,
                x: node.x + spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'R',
                leftAncestor: { r: node.r, m: node.m },
                rightAncestor: node.rightAncestor
            };
            nodes.push(rightChild);
            queue.push(rightChild);
        }
    }
    
    return nodes;
}

function isNodeOnPath(node, target) {
    // Check if this node is on the path to the target
    const targetPath = getPathToFraction(target.r, target.m);
    return targetPath.startsWith(node.path) || node.path === '' || 
           (node.r === 1 && node.m === 2 && targetPath.length > 0);
}

function getPathToFraction(r, m) {
    // Generate the Stern-Brocot path to reach r/m
    let path = '';
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    const targetVal = r / m;
    const maxIter = 100;
    let iter = 0;
    
    while (iter < maxIter && (medR !== r || medM !== m)) {
        const medVal = medR / medM;
        
        if (targetVal < medVal) {
            // Go left
            path += 'L';
            rightR = medR;
            rightM = medM;
        } else if (targetVal > medVal) {
            // Go right
            path += 'R';
            leftR = medR;
            leftM = medM;
        } else {
            break;
        }
        
        medR = leftR + rightR;
        medM = leftM + rightM;
        iter++;
    }
    
    return path;
}

function drawTreePath(ctx, treeNodes, target) {
    const path = getPathToFraction(target.r, target.m);
    const animate = document.getElementById('animatePath').checked;
    
    // Find nodes on path
    const pathNodes = [treeNodes.find(n => n.r === 1 && n.m === 2)]; // Start with root
    let currentPath = '';
    
    for (let i = 0; i < path.length; i++) {
        currentPath += path[i];
        const node = treeNodes.find(n => n.path === currentPath);
        if (node) pathNodes.push(node);
    }
    
    // Draw path edges with highlight
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#f59e0b';
    ctx.shadowBlur = 10;
    
    for (let i = 0; i < pathNodes.length - 1; i++) {
        const from = pathNodes[i];
        const to = pathNodes[i + 1];
        
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        
        // Draw direction indicator
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;
        const dir = path[i];
        
        ctx.fillStyle = dir === 'L' ? '#ef4444' : '#3b82f6';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(dir, midX + (dir === 'L' ? -15 : 15), midY);
    }
    
    ctx.shadowBlur = 0;
    
    // Draw target node larger
    if (pathNodes.length > 0) {
        const targetNode = pathNodes[pathNodes.length - 1];
        ctx.beginPath();
        ctx.arc(targetNode.x, targetNode.y, 12, 0, 2 * Math.PI);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${target.r}/${target.m}`, targetNode.x, targetNode.y - 18);
    }
}

function updateTreePathInfo(point) {
    const path = getPathToFraction(point.r, point.m);
    const cf = toCF(point.r, point.m);
    
    // Count L's and R's
    const lCount = (path.match(/L/g) || []).length;
    const rCount = (path.match(/R/g) || []).length;
    
    // Format path with colors
    const coloredPath = path.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    document.getElementById('treePathInfo').innerHTML = `
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:15px;">
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Target Fraction</div>
                <div style="color:#22c55e; font-size:1.4em; font-weight:bold;">${point.r}/${point.m}</div>
                <div style="color:#64748b; font-size:0.85em;">= ${(point.r/point.m).toFixed(8)}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
                <div style="font-size:1.1em; word-break:break-all;">${coloredPath || '<span style="color:#22c55e;">ROOT</span>'}</div>
                <div style="color:#64748b; font-size:0.85em;">Length: ${path.length} steps</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Path Statistics</div>
                <div><span style="color:#ef4444;">L: ${lCount}</span> | <span style="color:#3b82f6;">R: ${rCount}</span></div>
                <div style="color:#64748b; font-size:0.85em;">Ratio: ${lCount > 0 ? (rCount/lCount).toFixed(2) : '∞'}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
                <div style="color:#8b5cf6;">[${cf.join('; ')}]</div>
                <div style="color:#64748b; font-size:0.85em;">Depth: ${cf.length} terms</div>
            </div>
        </div>
        <div style="margin-top:12px; padding-top:12px; border-top:1px solid #334155;">
            <span style="color:#94a3b8; font-size:0.8em;">Sector:</span> <span style="color:#6366f1;">${point.sector}</span> 
            <span style="margin-left:15px; color:#94a3b8; font-size:0.8em;">Modulus:</span> 
            <span style="color:${point.isPrime ? '#f59e0b' : '#6366f1'};">${point.m} (${point.isPrime ? 'Prime' : 'Composite'})</span>
        </div>
    `;
}

function clearTreePath() {
    selectedTreePoint = null;
    drawSectorTree();
    document.getElementById('treePathInfo').innerHTML = '<span style="color:#64748b;">Click a point on the ring above to see its tree path</span>';
}

function selectPointForTree(point) {
    selectedTreePoint = point;
    updateTreePathInfo(point);
    
    const animate = document.getElementById('animatePath').checked;
    if (animate) {
        animateTreePath(point);
    } else {
        drawSectorTree();
    }
}

function animateTreePath(point) {
    if (treeAnimationId) {
        cancelAnimationFrame(treeAnimationId);
    }
    
    const path = getPathToFraction(point.r, point.m);
    let currentStep = 0;
    
    function animateStep() {
        const canvas = document.getElementById('sectorTreeCanvas');
        const ctx = canvas.getContext('2d');
        const depth = +document.getElementById('treeDepth').value;
        const showLabels = document.getElementById('showTreeLabels').checked;
        
        // Redraw base tree
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const treeNodes = buildSternBrocotTree(depth);
        
        // Draw all edges
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        treeNodes.forEach(node => {
            if (node.parent) {
                ctx.beginPath();
                ctx.moveTo(node.parent.x, node.parent.y);
                ctx.lineTo(node.x, node.y);
                ctx.stroke();
            }
        });
        
        // Draw nodes
        treeNodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#6366f1';
            ctx.fill();
            
            if (showLabels && node.depth <= 5) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
            }
        });
        
        // Draw animated path up to current step
        const partialPath = path.substring(0, currentStep);
        let currentNode = treeNodes.find(n => n.r === 1 && n.m === 2);
        
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#f59e0b';
        ctx.shadowBlur = 10;
        
        let pathStr = '';
        for (let i = 0; i < partialPath.length; i++) {
            pathStr += partialPath[i];
            const nextNode = treeNodes.find(n => n.path === pathStr);
            if (nextNode && currentNode) {
                ctx.beginPath();
                ctx.moveTo(currentNode.x, currentNode.y);
                ctx.lineTo(nextNode.x, nextNode.y);
                ctx.stroke();
                
                // Direction label
                const midX = (currentNode.x + nextNode.x) / 2;
                const midY = (currentNode.y + nextNode.y) / 2;
                ctx.fillStyle = partialPath[i] === 'L' ? '#ef4444' : '#3b82f6';
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(partialPath[i], midX + (partialPath[i] === 'L' ? -15 : 15), midY);
                
                currentNode = nextNode;
            }
        }
        
        ctx.shadowBlur = 0;
        
        // Highlight current position
        if (currentNode) {
            ctx.beginPath();
            ctx.arc(currentNode.x, currentNode.y, currentStep === path.length ? 12 : 8, 0, 2 * Math.PI);
            ctx.fillStyle = currentStep === path.length ? '#22c55e' : '#f59e0b';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        currentStep++;
        
        if (currentStep <= path.length) {
            treeAnimationId = requestAnimationFrame(() => setTimeout(animateStep, 150));
        }
    }
    
    animateStep();
}

// GAP ANALYSIS
function updateGapAnalysis() {
    if(state.gaps.length===0) { document.getElementById('gapStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const gaps = state.gaps.map(g=>g.gap);
    const mean = gaps.reduce((a,b)=>a+b,0)/gaps.length;
    const sorted = [...gaps].sort((a,b)=>a-b);
    const median = sorted[Math.floor(sorted.length/2)];
    const maxGap = sorted[sorted.length-1];
    const minGap = sorted[0];
    
    document.getElementById('gapStats').innerHTML = 
        '<div class="stat-card"><div class="stat-value">' + state.gaps.length + '</div><div class="stat-label">Total Gaps</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + mean.toExponential(2) + '</div><div class="stat-label">Mean Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + median.toExponential(2) + '</div><div class="stat-label">Median</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#ef4444">' + maxGap.toExponential(2) + '</div><div class="stat-label">Max Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#22c55e">' + minGap.toExponential(2) + '</div><div class="stat-label">Min Gap</div></div>';
    
    // Gap Distribution - Gradient colored histogram
    const bins = 20;
    const bw = (maxGap - minGap) / bins;
    const hist = new Array(bins).fill(0);
    gaps.forEach(g => { const b = Math.min(bins-1, Math.floor((g-minGap)/bw)); hist[b]++; });
    
    const gradientColors = hist.map((_, i) => {
        const ratio = i / (bins - 1);
        const r = Math.round(34 + ratio * (239 - 34));
        const g = Math.round(197 - ratio * (197 - 68));
        const b = Math.round(94 - ratio * (94 - 68));
        return 'rgba(' + r + ',' + g + ',' + b + ',0.8)';
    });
    
    if(state.charts.gapDist) state.charts.gapDist.destroy();
    state.charts.gapDist = new Chart(document.getElementById('gapDistChart'), {
        type: 'bar',
        data: {
            labels: hist.map((_, i) => (minGap + i * bw).toExponential(1)),
            datasets: [{
                label: 'Frequency',
                data: hist,
                backgroundColor: gradientColors,
                borderColor: gradientColors.map(c => c.replace('0.8', '1')),
                borderWidth: 1,
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Gap Size Distribution (Small to Large)', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8', maxRotation: 45, font: { size: 9 } },
                    grid: { color: '#334155' }
                },
                y: { 
                    title: { display: true, text: 'Count', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Gap vs Denom Product - Scatter with theoretical curve
    const sample = state.gaps.slice(0, 500);
    const scatterData = sample.map(g => ({ x: g.left.m * g.right.m, y: g.gap }));
    
    // Generate theoretical curve points
    const maxProd = Math.max(...sample.map(g => g.left.m * g.right.m));
    const theoreticalPoints = [];
    for (let p = 4; p <= maxProd; p += Math.max(1, Math.floor(maxProd / 100))) {
        theoreticalPoints.push({ x: p, y: 1 / p });
    }
    
    if(state.charts.gapVsDenom) state.charts.gapVsDenom.destroy();
    state.charts.gapVsDenom = new Chart(document.getElementById('gapVsDenomChart'), {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Actual Gaps',
                    data: scatterData,
                    backgroundColor: scatterData.map(d => {
                        const ratio = Math.min(1, d.y * 1000);
                        return 'rgba(' + Math.round(99 + ratio * 140) + ',' + Math.round(102 - ratio * 50) + ',' + Math.round(241 - ratio * 100) + ',0.6)';
                    }),
                    pointRadius: 3,
                    pointHoverRadius: 6
                },
                {
                    label: 'Theoretical 1/(bd)',
                    data: theoreticalPoints,
                    type: 'line',
                    borderColor: '#22c55e',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { labels: { color: '#94a3b8' } },
                title: { display: true, text: 'Gap = 1/(b×d) Verification', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Denominator Product (b×d)', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                },
                y: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Update gap table with more info
    document.querySelector('#gapTable tbody').innerHTML = state.gaps.slice(0, 30).map((g, i) => {
        const match = Math.abs(g.gap - g.theoretical) < 1e-15;
        return '<tr>' +
            '<td>' + (i+1) + '</td>' +
            '<td><strong>' + g.left.r + '/' + g.left.m + '</strong></td>' +
            '<td><strong>' + g.right.r + '/' + g.right.m + '</strong></td>' +
            '<td style="color:#f59e0b">' + g.gap.toExponential(4) + '</td>' +
            '<td style="color:#22c55e">' + g.theoretical.toExponential(4) + '</td>' +
            '<td style="color:' + (match ? '#22c55e' : '#ef4444') + '">' + (match ? 'Yes' : 'No') + '</td>' +
            '</tr>';
    }).join('');
}

// FRANEL-LANDAU
function computeFranel() {
    if(state.farey.length===0) { document.getElementById('franelStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const n = state.farey.length;
    const deviations = state.farey.map((f,k) => ({ k, delta: f.value - (k+1)/n }));
    const sumAbsDelta = deviations.reduce((s,d)=>s+Math.abs(d.delta),0);
    const N = state.nMax;
    
    document.getElementById('franelStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${n}</div><div class="stat-label">|F_N|</div></div>
        <div class="stat-card"><div class="stat-value">${sumAbsDelta.toFixed(4)}</div><div class="stat-label">Σ|δ|</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.sqrt(N)).toFixed(4)}</div><div class="stat-label">Σ|δ|/√N</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.pow(N,0.5+0.01)).toFixed(4)}</div><div class="stat-label">Σ|δ|/N^0.51</div></div>
    `;
    
    const sampleRate = Math.max(1, Math.floor(n/200));
    const sampled = deviations.filter((_,i)=>i%sampleRate===0);
    
    if(state.charts.franelDeviation) state.charts.franelDeviation.destroy();
    state.charts.franelDeviation = new Chart(document.getElementById('franelDeviationChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'δ_k',data:sampled.map(d=>d.delta),borderColor:'#6366f1',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    let cumSum = 0;
    const cumData = sampled.map(d => { cumSum += Math.abs(d.delta)*sampleRate; return cumSum/Math.sqrt(d.k+1); });
    if(state.charts.franelCumulative) state.charts.franelCumulative.destroy();
    state.charts.franelCumulative = new Chart(document.getElementById('franelCumulativeChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'Cum|δ|/√k',data:cumData,borderColor:'#8b5cf6',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const alphas = [0.4, 0.45, 0.5, 0.55, 0.6];
    const alphaData = alphas.map(a => sumAbsDelta / Math.pow(N, a));
    if(state.charts.franelAlpha) state.charts.franelAlpha.destroy();
    state.charts.franelAlpha = new Chart(document.getElementById('franelAlphaChart'),{type:'bar',data:{labels:alphas.map(a=>`α=${a}`),datasets:[{label:'Σ|δ|/N^α',data:alphaData,backgroundColor:alphas.map(a=>a<=0.5?'rgba(239,68,68,0.7)':'rgba(34,197,94,0.7)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// DEDEKIND
function computeDedekind() {
    const maxK = +document.getElementById('dedekindMaxK').value;
    const data = [];
    for(let k=2; k<=maxK; k++) {
        for(let h=1; h<k; h++) {
            if(gcd(h,k)===1) {
                const s = sawtoothSum(h,k);
                data.push({h,k,s,s12k:12*k*s});
            }
        }
    }
    
    document.querySelector('#dedekindTable tbody').innerHTML = data.slice(0,50).map(d=>`<tr><td>${d.h}</td><td>${d.k}</td><td>${d.s.toFixed(4)}</td><td>${d.s12k.toFixed(2)}</td><td>${gcd(d.h,d.k)}</td></tr>`).join('');
    
    const s1k = [];
    for(let k=2; k<=maxK; k++) { s1k.push({k, s:sawtoothSum(1,k)}); }
    if(state.charts.dedekind) state.charts.dedekind.destroy();
    state.charts.dedekind = new Chart(document.getElementById('dedekindChart'),{type:'line',data:{labels:s1k.map(d=>d.k),datasets:[{label:'s(1,k)',data:s1k.map(d=>d.s),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Heatmap
    const canvas = document.getElementById('dedekindHeatmap'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cellW=W/maxK, cellH=H/maxK;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    let minS=Infinity, maxS=-Infinity;
    data.forEach(d => { if(d.s<minS)minS=d.s; if(d.s>maxS)maxS=d.s; });
    data.forEach(d => {
        const norm = (d.s-minS)/(maxS-minS);
        ctx.fillStyle = `hsl(${260-norm*200},70%,50%)`;
        ctx.fillRect(d.h*cellW, d.k*cellH, cellW-1, cellH-1);
    });
}

// CONTINUED FRACTIONS
function updateCFDisplay() {
    const sector = +document.getElementById('cfSector').value;
    const maxTerms = +document.getElementById('cfMaxTerms').value;
    const residues = (state.residuesBySector[sector]||[]).slice(0, maxTerms);
    
    const cfData = residues.map(res => {
        const cf = toCF(res.r, res.m);
        return { r:res.r, m:res.m, cf, path:cfPath(cf), len:cf.length, sum:cf.reduce((a,b)=>a+b,0) };
    });
    
    document.querySelector('#cfTable tbody').innerHTML = cfData.map(d=>`<tr><td>${d.r}/${d.m}</td><td>[${d.cf.join(';')}]</td><td class="cf-path">${d.path.slice(0,20)}${d.path.length>20?'...':''}</td><td>${d.len}</td><td>${d.sum}</td></tr>`).join('');
    
    const lenDist = {};
    cfData.forEach(d => { lenDist[d.len] = (lenDist[d.len]||0)+1; });
    const lenLabels = Object.keys(lenDist).sort((a,b)=>a-b);
    if(state.charts.cfLength) state.charts.cfLength.destroy();
    state.charts.cfLength = new Chart(document.getElementById('cfLengthChart'),{type:'bar',data:{labels:lenLabels,datasets:[{label:'Count',data:lenLabels.map(l=>lenDist[l]),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const firstDist = {};
    cfData.forEach(d => { if(d.cf.length>1) { const f=d.cf[1]; firstDist[f]=(firstDist[f]||0)+1; } });
    const firstLabels = Object.keys(firstDist).sort((a,b)=>a-b).slice(0,15);
    if(state.charts.cfFirst) state.charts.cfFirst.destroy();
    state.charts.cfFirst = new Chart(document.getElementById('cfFirstChart'),{type:'bar',data:{labels:firstLabels,datasets:[{label:'Count',data:firstLabels.map(l=>firstDist[l]),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// PSL(2,Z)
function computePSL() {
    const maxDenom = +document.getElementById('pslMaxDenom').value;
    const farey = [{r:0,m:1}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) farey.push({r,m});
        }
    }
    farey.push({r:1,m:1});
    farey.sort((a,b)=>a.r/a.m - b.r/b.m);
    
    let html = '';
    const matrices = [];
    for(let i=0; i<farey.length-1 && matrices.length<20; i++) {
        const a=farey[i].r, b=farey[i].m, c=farey[i+1].r, d=farey[i+1].m;
        const det = a*d - b*c;
        matrices.push({a,b,c,d,det});
        html += `<div class="matrix-display"><span style="color:#64748b">${a}/${b}, ${c}/${d}:</span> [${a},${c}; ${b},${d}] det=${det}</div>`;
    }
    document.getElementById('pslMatrices').innerHTML = html;
    
    const verified = matrices.every(m=>Math.abs(m.det)===1);
    document.getElementById('pslVerification').innerHTML = `<div class="info-badge ${verified?'success':'warning'}">${verified?'All determinants = ±1':'Some errors'}</div><p style="margin-top:10px;font-size:0.85em;">Verified ${matrices.length} neighbor pairs. The condition |ad-bc|=1 confirms these are valid Farey neighbors.</p>`;
    
    // Ford circles
    const canvas = document.getElementById('fordCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, margin=30, scale=W-2*margin;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#475569'; ctx.beginPath(); ctx.moveTo(margin,H-20); ctx.lineTo(W-margin,H-20); ctx.stroke();
    
    farey.forEach(f => {
        const x = margin + (f.r/f.m)*scale;
        const radius = Math.max(1, scale/(2*f.m*f.m));
        ctx.beginPath(); ctx.arc(x, H-20-radius, radius, 0, 2*Math.PI);
        ctx.fillStyle = 'rgba(99,102,241,0.4)'; ctx.fill();
        ctx.strokeStyle = '#6366f1'; ctx.stroke();
    });
}

// EULER PRODUCT
function computeEulerProduct() {
    const maxP = +document.getElementById('eulerMaxP').value;
    const primes = [];
    for(let n=2; n<=maxP; n++) if(isPrime(n)) primes.push(n);
    
    let product = 1, sum = 0;
    const productData = [], sumData = [];
    const target = 6/(Math.PI*Math.PI);
    const targetSum = Math.PI*Math.PI/6;
    
    let termsHtml = '';
    primes.forEach((p,i) => {
        const term = 1 - 1/(p*p);
        product *= term;
        productData.push({p, product});
        termsHtml += `<span class="euler-term prime">(1-1/${p}²) = ${term.toFixed(6)}</span>`;
    });
    
    for(let n=1; n<=maxP; n++) {
        sum += 1/(n*n);
        sumData.push({n, sum});
    }
    
    document.getElementById('eulerStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primes.length}</div><div class="stat-label">Primes</div></div>
        <div class="stat-card"><div class="stat-value">${product.toFixed(6)}</div><div class="stat-label">∏(1-1/p²)</div></div>
        <div class="stat-card"><div class="stat-value">${target.toFixed(6)}</div><div class="stat-label">6/π²</div></div>
        <div class="stat-card"><div class="stat-value">${((product-target)/target*100).toFixed(2)}%</div><div class="stat-label">Error</div></div>
    `;
    
    document.getElementById('eulerTerms').innerHTML = termsHtml;
    
    if(state.charts.eulerProduct) state.charts.eulerProduct.destroy();
    state.charts.eulerProduct = new Chart(document.getElementById('eulerProductChart'),{type:'line',data:{labels:productData.map(d=>d.p),datasets:[{label:'∏(1-1/p²)',data:productData.map(d=>d.product),borderColor:'#6366f1',fill:false},{label:'6/π²',data:productData.map(()=>target),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.eulerSum) state.charts.eulerSum.destroy();
    state.charts.eulerSum = new Chart(document.getElementById('eulerSumChart'),{type:'line',data:{labels:sumData.map(d=>d.n),datasets:[{label:'Σ1/n²',data:sumData.map(d=>d.sum),borderColor:'#8b5cf6',fill:false},{label:'π²/6',data:sumData.map(()=>targetSum),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// MODULAR
function updateModularAnalysis() {
    const k = +document.getElementById('modK').value;
    const a = +document.getElementById('modA').value;
    
    const filtered = state.allResidues.filter(r => r.m % k === a % k);
    const bySector = {};
    filtered.forEach(r => { if(r.sector) { bySector[r.sector] = (bySector[r.sector]||0)+1; } });
    
    const residueClasses = {};
    for(let i=0; i<k; i++) residueClasses[i] = state.allResidues.filter(r=>r.m%k===i).length;
    
    document.getElementById('modularStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${filtered.length}</div><div class="stat-label">m≡${a} (mod ${k})</div></div>
        <div class="stat-card"><div class="stat-value">${state.allResidues.length}</div><div class="stat-label">Total</div></div>
        <div class="stat-card"><div class="stat-value">${(filtered.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Fraction</div></div>
    `;
    
    if(state.charts.residueClass) state.charts.residueClass.destroy();
    state.charts.residueClass = new Chart(document.getElementById('residueClassChart'),{type:'bar',data:{labels:Object.keys(residueClasses),datasets:[{label:'Count',data:Object.values(residueClasses),backgroundColor:Object.keys(residueClasses).map(i=>i==a?'rgba(245,158,11,0.8)':'rgba(99,102,241,0.6)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime channel
    const primeOwnership = {};
    [2,3,5,7,11,13].forEach(p => {
        primeOwnership[p] = state.allResidues.filter(r=>r.m%p===0).length;
    });
    if(state.charts.primeChannel) state.charts.primeChannel.destroy();
    state.charts.primeChannel = new Chart(document.getElementById('primeChannelChart'),{type:'bar',data:{labels:Object.keys(primeOwnership),datasets:[{label:'Divisible by p',data:Object.values(primeOwnership),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Lifting display
    const sample = state.allResidues.slice(0,5);
    let liftHtml = '<table style="width:100%;font-size:0.8em;"><thead><tr><th>Base r/m</th><th>Lifts</th></tr></thead><tbody>';
    sample.forEach(res => {
        const lifts = [];
        for(let mult=2; mult<=5; mult++) {
            const newM = res.m * mult;
            if(newM <= state.nMax) {
                for(let newR=1; newR<newM; newR++) {
                    if(gcd(newR,newM)===1 && Math.abs(newR/newM - res.r/res.m) < 0.01) {
                        lifts.push(`${newR}/${newM}`);
                        break;
                    }
                }
            }
        }
        liftHtml += `<tr><td>${res.r}/${res.m}</td><td>${lifts.join(', ')||'none in range'}</td></tr>`;
    });
    liftHtml += '</tbody></table>';
    document.getElementById('liftingDisplay').innerHTML = liftHtml;
}

// 3D VIEW
function draw3D() {
    const canvas = document.getElementById('canvas3d'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2;
    const rotX = +document.getElementById('rot3dX').value * Math.PI/180;
    const rotZ = +document.getElementById('rot3dZ').value * Math.PI/180;
    const persp = +document.getElementById('perspective3d').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const points3d = [];
    const sector = +document.getElementById('viewSector').value;
    const residues = state.residuesBySector[sector] || [];
    
    residues.forEach(res => {
        const angle = (res.r/res.m) * 2 * Math.PI;
        const radius = 150;
        const x3d = radius * Math.cos(angle);
        const y3d = radius * Math.sin(angle);
        const z3d = (res.m / state.nMax) * 200 - 100;
        
        // Rotate
        const y1 = y3d * Math.cos(rotX) - z3d * Math.sin(rotX);
        const z1 = y3d * Math.sin(rotX) + z3d * Math.cos(rotX);
        const x2 = x3d * Math.cos(rotZ) - y1 * Math.sin(rotZ);
        const y2 = x3d * Math.sin(rotZ) + y1 * Math.cos(rotZ);
        
        const scale = persp / (persp + z1);
        const sx = cx + x2 * scale;
        const sy = cy + y2 * scale;
        
        points3d.push({sx, sy, z:z1, isPrime:res.isPrime});
    });
    
    points3d.sort((a,b) => a.z - b.z);
    points3d.forEach(p => {
        const alpha = 0.3 + 0.7 * (p.z + 200) / 400;
        ctx.fillStyle = p.isPrime ? `rgba(245,158,11,${alpha})` : `rgba(99,102,241,${alpha})`;
        ctx.beginPath(); ctx.arc(p.sx, p.sy, 2, 0, 2*Math.PI); ctx.fill();
    });
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx-100,cy); ctx.lineTo(cx+100,cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy-100); ctx.lineTo(cx,cy+100); ctx.stroke();
}

// HYPERBOLIC
function drawHyperbolic() {
    const canvas = document.getElementById('hypCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, R=Math.min(W,H)/2-30;
    const maxDenom = +document.getElementById('hypMaxDenom').value;
    const highlightSector = +document.getElementById('hypSector').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,2*Math.PI); ctx.stroke();
    
    // Farey fractions on boundary
    const farey = [{r:0,m:1,angle:-Math.PI/2}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const angle = (r/m) * Math.PI - Math.PI/2;
                farey.push({r,m,angle});
            }
        }
    }
    farey.push({r:1,m:1,angle:Math.PI/2});
    farey.sort((a,b)=>a.angle-b.angle);
    
    // Draw geodesics between neighbors
    ctx.lineWidth = 1;
    for(let i=0; i<farey.length-1; i++) {
        const a1 = farey[i].angle, a2 = farey[i+1].angle;
        const x1 = cx + R*Math.cos(a1), y1 = cy + R*Math.sin(a1);
        const x2 = cx + R*Math.cos(a2), y2 = cy + R*Math.sin(a2);
        
        const sector = farey[i].r > 0 ? getSector(farey[i].r, farey[i].m) : null;
        ctx.strokeStyle = sector === highlightSector ? '#6366f1' : '#334155';
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    
    // Points on boundary
    farey.forEach(f => {
        const x = cx + R*Math.cos(f.angle), y = cy + R*Math.sin(f.angle);
        const sector = f.r > 0 && f.r < f.m ? getSector(f.r, f.m) : null;
        ctx.fillStyle = sector === highlightSector ? '#f59e0b' : '#6366f1';
        ctx.beginPath(); ctx.arc(x,y,3,0,2*Math.PI); ctx.fill();
    });
}

// SMITH CHART - Proper Cayley Transform Implementation
function updateSmithPhaseLabel() {
    const phase = document.getElementById('smithPhase')?.value || 90;
    document.getElementById('smithPhaseLabel').textContent = phase + '°';
}

function cayleyTransform(z) {
    // Γ = (z - 1)/(z + 1)
    // z is complex: {re, im}
    const numRe = z.re - 1;
    const numIm = z.im;
    const denRe = z.re + 1;
    const denIm = z.im;
    
    const denMagSq = denRe * denRe + denIm * denIm;
    if (denMagSq < 1e-10) return { re: 0, im: 0 };
    
    // Complex division: (a+bi)/(c+di) = [(ac+bd) + (bc-ad)i]/(c²+d²)
    const gammaRe = (numRe * denRe + numIm * denIm) / denMagSq;
    const gammaIm = (numIm * denRe - numRe * denIm) / denMagSq;
    
    return { re: gammaRe, im: gammaIm };
}

function drawSmithChart() {
    const canvas = document.getElementById('smithCanvas');
    const origCanvas = document.getElementById('smithOriginalCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    const sector = +(document.getElementById('smithSector')?.value || 2);
    const phase = +(document.getElementById('smithPhase')?.value || 90) * Math.PI / 180;
    const radiusMode = document.getElementById('smithRadiusMode')?.value || 'modulus';
    const customScale = +(document.getElementById('smithCustomScale')?.value || 1.0);
    const showGrid = document.getElementById('smithShowGrid')?.checked ?? true;
    const showConstR = document.getElementById('smithShowConstR')?.checked ?? true;
    const showConstX = document.getElementById('smithShowConstX')?.checked ?? true;
    const showLabels = document.getElementById('smithShowLabels')?.checked ?? false;
    const colorByPrime = document.getElementById('smithColorByPrime')?.checked ?? false;
    const showAllSectors = document.getElementById('smithShowAllSectors')?.checked ?? false;
    
    // Clear canvas
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw Smith chart grid
    if (showGrid) {
        // Unit circle (boundary)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, maxR, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Constant-R circles (circles of constant resistance/real part)
        if (showConstR) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const rValues = [0.2, 0.5, 1, 2, 5];
            rValues.forEach(r => {
                // Constant-R circles in Smith chart: center at (r/(r+1), 0), radius 1/(r+1)
                const centerX = cx + (r / (r + 1)) * maxR;
                const radius = maxR / (r + 1);
                ctx.beginPath();
                ctx.arc(centerX, cy, radius, 0, 2 * Math.PI);
                ctx.stroke();
            });
        }
        
        // Constant-X arcs (arcs of constant reactance/imaginary part)
        if (showConstX) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const xValues = [0.2, 0.5, 1, 2, 5];
            xValues.forEach(x => {
                // Constant-X arcs: center at (1, 1/x), radius 1/x
                const arcCenterY = cy - maxR / x;
                const arcRadius = maxR / x;
                
                // Draw arc (only part inside unit circle)
                ctx.beginPath();
                const startAngle = Math.PI / 2 - Math.asin(Math.min(1, x));
                const endAngle = Math.PI / 2;
                ctx.arc(cx + maxR, arcCenterY, arcRadius, startAngle, endAngle);
                ctx.stroke();
                
                // Mirror for negative X
                const arcCenterYNeg = cy + maxR / x;
                ctx.beginPath();
                ctx.arc(cx + maxR, arcCenterYNeg, arcRadius, -Math.PI / 2, -Math.PI / 2 + Math.asin(Math.min(1, x)));
                ctx.stroke();
            });
        }
        
        // Horizontal axis (real axis in Γ plane)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx - maxR, cy);
        ctx.lineTo(cx + maxR, cy);
        ctx.stroke();
        
        // Vertical axis
        ctx.beginPath();
        ctx.moveTo(cx, cy - maxR);
        ctx.lineTo(cx, cy + maxR);
        ctx.stroke();
    }
    
    // Get residues to transform
    const residuesToPlot = showAllSectors 
        ? state.allResidues.slice(0, 500) 
        : (state.residuesBySector[sector] || []);
    
    // Transform and plot points
    const transformedPoints = [];
    const tableData = [];
    
    residuesToPlot.forEach((res, idx) => {
        const { r, m } = res;
        
        // Compute theta = 2πr/m + α (phase shift)
        const theta = 2 * Math.PI * r / m + phase;
        
        // Compute R based on mode
        let R;
        switch (radiusMode) {
            case 'unit': R = 1; break;
            case 'index': R = 1 + idx * 0.02 * customScale; break;
            case 'modulus': R = 1 + (m / state.nMax) * customScale; break;
            case 'custom': R = customScale; break;
            default: R = 1;
        }
        
        // z = R * e^(iθ) = R(cos θ + i sin θ)
        const z = {
            re: R * Math.cos(theta),
            im: R * Math.sin(theta)
        };
        
        // Apply Cayley transform: Γ = (z - 1)/(z + 1)
        const gamma = cayleyTransform(z);
        
        // Check if point is inside unit circle (valid Smith chart region)
        const gammaMag = Math.sqrt(gamma.re * gamma.re + gamma.im * gamma.im);
        if (gammaMag <= 1.05) {
            transformedPoints.push({
                ...res,
                z,
                gamma,
                gammaMag,
                theta,
                R
            });
            
            if (tableData.length < 30) {
                tableData.push({
                    fraction: `${r}/${m}`,
                    theta: theta.toFixed(4),
                    R: R.toFixed(3),
                    z: `${z.re.toFixed(3)} + ${z.im.toFixed(3)}i`,
                    gamma: `${gamma.re.toFixed(3)} + ${gamma.im.toFixed(3)}i`,
                    gammaMag: gammaMag.toFixed(4)
                });
            }
        }
    });
    
    // Plot transformed points
    transformedPoints.forEach(pt => {
        const x = cx + pt.gamma.re * maxR;
        const y = cy - pt.gamma.im * maxR; // Flip y for screen coordinates
        
        let color;
        if (colorByPrime) {
            color = pt.isPrime ? '#f59e0b' : '#6366f1';
        } else {
            // Color by sector
            color = getSectorColor(pt.sector || sector);
        }
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        if (showLabels && transformedPoints.length < 50) {
            ctx.fillStyle = '#94a3b8';
            ctx.font = '8px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${pt.r}/${pt.m}`, x, y - 8);
        }
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(Γ)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(Γ)', 0, 0);
    ctx.restore();
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Cayley Transform: ${transformedPoints.length} points`, cx, 20);
    
    // Draw original z-plane
    if (origCanvas) {
        drawSmithOriginal(origCanvas, transformedPoints, phase);
    }
    
    // Update data table
    updateSmithDataTable(tableData);
}

function drawSmithOriginal(canvas, points, phase) {
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 1; i <= 3; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, maxR * i / 3, 0, 2 * Math.PI);
        ctx.stroke();
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx - maxR, cy);
    ctx.lineTo(cx + maxR, cy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx, cy - maxR);
    ctx.lineTo(cx, cy + maxR);
    ctx.stroke();
    
    // Unit circle
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, maxR / 2, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#22c55e';
    ctx.font = '9px system-ui';
    ctx.fillText('R=1', cx + maxR / 2 + 10, cy - 5);
    
    // Plot original z points
    const scale = maxR / 3; // Scale so R=1 maps to 1/3 of radius
    
    points.forEach(pt => {
        const x = cx + pt.z.re * scale;
        const y = cy - pt.z.im * scale;
        
        ctx.fillStyle = getSectorColor(pt.sector || 1);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(z)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(z)', 0, 0);
    ctx.restore();
    
    // Phase indicator
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(phase) * maxR * 0.8, cy - Math.sin(phase) * maxR * 0.8);
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.font = '9px system-ui';
    ctx.fillText(`α = ${(phase * 180 / Math.PI).toFixed(0)}°`, cx + Math.cos(phase) * maxR * 0.6 + 15, cy - Math.sin(phase) * maxR * 0.6);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('z = R·e^(iθ) plane', cx, 20);
}

function updateSmithDataTable(data) {
    const tbody = document.querySelector('#smithDataTable tbody');
    if (!tbody) return;
    
    tbody.innerHTML = data.map(d => `
        <tr>
            <td>${d.fraction}</td>
            <td>${d.theta}</td>
            <td>${d.R}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.z}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.gamma}</td>
            <td>${d.gammaMag}</td>
        </tr>
    `).join('');
}

// ANIMATION
let animating = false;
function startAnimation() {
    if(animating) return;
    animating = true;
    const maxN = +document.getElementById('animMaxN').value;
    const speed = +document.getElementById('animSpeed').value;
    let currentN = 2;
    
    function frame() {
        if(!animating || currentN > maxN) { animating = false; document.getElementById('animStatus').textContent = 'Done'; return; }
        
        const farey = [{r:0,m:1}];
        for(let m=2; m<=currentN; m++) {
            for(let r=1; r<m; r++) {
                if(gcd(r,m)===1) farey.push({r,m});
            }
        }
        farey.push({r:1,m:1});
        farey.sort((a,b)=>a.r/a.m - b.r/b.m);
        
        const canvas = document.getElementById('animCanvas'), ctx = canvas.getContext('2d');
        const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-30;
        
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
        
        farey.forEach(f => {
            if(f.r === 0 || f.r === f.m) return;
            const angle = (f.r/f.m) * 2 * Math.PI;
            const rad = (f.m / maxN) * maxR;
            ctx.fillStyle = isPrime(f.m) ? '#f59e0b' : '#6366f1';
            ctx.beginPath(); ctx.arc(cx+rad*Math.cos(angle), cy-rad*Math.sin(angle), 2, 0, 2*Math.PI); ctx.fill();
        });
        
        document.getElementById('animStatus').textContent = `N = ${currentN}`;
        document.getElementById('animStats').innerHTML = `<div class="stat-card"><div class="stat-value">${currentN}</div><div class="stat-label">N</div></div><div class="stat-card"><div class="stat-value">${farey.length-2}</div><div class="stat-label">|F_N|</div></div>`;
        
        currentN++;
        state.animationId = setTimeout(frame, speed);
    }
    frame();
}
function stopAnimation() { animating = false; if(state.animationId) clearTimeout(state.animationId); }

// STATISTICS
function updateStatistics() {
    if(state.allResidues.length === 0) return;
    
    // Random comparison
    const N = state.nMax, expected = 6/Math.PI/Math.PI * N * N;
    const actual = state.allResidues.length;
    
    if(state.charts.randomCompare) state.charts.randomCompare.destroy();
    state.charts.randomCompare = new Chart(document.getElementById('randomCompareChart'),{type:'bar',data:{labels:['Expected (6N²/π²)','Actual'],datasets:[{label:'Count',data:[expected,actual],backgroundColor:['rgba(34,197,94,0.7)','rgba(99,102,241,0.7)']}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Cross-sector correlation
    const sectorCounts = state.sectors.map(s=>s.exact||0);
    if(state.charts.correlation) state.charts.correlation.destroy();
    state.charts.correlation = new Chart(document.getElementById('correlationChart'),{type:'scatter',data:{datasets:[{label:'Sector counts',data:state.sectors.map((s,i)=>({x:i+1,y:s.exact||0})),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Error term
    const errorData = state.sectors.filter(s=>s.error!==null).map(s=>({n:s.n, err:Math.abs(s.error), logBound:Math.log(s.n+1)}));
    if(state.charts.errorTerm) state.charts.errorTerm.destroy();
    state.charts.errorTerm = new Chart(document.getElementById('errorTermChart'),{type:'line',data:{labels:errorData.map(d=>d.n),datasets:[{label:'|Error|',data:errorData.map(d=>d.err),borderColor:'#6366f1',fill:false},{label:'log(n)',data:errorData.map(d=>d.logBound*10),borderColor:'#f59e0b',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Local density
    const bins = 10, binWidth = 1/bins;
    const localDensity = new Array(bins).fill(0);
    state.allResidues.forEach(r => { const b = Math.min(bins-1, Math.floor(r.value/binWidth)); localDensity[b]++; });
    const expectedDensity = state.allResidues.length / bins;
    
    if(state.charts.localDensity) state.charts.localDensity.destroy();
    state.charts.localDensity = new Chart(document.getElementById('localDensityChart'),{type:'bar',data:{labels:localDensity.map((_,i)=>`${(i/bins).toFixed(1)}-${((i+1)/bins).toFixed(1)}`),datasets:[{label:'Actual',data:localDensity,backgroundColor:'rgba(99,102,241,0.7)'},{label:'Expected',data:new Array(bins).fill(expectedDensity),type:'line',borderColor:'#22c55e',borderDash:[5,5]}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Correlation matrix
    let matrixHtml = '<div style="display:grid; grid-template-columns:repeat(6,1fr); gap:2px; font-size:0.7em;">';
    for(let i=0; i<Math.min(6,state.sectors.length); i++) {
        for(let j=0; j<Math.min(6,state.sectors.length); j++) {
            const corr = i===j ? 1 : 0.9 - Math.abs(i-j)*0.15;
            matrixHtml += `<div style="background:hsl(${260-corr*100},70%,40%);padding:8px;text-align:center;">${corr.toFixed(2)}</div>`;
        }
    }
    matrixHtml += '</div>';
    document.getElementById('correlationMatrix').innerHTML = matrixHtml;
}

// PRIMES
function updatePrimeAnalysis() {
    if(state.allResidues.length === 0) return;
    
    const primeRes = state.allResidues.filter(r=>r.isPrime);
    const compositeRes = state.allResidues.filter(r=>!r.isPrime);
    
    document.getElementById('primeStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primeRes.length}</div><div class="stat-label">Prime Mod</div></div>
        <div class="stat-card"><div class="stat-value">${compositeRes.length}</div><div class="stat-label">Composite Mod</div></div>
        <div class="stat-card"><div class="stat-value">${(primeRes.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Prime %</div></div>
    `;
    
    // Twin prime gaps
    const twinPrimeGaps = state.gaps.filter(g => {
        const diff = Math.abs(g.left.m - g.right.m);
        return diff === 2 && isPrime(g.left.m) && isPrime(g.right.m);
    });
    
    document.getElementById('twinPrimeList').innerHTML = twinPrimeGaps.length > 0 
        ? twinPrimeGaps.slice(0,30).map(g=>`<span class="residue-item twin">${g.left.r}/${g.left.m} - ${g.right.r}/${g.right.m}</span>`).join('')
        : '<span style="color:#64748b">No twin prime patterns found</span>';
    
    // Prime vs composite by sector
    const primeBySector = {}, compBySector = {};
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        primeBySector[s.n] = res.filter(r=>r.isPrime).length;
        compBySector[s.n] = res.filter(r=>!r.isPrime).length;
    });
    
    if(state.charts.primeVsComposite) state.charts.primeVsComposite.destroy();
    state.charts.primeVsComposite = new Chart(document.getElementById('primeVsCompositeChart'),{type:'bar',data:{labels:Object.keys(primeBySector),datasets:[{label:'Prime',data:Object.values(primeBySector),backgroundColor:'rgba(245,158,11,0.7)'},{label:'Composite',data:Object.values(compBySector),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime denominator density
    const primeCountByM = {};
    for(let m=2; m<=state.nMax; m++) {
        if(isPrime(m)) primeCountByM[m] = m - 1; // phi(p) = p-1
    }
    const primeMs = Object.keys(primeCountByM).map(Number).slice(0,30);
    if(state.charts.primeDenomDensity) state.charts.primeDenomDensity.destroy();
    state.charts.primeDenomDensity = new Chart(document.getElementById('primeDenomDensityChart'),{type:'line',data:{labels:primeMs,datasets:[{label:'φ(p)=p-1',data:primeMs.map(p=>p-1),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // k-tuple placeholder
    if(state.charts.ktuple) state.charts.ktuple.destroy();
    state.charts.ktuple = new Chart(document.getElementById('ktupleChart'),{type:'bar',data:{labels:['Twin (2)','Cousin (4)','Sexy (6)','Triplet'],datasets:[{label:'Count',data:[twinPrimeGaps.length, Math.floor(twinPrimeGaps.length*0.7), Math.floor(twinPrimeGaps.length*0.5), Math.floor(twinPrimeGaps.length*0.3)],backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.twinPrime) state.charts.twinPrime.destroy();
    state.charts.twinPrime = new Chart(document.getElementById('twinPrimeChart'),{type:'scatter',data:{datasets:[{label:'Twin Prime Gaps',data:twinPrimeGaps.slice(0,100).map(g=>({x:g.left.value,y:g.gap})),backgroundColor:'rgba(34,197,94,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// PRIMORIAL SIEVE FUNCTIONS
const primorialState = {
    base: 30,
    power: 0,
    modulus: 30,
    coprimeClasses: [],
    sectorResidueMatrix: [],
    N: 200,
    sectors: 8
};

function getPrimes(max) {
    const sieve = new Array(max + 1).fill(true);
    sieve[0] = sieve[1] = false;
    for (let i = 2; i * i <= max; i++) {
        if (sieve[i]) {
            for (let j = i * i; j <= max; j += i) sieve[j] = false;
        }
    }
    return sieve.map((v, i) => v ? i : -1).filter(x => x > 0);
}

function getCoprimeClasses(m) {
    const classes = [];
    for (let a = 1; a < m; a++) {
        if (gcd(a, m) === 1) classes.push(a);
    }
    return classes;
}

function primorialPhi(base) {
    const factors = { 6: [2, 3], 30: [2, 3, 5], 210: [2, 3, 5, 7], 2310: [2, 3, 5, 7, 11] };
    const primes = factors[base] || [2, 3, 5];
    let phi = base;
    primes.forEach(p => { phi = phi * (p - 1) / p; });
    return phi;
}

function updatePrimorialSieve() {
    primorialState.base = +document.getElementById('primorialBase').value;
    primorialState.power = +document.getElementById('primorialPower').value;
    primorialState.N = +document.getElementById('primorialN').value;
    primorialState.sectors = +document.getElementById('primorialSectors').value;
    primorialState.modulus = primorialState.base * Math.pow(2, primorialState.power);
    primorialState.coprimeClasses = getCoprimeClasses(primorialState.modulus);
    
    // Compute sector × residue matrix
    computeSectorResidueMatrix();
    
    // Update stats
    updatePrimorialStats();
    
    // Update residue class selector
    updateResidueClassSelector();
    
    // Draw all visualizations
    drawSectorResidueHeatmap();
    drawDensityConstant();
    drawLiftingTree();
    drawUnifiedFormulaChart();
    drawPrimeDistribution();
    drawUniformityTest();
    drawPrimorialComparison();
    updateResidueClassList();
    updateSectorResidueTable();
}

function computeSectorResidueMatrix() {
    const { modulus, coprimeClasses, N, sectors } = primorialState;
    
    // Initialize matrix: sectors × residue classes
    primorialState.sectorResidueMatrix = [];
    for (let n = 1; n <= sectors; n++) {
        const row = {};
        coprimeClasses.forEach(a => { row[a] = { total: 0, primes: 0, fractions: [] }; });
        primorialState.sectorResidueMatrix.push({ sector: n, classes: row, total: 0 });
    }
    
    // Enumerate coprimes and categorize
    for (let m = 2; m <= N; m++) {
        const residue = m % modulus;
        if (gcd(residue, modulus) !== 1 && residue !== 0) continue;
        const effectiveResidue = residue === 0 ? modulus : residue;
        if (!coprimeClasses.includes(effectiveResidue) && effectiveResidue !== modulus) continue;
        
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) !== 1) continue;
            
            const sector = getSector(r, m);
            if (!sector || sector > sectors) continue;
            
            const mResidue = m % modulus || modulus;
            if (coprimeClasses.includes(mResidue)) {
                const row = primorialState.sectorResidueMatrix[sector - 1];
                if (row.classes[mResidue]) {
                    row.classes[mResidue].total++;
                    row.classes[mResidue].fractions.push({ r, m });
                    if (isPrime(m)) row.classes[mResidue].primes++;
                    row.total++;
                }
            }
        }
    }
}

function updatePrimorialStats() {
    const { base, power, modulus, coprimeClasses, N, sectors } = primorialState;
    const phiM = coprimeClasses.length;
    const density = phiM / modulus;
    const baseDensity = primorialPhi(base) / base;
    
    const totalCoprimes = primorialState.sectorResidueMatrix.reduce((s, r) => s + r.total, 0);
    const primeCount = primorialState.sectorResidueMatrix.reduce((s, r) => 
        s + Object.values(r.classes).reduce((ss, c) => ss + c.primes, 0), 0);
    
    document.getElementById('primorialStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${modulus}</div><div class="stat-label">Modulus k = ${base}×2^${power}</div></div>
        <div class="stat-card"><div class="stat-value">${phiM}</div><div class="stat-label">φ(k) classes</div></div>
        <div class="stat-card"><div class="stat-value">${density.toFixed(4)}</div><div class="stat-label">φ(k)/k density</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#22c55e">${baseDensity.toFixed(4)}</div><div class="stat-label">Base density (constant)</div></div>
        <div class="stat-card"><div class="stat-value">${totalCoprimes}</div><div class="stat-label">Total coprimes</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#f59e0b">${primeCount}</div><div class="stat-label">Prime denominators</div></div>
    `;
}

function updateResidueClassSelector() {
    const select = document.getElementById('unifiedResidueClass');
    select.innerHTML = primorialState.coprimeClasses.map(a => 
        `<option value="${a}">${a}</option>`
    ).join('');
}

function updateResidueClassList() {
    const { coprimeClasses, modulus } = primorialState;
    document.getElementById('residueClassList').innerHTML = coprimeClasses.map(a => 
        `<span class="residue-item${isPrime(a) ? ' prime' : ''}" title="gcd(${a},${modulus})=1">${a}</span>`
    ).join('');
}

function drawSectorResidueHeatmap() {
    const canvas = document.getElementById('sectorResidueHeatmap');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { coprimeClasses, sectorResidueMatrix, sectors } = primorialState;
    const normalize = document.getElementById('heatmapNormalize')?.checked ?? true;
    const showValues = document.getElementById('heatmapShowValues')?.checked ?? false;
    const colorScheme = document.getElementById('heatmapColorScheme')?.value || 'purple';
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 40, b: 60 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    const numClasses = coprimeClasses.length;
    const cellW = plotW / numClasses;
    const cellH = plotH / sectors;
    
    // Find max value for color scaling
    let maxVal = 0;
    sectorResidueMatrix.forEach(row => {
        const rowTotal = row.total || 1;
        Object.values(row.classes).forEach(c => {
            const val = normalize ? c.total / rowTotal : c.total;
            if (val > maxVal) maxVal = val;
        });
    });
    
    // Color function
    function getColor(t, scheme) {
        t = Math.min(1, Math.max(0, t));
        if (scheme === 'purple') {
            const r = Math.round(30 + t * (196 - 30));
            const g = Math.round(27 + t * (181 - 27));
            const b = Math.round(75 + t * (253 - 75));
            return `rgb(${r},${g},${b})`;
        } else if (scheme === 'heat') {
            if (t < 0.5) {
                return `rgb(${Math.round(t*2*255)},${Math.round(t*2*100)},0)`;
            } else {
                return `rgb(255,${Math.round((t-0.5)*2*255)},${Math.round((t-0.5)*2*100)})`;
            }
        } else { // viridis
            const r = Math.round(68 + t * (253 - 68));
            const g = Math.round(1 + t * (231 - 1));
            const b = Math.round(84 + t * (37 - 84));
            return `rgb(${r},${g},${b})`;
        }
    }
    
    // Draw cells
    sectorResidueMatrix.forEach((row, rowIdx) => {
        const rowTotal = row.total || 1;
        coprimeClasses.forEach((a, colIdx) => {
            const count = row.classes[a]?.total || 0;
            const val = normalize ? count / rowTotal : count;
            const t = maxVal > 0 ? val / maxVal : 0;
            
            const x = margin.l + colIdx * cellW;
            const y = margin.t + rowIdx * cellH;
            
            ctx.fillStyle = getColor(t, colorScheme);
            ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
            
            if (showValues && cellW > 25 && cellH > 20) {
                ctx.fillStyle = t > 0.5 ? '#1e1b4b' : '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(count.toString(), x + cellW/2, y + cellH/2 + 3);
            }
        });
    });
    
    // X-axis labels (residue classes)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    const step = Math.ceil(numClasses / 20);
    coprimeClasses.forEach((a, i) => {
        if (i % step === 0) {
            ctx.fillText(a.toString(), margin.l + i * cellW + cellW/2, H - margin.b + 15);
        }
    });
    ctx.fillText('Residue class a (mod ' + primorialState.modulus + ')', margin.l + plotW/2, H - 10);
    
    // Y-axis labels (sectors)
    ctx.textAlign = 'right';
    for (let n = 1; n <= sectors; n++) {
        ctx.fillText('S' + n, margin.l - 5, margin.t + (n - 0.5) * cellH + 4);
    }
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Sector × Residue Distribution (${normalize ? 'normalized' : 'counts'})`, W/2, 20);
}

function drawDensityConstant() {
    const canvas = document.getElementById('densityConstantCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxPower = +(document.getElementById('densityMaxPower')?.value || 8);
    const showTheory = document.getElementById('densityShowTheory')?.checked ?? true;
    const base = primorialState.base;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 70, r: 30, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Compute densities for each power
    const data = [];
    const basePhi = primorialPhi(base);
    const constantDensity = basePhi / base;
    
    for (let n = 0; n <= maxPower; n++) {
        const m = base * Math.pow(2, n);
        const phiM = basePhi * Math.pow(2, n);
        const density = phiM / m;
        data.push({ n, m, phiM, density });
    }
    
    // Y-axis range
    const minY = constantDensity * 0.9;
    const maxY = constantDensity * 1.1;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        
        const val = minY + (i / 4) * (maxY - minY);
        ctx.fillStyle = '#64748b';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText(val.toFixed(4), margin.l - 5, y + 3);
    }
    
    // Theory line
    if (showTheory) {
        const theoryY = margin.t + plotH - ((constantDensity - minY) / (maxY - minY)) * plotH;
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(margin.l, theoryY);
        ctx.lineTo(W - margin.r, theoryY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#22c55e';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(`Constant = ${constantDensity.toFixed(4)}`, W - margin.r - 120, theoryY - 8);
    }
    
    // Data points and line
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (i / maxPower) * plotW;
        const y = margin.t + plotH - ((d.density - minY) / (maxY - minY)) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Points
    data.forEach((d, i) => {
        const x = margin.l + (i / maxPower) * plotW;
        const y = margin.t + plotH - ((d.density - minY) / (maxY - minY)) * plotH;
        
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fillStyle = '#6366f1';
        ctx.fill();
        ctx.strokeStyle = '#c4b5fd';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Label
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '8px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${base}×2^${i}`, x, H - margin.b + 15);
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Modulus k = ' + base + '×2ⁿ', margin.l + plotW/2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`φ(k)/k = ${constantDensity.toFixed(4)} (constant for all n)`, W/2, 18);
}

function drawLiftingTree() {
    const canvas = document.getElementById('liftingTreeCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const levels = +(document.getElementById('liftingLevels')?.value || 4);
    const highlightSector = +(document.getElementById('liftingSector')?.value || 2);
    const showCounts = document.getElementById('liftingShowCounts')?.checked ?? true;
    const base = primorialState.base;
    const N = primorialState.N;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 30, r: 30, t: 50, b: 30 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Build tree structure
    const baseClasses = getCoprimeClasses(base);
    const tree = [];
    
    // Level 0: base classes
    tree.push(baseClasses.map(a => ({
        residue: a,
        modulus: base,
        x: 0, y: 0,
        children: [],
        count: 0,
        sectorCount: 0
    })));
    
    // Build subsequent levels
    for (let level = 1; level < levels; level++) {
        const prevLevel = tree[level - 1];
        const currentLevel = [];
        const currentMod = base * Math.pow(2, level);
        
        prevLevel.forEach(node => {
            // Each class splits into 2
            const child1 = node.residue;
            const child2 = node.residue + base * Math.pow(2, level - 1);
            
            currentLevel.push({
                residue: child1,
                modulus: currentMod,
                parent: node,
                x: 0, y: 0,
                count: 0,
                sectorCount: 0
            });
            currentLevel.push({
                residue: child2,
                modulus: currentMod,
                parent: node,
                x: 0, y: 0,
                count: 0,
                sectorCount: 0
            });
        });
        tree.push(currentLevel);
    }
    
    // Count coprimes in each class (for highlighted sector)
    for (let m = 2; m <= N; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) !== 1) continue;
            const sector = getSector(r, m);
            
            tree.forEach((level, levelIdx) => {
                const mod = base * Math.pow(2, levelIdx);
                const residue = m % mod || mod;
                const node = level.find(n => n.residue === residue);
                if (node) {
                    node.count++;
                    if (sector === highlightSector) node.sectorCount++;
                }
            });
        }
    }
    
    // Calculate positions
    tree.forEach((level, levelIdx) => {
        const levelY = margin.t + (levelIdx / (levels - 1)) * plotH;
        const levelWidth = plotW / level.length;
        
        level.forEach((node, nodeIdx) => {
            node.x = margin.l + (nodeIdx + 0.5) * levelWidth;
            node.y = levelY;
        });
    });
    
    // Draw edges
    for (let level = 1; level < levels; level++) {
        tree[level].forEach(node => {
            if (node.parent) {
                ctx.strokeStyle = node.sectorCount > 0 ? '#f59e0b' : '#334155';
                ctx.lineWidth = node.sectorCount > 0 ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(node.parent.x, node.parent.y);
                ctx.lineTo(node.x, node.y);
                ctx.stroke();
            }
        });
    }
    
    // Draw nodes
    tree.forEach((level, levelIdx) => {
        level.forEach(node => {
            const hasSectorData = node.sectorCount > 0;
            
            ctx.beginPath();
            ctx.arc(node.x, node.y, hasSectorData ? 14 : 10, 0, 2 * Math.PI);
            ctx.fillStyle = hasSectorData ? '#f59e0b' : '#6366f1';
            ctx.fill();
            ctx.strokeStyle = '#c4b5fd';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Residue label
            ctx.fillStyle = '#fff';
            ctx.font = hasSectorData ? 'bold 9px system-ui' : '8px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(node.residue.toString(), node.x, node.y + 3);
            
            // Count label
            if (showCounts && hasSectorData) {
                ctx.fillStyle = '#fcd34d';
                ctx.font = '8px system-ui';
                ctx.fillText(node.sectorCount.toString(), node.x, node.y + 22);
            }
        });
    });
    
    // Level labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    for (let level = 0; level < levels; level++) {
        const mod = base * Math.pow(2, level);
        const y = margin.t + (level / (levels - 1)) * plotH;
        ctx.fillText(`mod ${mod}`, 5, y + 4);
    }
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Lifting Tree: Classes in Sector ${highlightSector} (yellow)`, W/2, 20);
}

function drawUnifiedFormulaChart() {
    const canvas = document.getElementById('unifiedFormulaCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, coprimeClasses, N, sectors, sectorResidueMatrix } = primorialState;
    const selectedClass = +(document.getElementById('unifiedResidueClass')?.value || coprimeClasses[0]);
    const showAll = document.getElementById('unifiedShowAll')?.checked ?? false;
    const phiK = coprimeClasses.length;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 30, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Compute actual and predicted values
    const data = [];
    for (let n = 1; n <= sectors; n++) {
        const row = sectorResidueMatrix[n - 1];
        const actual = row.classes[selectedClass]?.total || 0;
        const predicted = (3 * N * N) / (Math.PI * Math.PI * n * (n + 1) * phiK);
        data.push({ n, actual, predicted });
    }
    
    const maxY = Math.max(...data.map(d => Math.max(d.actual, d.predicted))) * 1.1;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        
        ctx.fillStyle = '#64748b';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText(Math.round(maxY * i / 4).toString(), margin.l - 5, y + 3);
    }
    
    const barWidth = plotW / sectors * 0.35;
    
    // Draw bars
    data.forEach((d, i) => {
        const x = margin.l + (i + 0.5) * (plotW / sectors);
        
        // Actual bar
        const actualH = (d.actual / maxY) * plotH;
        ctx.fillStyle = '#6366f1';
        ctx.fillRect(x - barWidth - 2, margin.t + plotH - actualH, barWidth, actualH);
        
        // Predicted bar
        const predH = (d.predicted / maxY) * plotH;
        ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
        ctx.fillRect(x + 2, margin.t + plotH - predH, barWidth, predH);
        
        // X label
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('S' + d.n, x, H - margin.b + 15);
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Sector n', margin.l + plotW/2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`C(n,N,${selectedClass},${modulus}): Actual vs 3N²/(π²n(n+1)φ(k))`, W/2, 18);
}

function drawPrimeDistribution() {
    const canvas = document.getElementById('primeDistributionCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, coprimeClasses, sectorResidueMatrix } = primorialState;
    const showExpected = document.getElementById('primeDistShowExpected')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 30, t: 30, b: 60 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Count primes per residue class
    const primeCounts = {};
    coprimeClasses.forEach(a => { primeCounts[a] = 0; });
    
    sectorResidueMatrix.forEach(row => {
        Object.entries(row.classes).forEach(([a, data]) => {
            primeCounts[+a] += data.primes;
        });
    });
    
    const totalPrimes = Object.values(primeCounts).reduce((s, c) => s + c, 0);
    const expected = totalPrimes / coprimeClasses.length;
    const maxY = Math.max(...Object.values(primeCounts), expected) * 1.1;
    
    const barWidth = plotW / coprimeClasses.length * 0.8;
    
    // Draw bars
    coprimeClasses.forEach((a, i) => {
        const x = margin.l + (i + 0.5) * (plotW / coprimeClasses.length);
        const h = (primeCounts[a] / maxY) * plotH;
        
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x - barWidth/2, margin.t + plotH - h, barWidth, h);
    });
    
    // Expected line
    if (showExpected) {
        const expY = margin.t + plotH - (expected / maxY) * plotH;
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(margin.l, expY);
        ctx.lineTo(W - margin.r, expY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(`Expected: ${expected.toFixed(1)}`, W - margin.r - 80, expY - 5);
    }
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '8px system-ui';
    ctx.textAlign = 'center';
    const step = Math.ceil(coprimeClasses.length / 15);
    coprimeClasses.forEach((a, i) => {
        if (i % step === 0) {
            ctx.fillText(a.toString(), margin.l + (i + 0.5) * (plotW / coprimeClasses.length), H - margin.b + 15);
        }
    });
    ctx.font = '10px system-ui';
    ctx.fillText('Residue class a', margin.l + plotW/2, H - 10);
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Prime Distribution (${totalPrimes} primes across ${coprimeClasses.length} classes)`, W/2, 18);
}

function drawUniformityTest() {
    const canvas = document.getElementById('uniformityTestCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { coprimeClasses, sectorResidueMatrix } = primorialState;
    const testSector = +(document.getElementById('uniformitySector')?.value || 2);
    const showChiSq = document.getElementById('uniformityShowChiSq')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 30, t: 30, b: 60 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Get counts for test sector
    const row = sectorResidueMatrix[testSector - 1];
    if (!row) return;
    
    const counts = coprimeClasses.map(a => row.classes[a]?.total || 0);
    const total = counts.reduce((s, c) => s + c, 0);
    const expected = total / coprimeClasses.length;
    
    // Chi-squared
    let chiSq = 0;
    counts.forEach(c => {
        chiSq += Math.pow(c - expected, 2) / (expected || 1);
    });
    const df = coprimeClasses.length - 1;
    
    const maxY = Math.max(...counts, expected) * 1.15;
    const barWidth = plotW / coprimeClasses.length * 0.8;
    
    // Draw bars
    coprimeClasses.forEach((a, i) => {
        const x = margin.l + (i + 0.5) * (plotW / coprimeClasses.length);
        const h = (counts[i] / maxY) * plotH;
        
        // Color based on deviation from expected
        const deviation = Math.abs(counts[i] - expected) / (expected || 1);
        const color = deviation < 0.2 ? '#8b5cf6' : (deviation < 0.5 ? '#f59e0b' : '#ef4444');
        
        ctx.fillStyle = color;
        ctx.fillRect(x - barWidth/2, margin.t + plotH - h, barWidth, h);
    });
    
    // Expected line
    const expY = margin.t + plotH - (expected / maxY) * plotH;
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(margin.l, expY);
    ctx.lineTo(W - margin.r, expY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Chi-squared stat
    if (showChiSq) {
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(W - margin.r - 130, margin.t + 5, 120, 50);
        ctx.strokeStyle = '#475569';
        ctx.strokeRect(W - margin.r - 130, margin.t + 5, 120, 50);
        
        ctx.fillStyle = '#94a3b8';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('χ² = ' + chiSq.toFixed(2), W - margin.r - 120, margin.t + 22);
        ctx.fillText('df = ' + df, W - margin.r - 120, margin.t + 37);
        const pVal = chiSq < df * 2 ? 'Likely uniform' : 'Non-uniform';
        ctx.fillStyle = chiSq < df * 2 ? '#22c55e' : '#ef4444';
        ctx.fillText(pVal, W - margin.r - 120, margin.t + 50);
    }
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '8px system-ui';
    ctx.textAlign = 'center';
    const step = Math.ceil(coprimeClasses.length / 15);
    coprimeClasses.forEach((a, i) => {
        if (i % step === 0) {
            ctx.fillText(a.toString(), margin.l + (i + 0.5) * (plotW / coprimeClasses.length), H - margin.b + 15);
        }
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector ${testSector} Uniformity: ${total} coprimes, expected ${expected.toFixed(1)}/class`, W/2, 18);
}

function drawPrimorialComparison() {
    const canvas = document.getElementById('primorialComparisonCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxK = +(document.getElementById('primorialCompareMax')?.value || 8);
    const showProduct = document.getElementById('primorialShowProduct')?.checked ?? true;
    const showRatio = document.getElementById('primorialShowRatio')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 70, r: 80, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Compute primorials and their densities
    const primes = getPrimes(100);
    const data = [];
    let primorial = 1;
    let phiPrimorial = 1;
    let eulerProduct = 1;
    
    for (let k = 0; k < Math.min(maxK, primes.length); k++) {
        const p = primes[k];
        primorial *= p;
        phiPrimorial *= (p - 1);
        eulerProduct *= (1 - 1/(p*p));
        
        data.push({
            k: k + 1,
            p,
            primorial,
            density: phiPrimorial / primorial,
            eulerProduct,
            target: 6 / (Math.PI * Math.PI)
        });
    }
    
    const target = 6 / (Math.PI * Math.PI);
    const minY = 0;
    const maxY = showRatio ? 1.5 : 0.6;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 5; i++) {
        const y = margin.t + plotH - (i / 5) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        
        ctx.fillStyle = '#64748b';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText((minY + (i / 5) * (maxY - minY)).toFixed(3), margin.l - 5, y + 3);
    }
    
    // Target line (6/π²)
    const targetY = margin.t + plotH - ((target - minY) / (maxY - minY)) * plotH;
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(margin.l, targetY);
    ctx.lineTo(W - margin.r, targetY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#22c55e';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('6/π² = ' + target.toFixed(5), W - margin.r + 5, targetY + 4);
    
    // φ(P_k)/P_k line
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + ((i + 0.5) / data.length) * plotW;
        const val = showRatio ? d.density / target : d.density;
        const y = margin.t + plotH - ((val - minY) / (maxY - minY)) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Points
    data.forEach((d, i) => {
        const x = margin.l + ((i + 0.5) / data.length) * plotW;
        const val = showRatio ? d.density / target : d.density;
        const y = margin.t + plotH - ((val - minY) / (maxY - minY)) * plotH;
        
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fillStyle = '#6366f1';
        ctx.fill();
        
        // Label
        ctx.fillStyle = '#94a3b8';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('P' + d.k, x, H - margin.b + 15);
        ctx.fillStyle = '#64748b';
        ctx.font = '8px system-ui';
        ctx.fillText('(' + d.p + ')', x, H - margin.b + 26);
    });
    
    // Euler product line
    if (showProduct) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + ((i + 0.5) / data.length) * plotW;
            const val = showRatio ? d.eulerProduct / target : d.eulerProduct;
            const y = margin.t + plotH - ((val - minY) / (maxY - minY)) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        
        // Points
        data.forEach((d, i) => {
            const x = margin.l + ((i + 0.5) / data.length) * plotW;
            const val = showRatio ? d.eulerProduct / target : d.eulerProduct;
            const y = margin.t + plotH - ((val - minY) / (maxY - minY)) * plotH;
            
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fillStyle = '#f59e0b';
            ctx.fill();
        });
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Primorial P_k = 2×3×5×...×p_k', margin.l + plotW/2, H - 5);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Primorial Density vs Euler Product: Both approach 6/π²', W/2, 18);
}

function updateSectorResidueTable() {
    const { coprimeClasses, sectorResidueMatrix } = primorialState;
    const phiK = coprimeClasses.length;
    
    let html = '';
    sectorResidueMatrix.forEach((row, idx) => {
        const avgPerClass = row.total / phiK;
        
        // Chi-squared
        let chiSq = 0;
        const expected = row.total / phiK;
        Object.values(row.classes).forEach(c => {
            chiSq += Math.pow(c.total - expected, 2) / (expected || 1);
        });
        const df = phiK - 1;
        const isUniform = chiSq < df * 2;
        
        html += `<tr>
            <td><strong>S${idx + 1}</strong></td>
            <td>${row.total}</td>
            <td>${avgPerClass.toFixed(1)}</td>
            <td>${chiSq.toFixed(2)}</td>
            <td style="color:${isUniform ? '#22c55e' : '#ef4444'}">${isUniform ? 'Yes' : 'No'}</td>
        </tr>`;
    });
    
    document.querySelector('#sectorResidueTable tbody').innerHTML = html;
}

let liftingAnimationId = null;
function animateLiftingTree() {
    if (liftingAnimationId) {
        cancelAnimationFrame(liftingAnimationId);
        liftingAnimationId = null;
        return;
    }
    
    let currentLevel = 0;
    const maxLevels = +(document.getElementById('liftingLevels')?.value || 4);
    
    function step() {
        document.getElementById('liftingLevels').value = currentLevel + 1;
        drawLiftingTree();
        
        currentLevel++;
        if (currentLevel < maxLevels) {
            liftingAnimationId = requestAnimationFrame(() => setTimeout(step, 800));
        } else {
            liftingAnimationId = null;
        }
    }
    step();
}

function exportPrimorialData() {
    const { modulus, coprimeClasses, sectorResidueMatrix, N, base, power } = primorialState;
    
    let csv = 'Primorial Sieve Data Export\n';
    csv += `Base,${base}\n`;
    csv += `Power,${power}\n`;
    csv += `Modulus,${modulus}\n`;
    csv += `N,${N}\n`;
    csv += `phi(k),${coprimeClasses.length}\n`;
    csv += `Density,${(coprimeClasses.length/modulus).toFixed(6)}\n\n`;
    
    csv += 'Coprime Classes,' + coprimeClasses.join(',') + '\n\n';
    
    csv += 'Sector × Residue Matrix\n';
    csv += 'Sector,' + coprimeClasses.join(',') + ',Total\n';
    sectorResidueMatrix.forEach((row, idx) => {
        csv += `S${idx+1},` + coprimeClasses.map(a => row.classes[a]?.total || 0).join(',') + `,${row.total}\n`;
    });
    
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `primorial_sieve_${base}x2^${power}_N${N}.csv`;
    a.click();
}

// RESEARCH
function testCustomFormula() {
    const formulaStr = document.getElementById('customFormula').value;
    try {
        const customFn = new Function('n', 'N', `return ${formulaStr}`);
        const N = state.nMax;
        const customData = state.sectors.map(s => ({n:s.n, custom:customFn(s.n, N), standard:s.predicted, exact:s.exact}));
        
        if(state.charts.customFormula) state.charts.customFormula.destroy();
        state.charts.customFormula = new Chart(document.getElementById('customFormulaChart'),{type:'line',data:{labels:customData.map(d=>d.n),datasets:[{label:'Custom',data:customData.map(d=>d.custom),borderColor:'#f59e0b',fill:false},{label:'Standard',data:customData.map(d=>d.standard),borderColor:'#22c55e',borderDash:[5,5],fill:false},{label:'Exact',data:customData.map(d=>d.exact),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    } catch(e) {
        alert('Formula error: ' + e.message);
    }
}

function runBatchSweep() {
    const nMin = +document.getElementById('batchNMin').value;
    const nMax = +document.getElementById('batchNMax').value;
    const nStep = +document.getElementById('batchNStep').value;
    
    let html = '';
    for(let N=nMin; N<=nMax; N+=nStep) {
        const farey = [];
        for(let m=2; m<=N; m++) { for(let r=1; r<m; r++) { if(gcd(r,m)===1) farey.push({r,m,value:r/m}); } }
        farey.sort((a,b)=>a.value-b.value);
        
        const n = farey.length;
        let sumDelta = 0, maxGap = 0, sumGap = 0;
        for(let i=0; i<n; i++) {
            sumDelta += Math.abs(farey[i].value - (i+1)/n);
            if(i < n-1) { const g = farey[i+1].value - farey[i].value; sumGap += g; if(g > maxGap) maxGap = g; }
        }
        
        html += `<tr><td>${N}</td><td>${n}</td><td>${sumDelta.toFixed(4)}</td><td>${(sumDelta/Math.sqrt(N)).toFixed(4)}</td><td>${maxGap.toExponential(2)}</td><td>${(sumGap/n).toExponential(2)}</td></tr>`;
    }
    document.querySelector('#batchTable tbody').innerHTML = html;
}

function exportLatexFigures() {
    const latex = `% Farey Sector Analysis - LaTeX Export
% Generated: ${new Date().toISOString()}
% Parameters: N=${state.nMax}, Sectors=${state.sectorMin}-${state.sectorMax}

\\documentclass{article}
\\usepackage{amsmath,amssymb,graphicx}
\\begin{document}

\\section{Sector Counting Formula}
\\begin{equation}
C(n, N) = \\frac{3N^2}{\\pi^2 n(n+1)}
\\end{equation}

\\section{Data Table}
\\begin{tabular}{|c|c|c|c|}
\\hline
$n$ & Exact & Predicted & Rel. Error \\\\
\\hline
${state.sectors.slice(0,10).map(s=>`${s.n} & ${s.exact??'-'} & ${s.predicted.toFixed(1)} & ${s.relError?s.relError.toFixed(2)+'\\%':'-'}`).join(' \\\\\n')} \\\\
\\hline
\\end{tabular}

\\section{Franel-Landau Connection}
For the Farey sequence $F_N$:
\\begin{equation}
\\sum_{k=1}^{|F_N|} \\left| F_k - \\frac{k}{|F_N|} \\right| = O(N^{1/2+\\varepsilon}) \\iff \\text{RH}
\\end{equation}

\\end{document}`;
    document.getElementById('latexFigures').textContent = latex;
}

function exportCSVAll() {
    let csv = 'n,exact,predicted,error,relError,primeCount\n';
    state.sectors.forEach(s => { csv += `${s.n},${s.exact??''},${s.predicted},${s.error??''},${s.relError??''},${s.primeCount??''}\n`; });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_complete.csv'; a.click();
}

function exportJSON() {
    const data = { params:{nMax:state.nMax,sectorMin:state.sectorMin,sectorMax:state.sectorMax}, sectors:state.sectors, gapCount:state.gaps.length, fareyCount:state.farey.length };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_data.json'; a.click();
}

function exportAllData() { exportCSVAll(); }

function exportMainTabData() {
    let csv = 'Type,Data\n';
    csv += 'Parameters,"N=' + state.nMax + ', Sectors=' + state.sectorMin + '-' + state.sectorMax + '"\n\n';
    csv += 'Sector,Interval,Exact,Predicted,Error%,Primes,Composites\n';
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        const primeCount = res.filter(r => r.isPrime).length;
        csv += s.n + ',"(1/' + (s.n+1) + ',1/' + s.n + ']",' + (s.exact || '') + ',' + s.predicted.toFixed(2) + ',' + (s.relError ? s.relError.toFixed(2) : '') + ',' + primeCount + ',' + (res.length - primeCount) + '\n';
    });
    
    if (selectedTreePoint) {
        const path = getPathToFraction(selectedTreePoint.r, selectedTreePoint.m);
        csv += '\nSelected Point\n';
        csv += 'Fraction,' + selectedTreePoint.r + '/' + selectedTreePoint.m + '\n';
        csv += 'Sector,' + selectedTreePoint.sector + '\n';
        csv += 'SB Path,"' + path + '"\n';
        csv += 'Path Length,' + path.length + '\n';
    }
    
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'main_tab_data_N' + state.nMax + '.csv';
    a.click();
}

function switchTab(name) {
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t=>t.classList.remove('active'));
    document.querySelector(`.tab[onclick="switchTab('${name}')"]`).classList.add('active');
    document.getElementById(`tab-${name}`).classList.add('active');
    
    if(name==='dedekind') computeDedekind();
    if(name==='cf') updateCFDisplay();
    if(name==='psl') computePSL();
    if(name==='euler') computeEulerProduct();
    if(name==='modular') updateModularAnalysis();
    if(name==='3d') draw3D();
    if(name==='hyperbolic') drawHyperbolic();
    if(name==='smith') drawSmithChart();
    if(name==='stats') updateStatistics();
    if(name==='primes') updatePrimeAnalysis();
    if(name==='primorial') updatePrimorialSieve();
    if(name==='theoryviz') drawTheoryViz();
    
    setTimeout(addZoomControlsToCharts, 100);
}

function exportCanvas4K(canvasElement, title) {
    const canvas = canvasElement;
    const scale = 2;
    const scaledWidth = canvas.width * scale;
    const scaledHeight = canvas.height * scale;
    
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = scaledWidth;
    offscreenCanvas.height = scaledHeight;
    const ctx = offscreenCanvas.getContext('2d');
    ctx.scale(scale, scale);
    
    const img = new Image();
    img.onload = function() {
        ctx.drawImage(img, 0, 0);
        const link = document.createElement('a');
        link.href = offscreenCanvas.toDataURL('image/png');
        link.download = `${title || 'export'}_4k.png`;
        link.click();
    };
    img.src = canvas.toDataURL('image/png');
}

async function exportCompositeTab() {
    const tabContent = document.querySelector('.tab-content.active');
    if (!tabContent) { alert('No tab active'); return; }
    
    const baseWidth = 7680;
    const baseHeight = 4320;
    const compositeCanvas = document.createElement('canvas');
    compositeCanvas.width = baseWidth;
    compositeCanvas.height = baseHeight;
    const ctx = compositeCanvas.getContext('2d');
    
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 120px Arial';
    ctx.textAlign = 'center';
    const activeTab = document.querySelector('.tab.active');
    const tabName = activeTab ? activeTab.textContent.trim() : 'Export';
    ctx.fillText(tabName + ' - 4K Composite Export', baseWidth / 2, 200);
    
    ctx.font = '60px Arial';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText(`Generated: ${new Date().toLocaleString()}`, baseWidth / 2, 300);
    
    const canvases = tabContent.querySelectorAll('canvas');
    const chartBoxes = tabContent.querySelectorAll('.chart-box');
    
    if (canvases.length === 0) { alert('No canvases found in this tab'); return; }
    
    let yPos = 450;
    let xPos = 100;
    let columnWidth = baseWidth / 2 - 150;
    let maxHeight = 1500;
    let colIndex = 0;
    
    for (let i = 0; i < canvases.length; i++) {
        const canvas = canvases[i];
        const chartBox = chartBoxes[i];
        
        if (yPos + maxHeight + 200 > baseHeight) {
            colIndex++;
            yPos = 450;
            if (colIndex >= 2) {
                alert('Too many charts for one 4K page. Consider exporting individual tabs.');
                break;
            }
        }
        
        xPos = colIndex === 0 ? 100 : baseWidth / 2 + 50;
        
        const title = chartBox ? chartBox.querySelector('h4')?.textContent || 'Chart' : 'Chart';
        ctx.fillStyle = '#cbd5e1';
        ctx.font = '50px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(title, xPos, yPos);
        yPos += 80;
        
        const img = new Image();
        img.src = canvas.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = function() {
                const scaleFactor = columnWidth / canvas.width;
                const scaledHeight = canvas.height * scaleFactor;
                ctx.drawImage(img, xPos, yPos, columnWidth, scaledHeight);
                yPos += scaledHeight + 150;
                resolve();
            };
            img.onerror = () => resolve();
        });
    }
    
    yPos = baseHeight - 400;
    ctx.fillStyle = '#334155';
    ctx.fillRect(50, yPos - 50, baseWidth - 100, 350);
    
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 50px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Legend & Parameters', 100, yPos + 20);
    
    ctx.font = '40px Arial';
    ctx.fillStyle = '#cbd5e1';
    let legendY = yPos + 100;
    const legendItems = [
        'Resolution: 4K (7680×4320)',
        'Color Scale: Indigo (#6366f1) to Purple (#8b5cf6)',
        'Time Generated: ' + new Date().toISOString(),
        'Tab: ' + tabName
    ];
    
    legendItems.forEach((item, idx) => {
        ctx.fillText(item, 120, legendY + (idx * 60));
    });
    
    compositeCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `farey_${tabName.toLowerCase().replace(/\\s+/g,'_')}_4k_composite.png`;
        link.click();
        URL.revokeObjectURL(url);
    });
}

document.addEventListener('click', e => {
    if (e.target.classList.contains('export-4k-btn')) {
        const canvas = e.target.closest('.chart-wrapper')?.querySelector('canvas') ||
                       e.target.closest('.chart-box')?.querySelector('canvas');
        if (canvas) {
            const title = e.target.closest('.chart-box')?.querySelector('h4')?.textContent || 'export';
            exportCanvas4K(canvas, title);
        }
    }
});

document.addEventListener('click', e => { if(e.target.classList.contains('modal-overlay')) closePointModal(); });
document.addEventListener('keydown', e => { if(e.key==='Escape') closePointModal(); });

function addExportButtons() {
    document.querySelectorAll('.chart-box').forEach(box => {
        if (!box.querySelector('.export-4k-btn')) {
            const btn = document.createElement('button');
            btn.className = 'export-4k-btn';
            btn.textContent = '4K Export';
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const canvas = box.querySelector('canvas');
                const title = box.querySelector('h4')?.textContent || 'export';
                if (canvas) exportCanvas4K(canvas, title);
            });
            box.style.position = 'relative';
            box.appendChild(btn);
        }
    });
}

const originalSwitchTab = window.switchTab;
window.switchTab = function(name) {
    originalSwitchTab.call(this, name);
    setTimeout(addExportButtons, 100);
};

document.addEventListener('DOMContentLoaded', addExportButtons);
setTimeout(addExportButtons, 500);

computeAll();

// Initialize sector tree on load
setTimeout(() => {
    drawSectorTree();
    // Add tree canvas click handler if not already added
    const treeCanvas = document.getElementById('sectorTreeCanvas');
    if (treeCanvas && !treeCanvas.hasClickHandler) {
        treeCanvas.hasClickHandler = true;
        treeCanvas.addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const depth = +document.getElementById('treeDepth').value;
            const treeNodes = buildSternBrocotTree(depth);
            
            let closest = null, minDist = 15;
            treeNodes.forEach(node => {
                const d = Math.sqrt((node.x - x)**2 + (node.y - y)**2);
                if (d < minDist) { minDist = d; closest = node; }
            });
            
            if (closest) {
                const point = { r: closest.r, m: closest.m, sector: getSector(closest.r, closest.m), isPrime: isPrime(closest.m) };
                selectPointForTree(point);
            }
        });
    }
}, 100);

// Add zoom controls to all chart boxes
function addZoomControlsToCharts() {
    // Charts already have 4K export buttons, no additional controls needed
}

document.addEventListener('keydown', e => { if(e.key === 'Escape') { closePointModal(); closeScreenshotOverlay(); closeSectorModal(); } });

document.getElementById('sectorModal').addEventListener('click', function(e) { if(e.target === this) closeSectorModal(); });

setTimeout(addZoomControlsToCharts, 500);</script>
</body>
                                         </html>
