<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farey Sector Formula - Complete Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0f1a; color: #e2e8f0; line-height: 1.6; font-size: 14px; }
        
        /* GLOBAL HARMONIC TOOLBAR - TOP DROPDOWN */
        .harmonic-toolbar {
            background: linear-gradient(90deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);
            border-bottom: 2px solid #8b5cf6;
            position: sticky;
            top: 38px;
            z-index: 500;
        }
        .harmonic-toolbar-header {
            display: flex;
            align-items: center;
            padding: 6px 15px;
            cursor: pointer;
            gap: 15px;
        }
        .harmonic-toolbar-header:hover { background: rgba(139, 92, 246, 0.1); }
        .harmonic-toolbar-toggle {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .harmonic-toolbar-toggle:hover { opacity: 0.9; }
        .harmonic-toolbar-toggle .icon { font-size: 14px; }
        .harmonic-toolbar-toggle.playing { background: linear-gradient(135deg, #22c55e, #16a34a); animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        @keyframes horizonPulse { 0%, 100% { transform: scale(1.15); box-shadow: 0 0 10px #8b5cf6; } 50% { transform: scale(1.2); box-shadow: 0 0 15px #8b5cf6; } }
        .horizon-frac-playing { animation: horizonPulse 0.3s ease-in-out; transition: all 0.15s ease; }
        .horizon-frac { transition: all 0.15s ease; }
        .horizon-frac:hover { transform: scale(1.1); filter: brightness(1.2); }
        .harmonic-quick-display {
            display: flex;
            align-items: center;
            gap: 20px;
            flex: 1;
            margin-left: 15px;
        }
        .harmonic-quick-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }
        .harmonic-quick-item label { color: #94a3b8; font-size: 11px; }
        .harmonic-quick-item .value { color: #8b5cf6; font-weight: 600; font-family: monospace; font-size: 13px; }
        .harmonic-quick-item .note { color: #22c55e; font-weight: 600; font-size: 13px; }
        .harmonic-quick-btns {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }
        .harmonic-quick-btn {
            padding: 5px 10px;
            font-size: 11px;
            background: rgba(99, 102, 241, 0.3);
            border: 1px solid #6366f1;
            border-radius: 4px;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .harmonic-quick-btn:hover { background: rgba(99, 102, 241, 0.5); transform: translateY(-1px); }
        .harmonic-quick-btn.play { background: rgba(34, 197, 94, 0.3); border-color: #22c55e; }
        .harmonic-quick-btn.play:hover { background: rgba(34, 197, 94, 0.5); }
        .harmonic-quick-btn.stop { background: rgba(239, 68, 68, 0.3); border-color: #ef4444; }
        .harmonic-quick-btn.stop:hover { background: rgba(239, 68, 68, 0.5); }
        
        .harmonic-panel-dropdown {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            background: #0f172a;
        }
        .harmonic-panel-dropdown.expanded { 
            max-height: 600px; 
            overflow-y: auto; 
        }
        .harmonic-panel-content {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .harmonic-toolbar-header.expanded .harmonic-toolbar-toggle {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }
        #harmonicArrow.rotated {
            transform: rotate(180deg);
        }
        .harmonic-card {
            background: #1e293b;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #334155;
        }
        .harmonic-card h5 {
            color: #a5b4fc;
            font-size: 11px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .harmonic-card h5 .badge { background: #22c55e; padding: 2px 6px; border-radius: 8px; font-size: 8px; color: white; }
        .harmonic-card-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .harmonic-card-row:last-child { margin-bottom: 0; }
        .harmonic-card-row label { font-size: 10px; color: #94a3b8; min-width: 55px; }
        .harmonic-card-row input[type="range"] { flex: 1; height: 4px; cursor: pointer; }
        .harmonic-card-row input[type="number"] { width: 55px; padding: 3px 5px; font-size: 10px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; }
        .harmonic-card-row select { flex: 1; padding: 4px 6px; font-size: 10px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; }
        .harmonic-card-row .val { font-size: 10px; color: #8b5cf6; font-weight: 600; min-width: 40px; text-align: right; font-family: monospace; }
        
        .interval-grid-compact { display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px; }
        .interval-btn-sm { padding: 5px 3px; font-size: 9px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; cursor: pointer; text-align: center; transition: all 0.2s; font-family: monospace; }
        .interval-btn-sm:hover { background: #334155; border-color: #6366f1; transform: translateY(-1px); }
        .interval-btn-sm.active { background: #6366f1; border-color: #8b5cf6; color: white; }
        
        .mode-badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 9px; font-weight: 600; }
        .mode-badge.unison { background: #22c55e30; color: #4ade80; }
        .mode-badge.consonant { background: #3b82f630; color: #60a5fa; }
        .mode-badge.complex { background: #f59e0b30; color: #fbbf24; }
        .mode-badge.dissonant { background: #ef444430; color: #f87171; }
        
        .freq-box { background: #0f172a; padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #334155; }
        .freq-box .big { font-size: 20px; font-weight: bold; color: #8b5cf6; font-family: monospace; }
        .freq-box .small { font-size: 11px; color: #64748b; margin-top: 2px; }
        
        .arnold-canvas-sm { width: 100%; height: 70px; background: #0f172a; border-radius: 4px; border: 1px solid #334155; display: block; }
        .spectrum-canvas-sm { width: 100%; height: 40px; background: #0f172a; border-radius: 4px; border: 1px solid #334155; display: block; }
        
        .keyboard-row { display: flex; gap: 1px; height: 28px; }
        .key-white { flex: 1; background: linear-gradient(180deg, #f1f5f9, #cbd5e1); border-radius: 0 0 2px 2px; cursor: pointer; min-width: 14px; }
        .key-white:hover { background: #a5b4fc; }
        .key-white.active { background: #6366f1; }
        .key-black { width: 12px; background: linear-gradient(180deg, #1e293b, #0f172a); margin: 0 -6px; z-index: 1; height: 18px; border-radius: 0 0 2px 2px; cursor: pointer; }
        .key-black:hover { background: #475569; }
        .key-black.active { background: #8b5cf6; }
        
        .nav-links { background: linear-gradient(90deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%); padding: 8px 15px; border-bottom: 1px solid #4338ca; overflow-x: auto; white-space: nowrap; position: sticky; top: 0; z-index: 500; }
        .nav-links::-webkit-scrollbar { height: 4px; }
        .nav-links::-webkit-scrollbar-track { background: #1e1b4b; }
        .nav-links::-webkit-scrollbar-thumb { background: #6366f1; border-radius: 2px; }
        .nav-links a { display: inline-block; padding: 4px 10px; margin: 2px 3px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 4px; color: #a5b4fc; text-decoration: none; font-size: 11px; font-weight: 500; transition: all 0.2s; }
        .nav-links a:hover { background: rgba(99, 102, 241, 0.4); color: #e0e7ff; border-color: #6366f1; transform: translateY(-1px); }
        .nav-links-label { color: #64748b; font-size: 10px; margin-right: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; overflow-y: auto; padding: 20px; }
        .modal-overlay.active { display: flex; justify-content: center; align-items: flex-start; }
        .modal-content { background: #1e293b; border-radius: 12px; max-width: 900px; width: 100%; border: 1px solid #475569; margin: 20px auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 18px; border-bottom: 1px solid #334155; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border-radius: 12px 12px 0 0; }
        .modal-header h3 { margin: 0; font-size: 1.1em; }
        .modal-close { background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 16px; }
        .modal-body { padding: 18px; max-height: 75vh; overflow-y: auto; }
        
        .container { max-width: 1800px; margin: 0 auto; padding: 15px; }
        h1 { color: #f8fafc; font-size: 1.5em; margin-bottom: 4px; }
        .subtitle { color: #94a3b8; margin-bottom: 15px; font-size: 0.9em; }
        h2 { color: #f1f5f9; font-size: 1.1em; margin: 20px 0 12px 0; border-bottom: 1px solid #334155; padding-bottom: 6px; }
        h3 { color: #cbd5e1; font-size: 1em; margin: 12px 0 8px 0; }
        h4 { color: #94a3b8; font-size: 0.9em; margin: 8px 0 6px 0; }
        
        .formula-box { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        .formula-main { font-size: 1.3em; font-weight: bold; font-family: 'Cambria Math', serif; text-align: center; margin: 8px 0; }
        
        .control-panel { background: #1e293b; padding: 12px 15px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #334155; }
        .control-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .control-row:last-child { margin-bottom: 0; }
        .control-group { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: #0f172a; border-radius: 5px; }
        .control-group.highlight { border: 1px solid #6366f1; background: #1e1b4b; }
        label { font-weight: 600; color: #cbd5e1; font-size: 0.8em; white-space: nowrap; }
        input[type="number"], input[type="text"], select, textarea { padding: 6px 8px; font-size: 13px; border: 1px solid #475569; border-radius: 5px; background: #1e293b; color: #e2e8f0; }
        input[type="number"] { width: 70px; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }
        select { min-width: 90px; }
        button { padding: 8px 14px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { opacity: 0.9; }
        button.secondary { background: #334155; border: 1px solid #475569; }
        button.small { padding: 5px 10px; font-size: 11px; }
        .info-badge { background: #334155; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; color: #94a3b8; }
        .info-badge strong { color: #e2e8f0; }
        .info-badge.success { background: #14532d; border: 1px solid #16a34a; }
        .info-badge.warning { background: #713f12; border: 1px solid #a16207; }
        
        .mode-selector { display: flex; gap: 4px; }
        .mode-btn { padding: 6px 12px; background: #1e293b; border: 1px solid #475569; border-radius: 5px; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .mode-btn.active { background: #6366f1; border-color: #6366f1; color: white; }
        
        .tabs { display: flex; gap: 3px; margin-bottom: 12px; flex-wrap: wrap; }
        .tab { padding: 6px 12px; background: #1e293b; border: 1px solid #334155; border-radius: 5px 5px 0 0; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .tab.active { background: #334155; color: #f1f5f9; border-bottom-color: #334155; }
        .tab:hover { color: #e2e8f0; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .panel { background: #1e293b; border-radius: 8px; padding: 15px; border: 1px solid #334155; margin-bottom: 15px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
        .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        @media (max-width: 1200px) { .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; } }
        
        .chart-box { background: #0f172a; border-radius: 6px; padding: 12px; border: 1px solid #334155; }
        .chart-box h4 { margin-top: 0; }
        canvas { max-width: 100%; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.8em; }
        thead { background: #334155; }
        th { padding: 8px; text-align: left; font-weight: 600; color: #e2e8f0; }
        td { padding: 6px 8px; border-bottom: 1px solid #334155; }
        tbody tr:hover { background: #334155; }
        .table-scroll { max-height: 350px; overflow-y: auto; }
        
        .detail-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .detail-card { background: #0f172a; padding: 12px; border-radius: 6px; border: 1px solid #334155; }
        .detail-card h5 { color: #94a3b8; font-size: 0.75em; margin-bottom: 6px; text-transform: uppercase; }
        .detail-card .value { font-size: 1.2em; font-weight: bold; color: #6366f1; }
        .detail-card .sub { font-size: 0.8em; color: #64748b; margin-top: 3px; }
        
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
        .stat-card { background: #0f172a; padding: 10px; border-radius: 5px; border: 1px solid #334155; text-align: center; }
        .stat-value { font-size: 1.1em; font-weight: bold; color: #6366f1; }
        .stat-label { font-size: 0.7em; color: #94a3b8; margin-top: 3px; }
        
        .theorem-box { background: #1e1b4b; border-left: 3px solid #6366f1; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .derivation-box { background: #422006; border-left: 3px solid #f59e0b; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .rh-box { background: #450a0a; border-left: 3px solid #ef4444; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .connection-box { background: #14532d; border-left: 3px solid #22c55e; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        
        .ring-canvas { background: #0f172a; border-radius: 6px; border: 1px solid #334155; cursor: crosshair; }
        .point-tooltip { position: absolute; background: #1e293b; border: 1px solid #6366f1; padding: 8px 12px; border-radius: 6px; font-size: 0.8em; pointer-events: none; z-index: 100; display: none; min-width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .point-tooltip.visible { display: block; }
        .point-tooltip h5 { color: #6366f1; margin: 0 0 6px 0; font-size: 1em; }
        .point-tooltip .row { display: flex; justify-content: space-between; margin: 2px 0; }
        .point-tooltip .label { color: #94a3b8; }
        .point-tooltip .val { color: #e2e8f0; font-weight: 600; }
        
        .color-legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 8px; padding: 8px; background: #0f172a; border-radius: 5px; font-size: 0.75em; }
        .color-legend-item { display: flex; align-items: center; gap: 5px; }
        .color-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #475569; }
        
        .progress-bar { width: 100%; height: 5px; background: #334155; border-radius: 3px; overflow: hidden; margin: 8px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); transition: width 0.3s; }
        
        .matrix-display { font-family: 'Courier New', monospace; background: #0f172a; padding: 10px; border-radius: 5px; display: inline-block; margin: 5px; }
        .matrix-bracket { font-size: 2em; line-height: 1; }
        
        .residue-list { max-height: 180px; overflow-y: auto; background: #0f172a; padding: 8px; border-radius: 5px; font-family: monospace; font-size: 0.8em; }
        .residue-item { display: inline-block; padding: 3px 8px; margin: 3px; background: #334155; border-radius: 3px; cursor: default; transition: background 0.2s; }
        .residue-item:hover { background: #475569; }
        .residue-item.prime { background: #854d0e; color: #fbbf24; border: 1px solid #f59e0b; }
        .residue-item.prime:hover { background: #a16207; }
        .residue-item.twin { background: #166534; color: #4ade80; }
        
        .latex-output { background: #0f172a; padding: 12px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; border: 1px solid #334155; max-height: 250px; overflow-y: auto; }
        
        .cf-path { font-family: monospace; background: #334155; padding: 2px 6px; border-radius: 3px; margin: 2px; display: inline-block; }
        
        .screenshot-btn { position: absolute; top: 8px; right: 8px; padding: 4px 8px; background: rgba(99,102,241,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn { position: absolute; top: 8px; right: 90px; padding: 4px 8px; background: rgba(168,85,247,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn:hover { background: rgba(168,85,247,1); }
        .chart-wrapper { position: relative; }
        .composite-export-btn { margin-top: 10px; padding: 10px 16px; font-size: 13px; background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%); }
        .composite-export-btn:hover { opacity: 0.95; }
        #compositeCanvas { display: none; max-width: 100%; margin-top: 10px; }
        .composite-info { background: #1e1b4b; border: 1px solid #8b5cf6; padding: 10px 12px; border-radius: 5px; margin-top: 10px; font-size: 0.85em; color: #cbd5e1; }
        
        .screenshot-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; justify-content: center; align-items: center; flex-direction: column; padding: 20px; }
        .screenshot-overlay.active { display: flex; }
        .screenshot-preview { max-width: 90%; max-height: 60vh; border: 2px solid #6366f1; border-radius: 8px; }
        .screenshot-actions { margin-top: 20px; display: flex; gap: 10px; }
        .screenshot-actions button { padding: 12px 24px; font-size: 14px; }
        
        .heatmap-cell { display: inline-block; width: 20px; height: 20px; margin: 1px; border-radius: 2px; }
        
        .euler-term { display: inline-block; padding: 4px 8px; margin: 3px; background: #1e293b; border-radius: 4px; border: 1px solid #334155; font-family: monospace; }
        .euler-term.prime { border-color: #f59e0b; }
    </style>
</head>
<body>
<div class="nav-links">
    <span class="nav-links-label">Projects:</span>
    <a href="https://wessengetachew.github.io/2025/" target="_blank">2025</a>
    <a href="https://wessengetachew.github.io/Transform/" target="_blank">Transform</a>
    <a href="https://wessengetachew.github.io/finite/" target="_blank">Finite</a>
    <a href="https://wessengetachew.github.io/Primes/" target="_blank">Primes</a>
    <a href="https://wessengetachew.github.io/Farey/" target="_blank">Farey</a>
    <a href="https://wessengetachew.github.io/Composite/" target="_blank">Composite</a>
    <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank">Ethiopian</a>
    <a href="https://wessengetachew.github.io/2pir/" target="_blank">2œÄr</a>
    <a href="https://wessengetachew.github.io/1-2/" target="_blank">1-2</a>
    <a href="https://wessengetachew.github.io/Rational-/" target="_blank">Rational</a>
    <a href="https://wessengetachew.github.io/Infinitemoduli/" target="_blank">Infinite Moduli</a>
    <a href="https://wessengetachew.github.io/Pythagorean-/" target="_blank">Pythagorean</a>
    <a href="https://wessengetachew.github.io/Phase/" target="_blank">Phase</a>
    <a href="https://wessengetachew.github.io/Gemini/" target="_blank">Gemini</a>
    <a href="https://wessengetachew.github.io/Rebuild/" target="_blank">Rebuild</a>
    <a href="https://wessengetachew.github.io/Goldbach/" target="_blank">Goldbach</a>
</div>

<!-- GLOBAL HARMONIC ANALYSIS PANEL - COMPLETE -->
<!-- HARMONIC TOOLBAR - COLLAPSED BY DEFAULT -->
<div class="harmonic-toolbar" id="harmonicToolbar">
    <div class="harmonic-toolbar-header" onclick="toggleHarmonicDropdown()">
        <button class="harmonic-toolbar-toggle" id="harmonicToggle">
            <span class="icon">‚ô™</span>
            HARMONIC ANALYSIS
            <span id="harmonicArrow" style="margin-left:8px;transition:transform 0.3s;">‚ñº</span>
        </button>
        <div class="harmonic-quick-display">
            <div class="harmonic-quick-item">
                <label>Selected:</label>
                <span class="value" id="quickFraction">1/2</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Freq:</label>
                <span class="value" id="quickFreq">110 Hz</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Œª:</label>
                <span class="value" id="quickWave" style="color:#f59e0b;">3.12 m</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Note:</label>
                <span class="note" id="quickNote">A2</span>
            </div>
            <div class="harmonic-quick-item" id="playbackStatusContainer" style="display:none;">
                <label>Status:</label>
                <span class="value" id="playbackStatus" style="color:#22c55e;">Playing...</span>
            </div>
            <div class="harmonic-quick-btns">
                <button class="harmonic-quick-btn play" onclick="event.stopPropagation(); playSelectedFraction();" title="Play single note">‚ñ∂</button>
                <button class="harmonic-quick-btn" onclick="event.stopPropagation(); if(selectedTreePoint) playTreePathAudio('forward'); else playSectorSequence('forward');" title="Play sequence">‚ô™</button>
                <button class="harmonic-quick-btn stop" onclick="event.stopPropagation(); stopAllPlayback();" title="Stop all">‚ñ†</button>
            </div>
        </div>
    </div>
    <div class="harmonic-panel-dropdown" id="harmonicDropdown">
        <div class="harmonic-panel-content">
            <!-- AUDIO ENGINE -->
            <div class="harmonic-card">
                <h5>Audio Engine <span class="badge">LIVE</span></h5>
                <div class="harmonic-card-row">
                    <label>Base Hz:</label>
                    <input type="number" id="baseFreq" min="20" max="2000" value="440" step="1" style="width:70px;" oninput="updateBaseFreq()">
                    <input type="range" id="baseFreqSlider" min="55" max="880" value="440" oninput="document.getElementById('baseFreq').value=this.value; updateBaseFreq()">
                    <span class="val" id="baseFreqVal">440 Hz</span>
                </div>
                <div class="harmonic-card-row">
                    <label>Volume:</label>
                    <input type="range" id="harmonicVolume" min="0" max="100" value="100" oninput="updateHarmonicVolume()">
                    <span class="val" id="volumeVal">100%</span>
                </div>
                <div class="harmonic-card-row">
                    <label>Wave:</label>
                    <select id="waveform" onchange="updateWaveform()">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                    </select>
                </div>
                <div class="freq-box" style="margin-top:8px;">
                    <div class="big" id="currentFreqDisplay">110 Hz</div>
                    <div class="small" id="currentNoteDisplay">1/2 = A2</div>
                </div>
            </div>
            
            <!-- WAVELENGTH DISPLAY -->
            <div class="harmonic-card">
                <h5>Wave Properties <span class="badge" style="background:#f59e0b;">Œª</span></h5>
                <div class="freq-box" style="background:linear-gradient(135deg,#1e1b4b,#0f172a);">
                    <div class="big" id="wavelengthDisplay" style="color:#f59e0b;">78.0 cm</div>
                    <div class="small">Wavelength (v=343 m/s)</div>
                </div>
                <div style="margin-top:8px;font-size:10px;color:#64748b;">
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span>Period:</span>
                        <span id="periodDisplay" style="color:#a5b4fc;">2.27 ms</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span>Angular œâ:</span>
                        <span id="angularFreqDisplay" style="color:#a5b4fc;">2764 rad/s</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;">
                        <span>Wavenumber k:</span>
                        <span id="wavenumberDisplay" style="color:#a5b4fc;">8.06 /m</span>
                    </div>
                </div>
            </div>
            
            <!-- MUSICAL INTERVALS -->
            <div class="harmonic-card">
                <h5>Musical Intervals</h5>
                <div class="interval-grid-compact">
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(1,1)" title="Unison">1:1</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(16,15)" title="m2">16:15</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(9,8)" title="M2">9:8</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(6,5)" title="m3">6:5</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(5,4)" title="M3">5:4</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(4,3)" title="P4">4:3</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(45,32)" title="TT">45:32</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(3,2)" title="P5">3:2</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(8,5)" title="m6">8:5</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(5,3)" title="M6">5:3</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(9,5)" title="m7">9:5</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(15,8)" title="M7">15:8</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(2,1)" title="Oct">2:1</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(5,2)" title="10th">5:2</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(3,1)" title="12th">3:1</button>
                    <button class="interval-btn-sm" onclick="setHarmonicInterval(4,1)" title="2Oct">4:1</button>
                </div>
                <div style="margin-top:8px;display:flex;gap:4px;justify-content:center;flex-wrap:wrap;">
                    <button class="harmonic-quick-btn play" onclick="playSelectedFraction()">‚ñ∂ Play</button>
                    <button class="harmonic-quick-btn" onclick="playArpeggio()">Arpeggio</button>
                    <button class="harmonic-quick-btn" onclick="playChord()">Chord</button>
                    <button class="harmonic-quick-btn" id="randomIntervalBtn" onclick="toggleRandomIntervals()" style="background:linear-gradient(135deg,#f59e0b,#d97706);border-color:#f59e0b;">üé≤ Random</button>
                    <button class="harmonic-quick-btn stop" onclick="stopAudio(); stopRandomIntervals();">‚ñ† Stop</button>
                </div>
            </div>
            
            <!-- HARMONIC MODE -->
            <div class="harmonic-card">
                <h5>Harmonic Mode</h5>
                <div style="text-align:center;margin:8px 0;">
                    <span class="mode-badge consonant" id="harmonicModeIndicator">Consonant</span>
                    <span style="font-size:10px;color:#64748b;margin-left:6px;" id="modeQValue">q ‚â§ 4</span>
                </div>
                <div style="font-size:9px;color:#64748b;display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:8px;">
                    <div><span class="mode-badge unison" style="font-size:8px;">Unison</span> q=1</div>
                    <div><span class="mode-badge consonant" style="font-size:8px;">Consonant</span> q‚â§4</div>
                    <div><span class="mode-badge complex" style="font-size:8px;">Complex</span> q‚â§16</div>
                    <div><span class="mode-badge dissonant" style="font-size:8px;">Dissonant</span> q>16</div>
                </div>
            </div>
            
            <!-- ARNOLD TONGUE PREVIEW -->
            <div class="harmonic-card">
                <h5>Arnold Tongue</h5>
                <canvas id="arnoldMiniCanvas" class="arnold-canvas-sm" width="200" height="70"></canvas>
                <div class="harmonic-card-row" style="margin-top:6px;">
                    <label>K:</label>
                    <input type="range" id="arnoldK" min="0" max="100" value="50" oninput="updateArnoldTongue()">
                    <span class="val" id="arnoldKVal">0.50</span>
                </div>
            </div>
            
            <!-- HARMONIC SERIES -->
            <div class="harmonic-card">
                <h5>Harmonic Series</h5>
                <div class="harmonic-card-row">
                    <label>Partials:</label>
                    <input type="range" id="numPartials" min="1" max="16" value="8" oninput="updateHarmonicSeries()">
                    <span class="val" id="partialsVal">8</span>
                </div>
                <canvas id="harmonicSeriesCanvas" class="spectrum-canvas-sm" width="200" height="40"></canvas>
                <div style="margin-top:6px;display:flex;gap:4px;">
                    <button class="harmonic-quick-btn" onclick="playHarmonicSeries()" style="flex:1;">Harmonic</button>
                    <button class="harmonic-quick-btn" onclick="playSubharmonicSeries()" style="flex:1;">Subharmonic</button>
                </div>
            </div>
            
            <!-- GLOBAL OPTIONS -->
            <div class="harmonic-card">
                <h5>Options</h5>
                <div style="font-size:10px;display:flex;flex-direction:column;gap:4px;">
                    <label><input type="checkbox" id="applyHarmonicColor" onchange="applyHarmonicColoring()"> Color by consonance</label>
                    <label><input type="checkbox" id="showArnoldOnTree" onchange="drawSectorTree()"> Arnold on tree</label>
                    <label><input type="checkbox" id="autoPlayOnClick" checked> Auto-play on click</label>
                    <label><input type="checkbox" id="showFreqOnHover"> Show freq on hover</label>
                </div>
            </div>
        
            <!-- SELECTED FRACTION -->
            <div class="harmonic-card">
                <h5>Selected Fraction</h5>
                <div id="selectedFractionInfo" style="font-size:10px;color:#94a3b8;">
                    Click any point to select
                </div>
            </div>
            
            <!-- RESET BUTTON & KEYBOARD HINTS -->
            <div class="harmonic-card" style="text-align:center;">
                <button class="harmonic-quick-btn" onclick="resetHarmonicDefaults()" style="padding:6px 12px;">Reset Defaults</button>
                <div style="margin-top:8px;font-size:9px;color:#64748b;text-align:left;">
                    <strong>Keyboard:</strong><br>
                    Space = toggle play<br>
                    ‚Üê/‚Üí = path direction<br>
                    ‚Üë/‚Üì = sector direction<br>
                    Esc = stop
                </div>
            </div>
        </div>
    </div>
</div>
<div class="container">
    <h1>Farey Sector Formula - Complete Research Platform</h1>
    <p class="subtitle">Comprehensive analysis with RH connections, modular arithmetic, and advanced visualizations</p>
    
    <div class="formula-box">
        <div class="formula-main" id="formulaDisplay">C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))</div>
        <div id="formulaComputed" style="text-align:center; font-size:0.9em; color:#22c55e; margin-top:8px; display:none;"></div>
        <p style="text-align:center; font-size:0.85em; opacity:0.9;">Asymptotic count of coprime pairs (r, m) with r/m in sector S_n = (1/(n+1), 1/n]</p>
    </div>
    
    <div class="control-panel">
        <div class="control-row">
            <label>Mode:</label>
            <div class="mode-selector">
                <div class="mode-btn active" onclick="setMode('exact')" id="mode-exact">Exact</div>
                <div class="mode-btn" onclick="setMode('hybrid')" id="mode-hybrid">Hybrid</div>
                <div class="mode-btn" onclick="setMode('formula')" id="mode-formula">Formula</div>
            </div>
            <span class="info-badge" id="modeDescription">Exact enumeration</span>
        </div>
        <div class="control-row">
            <div class="control-group highlight">
                <label>N:</label>
                <input type="number" id="nMin" value="1" min="1"> to
                <input type="number" id="nMax" value="500" min="2">
            </div>
            <div class="control-group highlight">
                <label>Sectors:</label>
                <input type="number" id="sectorMin" value="1" min="1"> to
                <input type="number" id="sectorMax" value="275" min="1">
            </div>
            <button onclick="computeAll()">Compute</button>
            <button class="secondary" onclick="cancelComputation()">Cancel</button>
            <button class="secondary" onclick="exportAllData()">Export All</button>
            <button class="composite-export-btn" onclick="exportCompositeTab()" title="Export all visible charts to single 4K image">4K Composite Export</button>
        </div>
        
        <!-- Sector Bound Controls -->
        <div class="control-row" style="background:#0f172a;padding:8px 12px;border-radius:6px;margin-top:8px;border:1px solid #334155;">
            <label style="color:#94a3b8;font-size:11px;margin-right:8px;">Sector Bound:</label>
            <label style="font-size:11px;"><input type="checkbox" id="useSectorBound" checked onchange="updateSectorBound()"> Auto-bound</label>
            <label style="margin-left:12px;font-size:11px;">Constant:</label>
            <select id="sectorBoundPreset" onchange="applySectorBoundPreset()" style="font-size:11px;padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;">
                <option value="sqrt3pi" selected>‚àö3/œÄ ‚âà 0.5513</option>
                <option value="sqrt6pi">‚àö6/œÄ ‚âà 0.7797</option>
                <option value="1pi">1/œÄ ‚âà 0.3183</option>
                <option value="2pi">2/œÄ ‚âà 0.6366</option>
                <option value="sqrt2pi">‚àö2/œÄ ‚âà 0.4502</option>
                <option value="1">1.0000</option>
                <option value="custom">Custom...</option>
            </select>
            <label style="margin-left:8px;font-size:11px;">or enter:</label>
            <input type="text" id="customSectorBound" value="sqrt(3)/pi" placeholder="e.g. sqrt(6)/pi" style="width:100px;font-size:11px;padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;font-family:monospace;" onchange="applyCustomSectorBound()">
            <span id="sectorBoundValue" style="color:#22c55e;font-size:11px;font-family:monospace;margin-left:8px;">= 0.5513</span>
            <span id="sectorBoundResult" style="color:#f59e0b;font-size:11px;margin-left:8px;">‚Üí Max sector: 275</span>
        </div>
        
        <!-- Bounded P/C Analysis for Large N -->
        <div class="control-row" style="background:#1e1b4b;padding:8px 12px;border-radius:6px;margin-top:8px;border:1px solid #6366f1;">
            <label style="color:#a5b4fc;font-size:11px;font-weight:bold;margin-right:8px;">Large N P/C Analysis:</label>
            <label style="font-size:11px;"><input type="checkbox" id="computeBoundedPC" checked> Compute bounded window for P/C ratios</label>
            <label style="margin-left:12px;font-size:11px;">Window N:</label>
            <input type="number" id="boundedWindowN" value="1500" min="100" max="3000" style="width:70px;font-size:11px;padding:3px 6px;background:#1e293b;border:1px solid #475569;border-radius:3px;color:#e2e8f0;">
            <span style="color:#64748b;font-size:10px;margin-left:8px;">(exact data computed up to this N for P/C ratios)</span>
            <button onclick="showConvergenceAnalysis()" class="secondary" style="margin-left:12px;font-size:10px;padding:4px 8px;">Convergence Analysis</button>
        </div>
        
        <!-- Global Display Format Controls -->
        <div class="control-row" style="background:linear-gradient(135deg,#1e1b4b,#312e81);padding:10px 15px;border-radius:6px;margin-top:10px;">
            <label style="color:#a5b4fc;font-weight:600;">Global Display:</label>
            <select id="globalDisplayFormat" onchange="updateGlobalDisplayFormat()" style="padding:5px 10px;background:#0f172a;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                <option value="fraction">Fraction (r/m)</option>
                <option value="decimal">Decimal</option>
                <option value="degree">Degrees (0-360¬∞)</option>
                <option value="radian">Radians (0-2œÄ)</option>
                <option value="pi">œÄ-fraction (√óœÄ)</option>
            </select>
            <label style="color:#a5b4fc;margin-left:15px;">Precision:</label>
            <select id="globalPrecision" onchange="updateGlobalDisplayFormat()" style="padding:5px 10px;background:#0f172a;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                <option value="2">2 decimals</option>
                <option value="4" selected>4 decimals</option>
                <option value="6">6 decimals</option>
                <option value="8">8 decimals</option>
                <option value="10">10 decimals</option>
                <option value="12">12 decimals</option>
            </select>
            <span id="globalFormatPreview" style="color:#22c55e;margin-left:15px;font-family:monospace;">1/2 = 0.5000</span>
        </div>
        
        <div class="progress-bar" id="progressBar" style="display:none;"><div class="progress-fill" id="progressFill"></div></div>
        <div id="statusArea"></div>
    </div>
    
    <div class="tabs">
        <div class="tab active" onclick="switchTab('main')">Main</div>
        <div class="tab" onclick="switchTab('theory')">Theory</div>
        <div class="tab" onclick="switchTab('theoryviz')">Theory Viz</div>
        <div class="tab" onclick="switchTab('gaps')">Gaps</div>
        <div class="tab" onclick="switchTab('franel')">Franel-Landau</div>
        <div class="tab" onclick="switchTab('dedekind')">Dedekind</div>
        <div class="tab" onclick="switchTab('cf')">Continued Fractions</div>
        <div class="tab" onclick="switchTab('psl')">PSL(2,Z)</div>
        <div class="tab" onclick="switchTab('euler')">Euler Product</div>
        <div class="tab" onclick="switchTab('modular')">Modular</div>
        <div class="tab" onclick="switchTab('3d')">3D View</div>
        <div class="tab" onclick="switchTab('hyperbolic')">Hyperbolic</div>
        <div class="tab" onclick="switchTab('animation')">Animation</div>
        <div class="tab" onclick="switchTab('smith')">Smith Chart</div>
        <div class="tab" onclick="switchTab('stats')">Statistics</div>
        <div class="tab" onclick="switchTab('primes')">Primes</div>
        <div class="tab" onclick="switchTab('harmonic')">Harmonic</div>
        <div class="tab" onclick="switchTab('primorial')">Primorial Sieve</div>
        <div class="tab" onclick="switchTab('horizon')">Horizon</div>
        <div class="tab" onclick="switchTab('research')">Research</div>
    </div>
    
    <!-- MAIN TAB -->
    <div id="tab-main" class="tab-content active">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #6366f1;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Main Sector Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#6366f1;">C(n,N) = 3N¬≤ / (œÄ¬≤ n(n+1))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;"><strong>Definition:</strong> Sectors are defined by consecutive Farey bounds: sector S_n spans the interval (1/(n+1), 1/n], a decreasing sequence of intervals that partition [0,1]. <strong>Formula Purpose:</strong> This asymptotic formula provides increasingly accurate predictions of the count of coprime pairs (r,m) with r/m in sector S_n, where N is the maximum denominator. As N grows, the accuracy of this prediction improves significantly. The formula shows how the Farey sequence distributes its fractions across the unit interval with mathematical precision.</p>
        </div>
        <div class="stat-grid" id="mainStats"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Exact vs Predicted 
                    <button class="secondary" onclick="playErrorBySector('count')" style="font-size:10px;padding:3px 8px;margin-left:10px;">‚ñ∂ Play</button>
                </h4>
                <canvas id="mainCountChart"></canvas>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Relative Error % 
                    <button class="secondary" onclick="playErrorBySector('error')" style="font-size:10px;padding:3px 8px;margin-left:10px;">‚ñ∂ Play All</button>
                    <button id="playSelectedRangeBtn" class="secondary" onclick="playSelectedErrorRange()" style="font-size:10px;padding:3px 8px;display:none;">‚ñ∂ Play Selection</button>
                    <button class="secondary" onclick="clearErrorSelection()" style="font-size:10px;padding:3px 8px;">Clear</button>
                    <button class="secondary" onclick="stopAllPlayback()" style="font-size:10px;padding:3px 8px;">‚ñ†</button>
                    <span id="errorSelectionInfo" style="font-size:10px;color:#64748b;margin-left:10px;"></span>
                </h4>
                <div style="margin-bottom:8px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
                    <label style="color:#94a3b8;font-size:11px;">Click/Selection Mode:</label>
                    <select id="errorPlaybackMode" onchange="updateErrorModeHint()" style="font-size:11px;padding:3px 8px;background:#1e293b;border:1px solid #475569;border-radius:4px;color:#e2e8f0;">
                        <option value="error">Error Magnitude (pitch = error%)</option>
                        <option value="fractions">All Fractions in Sector</option>
                        <option value="representative">Representative Fraction</option>
                    </select>
                    <span style="color:#64748b;font-size:10px;" id="errorModeHint">Higher error ‚Üí higher pitch</span>
                </div>
                <canvas id="mainErrorChart"></canvas>
            </div>
        </div>
        <div class="panel" style="margin-top:15px;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:10px;">
                <h4 style="margin:0;">Sector Data <span style="font-weight:normal; color:#64748b;">(click row to see details)</span></h4>
                <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
                    <label style="font-size:11px;color:#94a3b8;"><input type="checkbox" id="showCategoryColumns" onchange="updateMainTable()"> Show Categories</label>
                    <button id="playAllSectorsBtn" onclick="playAllSectorsSequentially()" style="padding:5px 12px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ Play All Sectors</button>
                    <button onclick="stopAllPlayback()" style="padding:5px 8px;font-size:11px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ† Stop</button>
                    <label style="color:#94a3b8;">View Sector:</label>
                    <select id="sectorDataSelect" onchange="showSectorDataDetail(this.value)" style="padding:5px 10px;background:#1e1b4b;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                        <option value="">-- Select Sector --</option>
                    </select>
                    <button onclick="exportSectorCSV(document.getElementById('sectorDataSelect').value)" class="secondary" style="font-size:11px;">Export Sector CSV</button>
                    <button onclick="exportAllSectorsCSV()" class="secondary" style="font-size:11px;">Export All CSV</button>
                </div>
            </div>
            <!-- Category legend -->
            <div id="categoryLegend" style="display:none;margin-bottom:10px;padding:8px 12px;background:#1e1b4b;border-radius:6px;font-size:11px;border:1px solid #334155;">
                <div style="margin-bottom:6px;">
                    <span style="color:#94a3b8;margin-right:8px;"><strong>Columns:</strong></span>
                    <span style="color:#f59e0b;margin-right:12px;">P(m) = Prime denominator count</span>
                    <span style="color:#6366f1;margin-right:12px;">C(m) = Composite denominator count</span>
                    <span style="color:#22c55e;margin-right:12px;">P/C = P(m)/C(m) ratio</span>
                    <span style="color:#a5b4fc;margin-right:12px;">P(r) = Prime numerator count</span>
                </div>
                <div>
                    <span style="color:#94a3b8;margin-right:8px;"><strong>Categories:</strong></span>
                    <span style="color:#22c55e;margin-right:12px;">PP = Both prime (r prime, m prime)</span>
                    <span style="color:#f59e0b;margin-right:12px;">PC = Prime num, Composite denom</span>
                    <span style="color:#6366f1;margin-right:12px;">CP = Composite num, Prime denom</span>
                    <span style="color:#94a3b8;">CC = Both composite</span>
                </div>
            </div>
            <div class="table-scroll"><table id="mainTable"><thead><tr id="mainTableHeader"><th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th><th title="P(m) = Prime denominator count (m is prime: 2,3,5,7,...)">P(m)</th><th title="C(m) = Composite denominator count (m is composite: 4,6,8,9,...)">C(m)</th><th title="P/C = P(m)/C(m) ratio">P/C</th></tr></thead><tbody></tbody></table></div>
            
            <!-- Sector Detail Panel -->
            <div id="sectorDetailPanel" style="display:none;margin-top:15px;background:#0f172a;border-radius:8px;padding:15px;border:1px solid #334155;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px;">
                    <div>
                        <h5 style="margin:0;color:#a78bfa;" id="sectorDetailTitle">Sector Details</h5>
                        <div style="margin-top:6px;font-size:12px;">
                            <span style="color:#94a3b8;">P/C Ratio (denom): </span>
                            <span id="sectorPCRatio" style="color:#22c55e;font-family:monospace;font-weight:bold;">-</span>
                        </div>
                    </div>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                        <button onclick="playSectorDetailFractions('primes','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#f59e0b,#d97706);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ P(m)</button>
                        <button onclick="playSectorDetailFractions('composites','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ C(m)</button>
                        <button onclick="playSectorDetailFractions('PP','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ PP</button>
                        <button onclick="playSectorDetailFractions('all','forward')" style="padding:4px 10px;font-size:11px;background:linear-gradient(135deg,#8b5cf6,#7c3aed);border:none;border-radius:4px;color:white;cursor:pointer;">‚ñ∂ All</button>
                        <button onclick="closeSectorDetail()" style="padding:4px 10px;font-size:11px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;">‚úï Close</button>
                    </div>
                </div>
                
                <!-- Category breakdown stats -->
                <div id="sectorCategoryStats" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:8px;margin-bottom:12px;padding:10px;background:#1e293b;border-radius:6px;">
                    <div style="text-align:center;"><div style="color:#f59e0b;font-size:16px;font-weight:bold;" id="statPrimeM">0</div><div style="font-size:10px;color:#94a3b8;">P(m) Prime denom</div></div>
                    <div style="text-align:center;"><div style="color:#6366f1;font-size:16px;font-weight:bold;" id="statCompM">0</div><div style="font-size:10px;color:#94a3b8;">C(m) Comp denom</div></div>
                    <div style="text-align:center;"><div style="color:#a5b4fc;font-size:16px;font-weight:bold;" id="statPrimeR">0</div><div style="font-size:10px;color:#94a3b8;">P(r) Prime num</div></div>
                    <div style="text-align:center;"><div style="color:#22c55e;font-size:16px;font-weight:bold;" id="statPP">0</div><div style="font-size:10px;color:#94a3b8;">PP Both prime</div></div>
                    <div style="text-align:center;"><div style="color:#f59e0b;font-size:16px;font-weight:bold;" id="statPC">0</div><div style="font-size:10px;color:#94a3b8;">PC P-num C-denom</div></div>
                    <div style="text-align:center;"><div style="color:#6366f1;font-size:16px;font-weight:bold;" id="statCP">0</div><div style="font-size:10px;color:#94a3b8;">CP C-num P-denom</div></div>
                    <div style="text-align:center;"><div style="color:#94a3b8;font-size:16px;font-weight:bold;" id="statCC">0</div><div style="font-size:10px;color:#94a3b8;">CC Both comp</div></div>
                </div>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;">
                    <div>
                        <h6 style="color:#f59e0b;margin:0 0 8px 0;">Prime Denominators (<span id="sectorPrimeCount">0</span>)</h6>
                        <div id="sectorPrimesList" style="background:#1e293b;padding:10px;border-radius:6px;max-height:200px;overflow-y:auto;font-family:monospace;font-size:0.85em;"></div>
                    </div>
                    <div>
                        <h6 style="color:#6366f1;margin:0 0 8px 0;">Composite Denominators (<span id="sectorCompositeCount">0</span>)</h6>
                        <div id="sectorCompositesList" style="background:#1e293b;padding:10px;border-radius:6px;max-height:200px;overflow-y:auto;font-family:monospace;font-size:0.85em;"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel chart-wrapper">
            <h4>Sector Ring <span style="font-weight:normal; color:#64748b;">(click points to see tree path)</span></h4>
            
            <!-- MAIN CONTROLS + PRESETS ROW (Combined) -->
            <div class="control-row" style="margin-bottom:8px;background:#1e1b4b;padding:10px 12px;border-radius:6px;border:1px solid #6366f1;">
                <label>Sector: <input type="number" id="viewSector" value="1" min="1" onchange="drawMainRing(); updateFormulaDisplay();" style="width:60px;"></label>
                <label>Color: <select id="colorMode" onchange="drawMainRing()"><option value="sector">Sector</option><option value="prime">Prime</option><option value="denominator">Denom</option><option value="gap">Gap</option></select></label>
                <label><input type="checkbox" id="showAllSectors" onchange="drawMainRing()"> All</label>
                <span style="color:#475569;margin:0 8px;">|</span>
                <span style="color:#a5b4fc;font-size:11px;">Presets:</span>
                <button class="secondary" onclick="applyPreset('quick')" style="font-size:10px;padding:4px 8px;">Quick (N=50)</button>
                <button class="secondary" onclick="applyPreset('standard')" style="font-size:10px;padding:4px 8px;">Standard (N=200)</button>
                <button class="secondary" onclick="applyPreset('detailed')" style="font-size:10px;padding:4px 8px;">Detailed (N=500)</button>
                <button class="secondary" onclick="applyPreset('deep')" style="font-size:10px;padding:4px 8px;">Deep (N=1000)</button>
                <button class="secondary" onclick="applyPreset('primes')" style="font-size:10px;padding:4px 8px;border-color:#f59e0b;color:#f59e0b;">Prime Focus</button>
                <button class="secondary" onclick="applyPreset('musical')" style="font-size:10px;padding:4px 8px;border-color:#22c55e;color:#22c55e;">Musical (N=12)</button>
            </div>
            
            <!-- ANIMATION ROW -->
            <div class="control-row" style="margin-bottom:8px;background:#0f172a;padding:8px 12px;border-radius:6px;border:1px solid #334155;">
                <span style="color:#94a3b8;font-size:11px;margin-right:10px;">Animation:</span>
                <button id="ringAnimateBtn" onclick="toggleRingAnimation()" style="background:linear-gradient(135deg,#22c55e,#16a34a);font-size:11px;padding:5px 12px;">‚ñ∂ Animate N</button>
                <button id="sectorSweepBtn" onclick="toggleSectorSweep()" style="background:linear-gradient(135deg,#8b5cf6,#6366f1);font-size:11px;padding:5px 12px;">‚ñ∂ Sweep Sectors</button>
                <button onclick="stepRingAnimation(1)" class="secondary" style="font-size:11px;padding:5px 8px;">N+1</button>
                <button onclick="stepRingAnimation(-1)" class="secondary" style="font-size:11px;padding:5px 8px;">N-1</button>
                <button onclick="stepSectorAnimation(1)" class="secondary" style="font-size:11px;padding:5px 8px;">S+1</button>
                <button onclick="stepSectorAnimation(-1)" class="secondary" style="font-size:11px;padding:5px 8px;">S-1</button>
                <label style="margin-left:10px;font-size:11px;">Speed:
                    <select id="ringAnimSpeed" style="font-size:10px;padding:3px;">
                        <option value="50">Fast</option>
                        <option value="150" selected>Normal</option>
                        <option value="300">Slow</option>
                        <option value="500">Very Slow</option>
                    </select>
                </label>
                <label style="margin-left:10px;font-size:11px;"><input type="checkbox" id="animWithSound" checked> Sound</label>
                <span id="ringAnimStatus" style="margin-left:auto;color:#64748b;font-size:11px;"></span>
            </div>
            
            <!-- PLAYBACK ROW -->
            <div class="control-row" style="margin-bottom:10px;">
                <button class="secondary" onclick="openSectorModal(+document.getElementById('viewSector').value)">View Sector Details</button>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playSectorSequence('forward')" id="sectorPlayBtn" title="Play sector ascending">‚ñ∂ Forward</button>
                <button style="background:linear-gradient(135deg,#6366f1,#8b5cf6);" onclick="playSectorSequence('backward')" title="Play sector descending">‚óÄ Backward</button>
                <button class="secondary" onclick="stopAllPlayback()" title="Stop playback">‚ñ† Stop</button>
                <label style="margin-left:10px;">Speed: <select id="playbackSpeed" style="width:80px;"><option value="100">Fastest</option><option value="150">Fast</option><option value="250" selected>Normal</option><option value="400">Slow</option><option value="600">Very Slow</option></select></label>
            </div>
            <div style="text-align:center;position:relative;"><canvas id="mainRing" class="ring-canvas" width="600" height="600"></canvas><div class="point-tooltip" id="pointTooltip"></div></div>
            <div class="color-legend" id="colorLegend"></div>
            <div style="margin-top:10px;"><button onclick="screenshotFullTab('main')">Screenshot Full Main Tab</button></div>
        </div>
        
        <div class="panel chart-wrapper">
            <h4>Sector Tree Path <span style="font-weight:normal; color:#64748b;">(Stern-Brocot navigation - click nodes to play)</span></h4>
            <div class="control-row" style="margin-bottom:8px;background:#1e1b4b;padding:8px 12px;border-radius:6px;border:1px solid #6366f1;">
                <label>View Sector: 
                    <select id="treeSectorFilter" onchange="drawSectorTree()" style="width:120px;">
                        <option value="all">All Sectors</option>
                        <option value="1">Sector 1 (1/2, 1]</option>
                        <option value="2">Sector 2 (1/3, 1/2]</option>
                        <option value="3">Sector 3 (1/4, 1/3]</option>
                        <option value="4">Sector 4 (1/5, 1/4]</option>
                        <option value="5">Sector 5 (1/6, 1/5]</option>
                        <option value="6">Sector 6 (1/7, 1/6]</option>
                        <option value="7">Sector 7 (1/8, 1/7]</option>
                        <option value="8">Sector 8 (1/9, 1/8]</option>
                        <option value="9">Sector 9 (1/10, 1/9]</option>
                        <option value="10">Sector 10 (1/11, 1/10]</option>
                    </select>
                </label>
                <label>Color by: 
                    <select id="treeColorMode" onchange="drawSectorTree()">
                        <option value="default">Default</option>
                        <option value="sector">Sector</option>
                        <option value="prime">Prime/Composite</option>
                        <option value="arnold">Arnold Tongue</option>
                    </select>
                </label>
                <label><input type="checkbox" id="treeHighlightOnly" onchange="drawSectorTree()"> Highlight Only</label>
                <button class="secondary" onclick="playTreeSectorFractions()" style="font-size:11px;">‚ñ∂ Play Sector</button>
            </div>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Tree Depth: <input type="number" id="treeDepth" value="8" min="3" max="15" onchange="drawSectorTree()"></label>
                <label><input type="checkbox" id="showTreeLabels" checked onchange="drawSectorTree()"> Labels</label>
                <label><input type="checkbox" id="showTreeGrid" onchange="drawSectorTree()"> Grid</label>
                <label><input type="checkbox" id="animatePath" checked> Animate</label>
                <button class="secondary" onclick="clearTreePath()">Clear Path</button>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playTreePathAudio('forward')" id="treePlayBtn" title="Play path forward">‚ñ∂ Forward</button>
                <button style="background:linear-gradient(135deg,#6366f1,#8b5cf6);" onclick="playTreePathAudio('backward')" title="Play path backward">‚óÄ Backward</button>
                <button class="secondary" onclick="playChordFromPath()" title="Play all as chord">‚ô´ Chord</button>
                <button class="secondary" onclick="stopAllPlayback()">‚ñ† Stop</button>
            </div>
            <div style="text-align:center;position:relative;">
                <canvas id="sectorTreeCanvas" class="ring-canvas" width="900" height="500"></canvas>
            </div>
            <div id="treePathInfo" style="margin-top:10px; padding:10px; background:#0f172a; border-radius:5px; font-family:monospace; font-size:0.9em;">
                <span style="color:#64748b;">Click a point on the ring or tree to see its path and play its frequency</span>
            </div>
            <div class="color-legend">
                <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Tree nodes</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Path to target</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Target fraction</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>L (left)</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>R (right)</div>
                <div class="color-legend-item" style="border-left:1px solid #475569; padding-left:10px;"><strong style="color:#a5b4fc;">Sector Colors:</strong></div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,70%,50%)"></div>S1</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(36,70%,50%)"></div>S2</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(72,70%,50%)"></div>S3</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(108,70%,50%)"></div>S4</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:hsl(144,70%,50%)"></div>S5</div>
            </div>
        </div>
        
        <!-- MATHEMATICAL MUSIC GENERATOR -->
        <div class="panel chart-wrapper" style="background:linear-gradient(135deg,#1e1b4b 0%,#312e81 50%,#1e1b4b 100%);border:2px solid #8b5cf6;">
            <h4 style="color:#e0e7ff;">üéµ Mathematical Music Generator <span style="font-weight:normal;color:#a5b4fc;">(Procedural compositions from Farey mathematics)</span></h4>
            
            <!-- Style Presets -->
            <div class="control-row" style="margin-bottom:10px;background:#0f172a;padding:10px 12px;border-radius:6px;">
                <span style="color:#a5b4fc;font-size:11px;margin-right:10px;">Style:</span>
                <button id="musicStyle-epic" onclick="setMusicStyle('epic')" class="music-style-btn active" style="background:linear-gradient(135deg,#dc2626,#b91c1c);border:none;padding:6px 12px;border-radius:4px;color:white;cursor:pointer;font-size:11px;font-weight:600;">üî• Epic</button>
                <button id="musicStyle-battle" onclick="setMusicStyle('battle')" class="music-style-btn" style="background:linear-gradient(135deg,#7c3aed,#6d28d9);border:none;padding:6px 12px;border-radius:4px;color:white;cursor:pointer;font-size:11px;font-weight:600;">‚öîÔ∏è Battle</button>
                <button id="musicStyle-powerSurge" onclick="setMusicStyle('powerSurge')" class="music-style-btn" style="background:linear-gradient(135deg,#ea580c,#c2410c);border:none;padding:6px 12px;border-radius:4px;color:white;cursor:pointer;font-size:11px;font-weight:600;">‚ö° Power Surge</button>
                <button id="musicStyle-awakening" onclick="setMusicStyle('awakening')" class="music-style-btn" style="background:linear-gradient(135deg,#4f46e5,#3730a3);border:none;padding:6px 12px;border-radius:4px;color:white;cursor:pointer;font-size:11px;font-weight:600;">üí† Awakening</button>
                <button id="musicStyle-soulReaper" onclick="setMusicStyle('soulReaper')" class="music-style-btn" style="background:linear-gradient(135deg,#0f172a,#1e293b);border:1px solid #6366f1;padding:6px 12px;border-radius:4px;color:white;cursor:pointer;font-size:11px;font-weight:600;">üó°Ô∏è Soul Edge</button>
                <button id="musicStyle-hollow" onclick="setMusicStyle('hollow')" class="music-style-btn" style="background:linear-gradient(135deg,#18181b,#27272a);border:1px solid #ef4444;padding:6px 12px;border-radius:4px;color:white;cursor:pointer;font-size:11px;font-weight:600;">üåë Hollow</button>
            </div>
            <div class="control-row" style="margin-bottom:10px;background:#0f172a;padding:8px 12px;border-radius:6px;">
                <span style="color:#64748b;font-size:10px;margin-right:10px;">More:</span>
                <button id="musicStyle-finalForm" onclick="setMusicStyle('finalForm')" class="music-style-btn" style="background:linear-gradient(135deg,#fbbf24,#d97706);border:none;padding:5px 10px;border-radius:4px;color:black;cursor:pointer;font-size:10px;font-weight:600;">üëë Final Form</button>
                <button id="musicStyle-triumph" onclick="setMusicStyle('triumph')" class="music-style-btn" style="background:linear-gradient(135deg,#f59e0b,#d97706);border:none;padding:5px 10px;border-radius:4px;color:white;cursor:pointer;font-size:10px;font-weight:600;">üèÜ Triumph</button>
                <button id="musicStyle-resolve" onclick="setMusicStyle('resolve')" class="music-style-btn" style="background:linear-gradient(135deg,#2563eb,#1d4ed8);border:none;padding:5px 10px;border-radius:4px;color:white;cursor:pointer;font-size:10px;font-weight:600;">üí™ Resolve</button>
                <button id="musicStyle-dark" onclick="setMusicStyle('dark')" class="music-style-btn" style="background:linear-gradient(135deg,#1f2937,#111827);border:none;padding:5px 10px;border-radius:4px;color:white;cursor:pointer;font-size:10px;font-weight:600;">üåë Dark</button>
                <button id="musicStyle-mystical" onclick="setMusicStyle('mystical')" class="music-style-btn" style="background:linear-gradient(135deg,#0891b2,#0e7490);border:none;padding:5px 10px;border-radius:4px;color:white;cursor:pointer;font-size:10px;font-weight:600;">‚ú® Mystical</button>
                <button id="musicStyle-calm" onclick="setMusicStyle('calm')" class="music-style-btn" style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;padding:5px 10px;border-radius:4px;color:white;cursor:pointer;font-size:10px;font-weight:600;">üåä Calm</button>
            </div>
            
            <!-- Controls Row -->
            <div class="control-row" style="margin-bottom:10px;">
                <label>BPM: <input type="number" id="musicBPM" value="120" min="40" max="240" style="width:60px;" onchange="updateMusicTempo()"></label>
                <label>Scale: 
                    <select id="musicScale" onchange="updateMusicScale()">
                        <option value="minor">Natural Minor</option>
                        <option value="harmonicMinor">Harmonic Minor</option>
                        <option value="major">Major</option>
                        <option value="pentatonic">Pentatonic</option>
                        <option value="phrygian">Phrygian (dark)</option>
                        <option value="dorian">Dorian</option>
                        <option value="chromatic">Chromatic</option>
                    </select>
                </label>
                <label>Base: 
                    <select id="musicBaseNote">
                        <option value="130.81">C3</option>
                        <option value="146.83">D3</option>
                        <option value="164.81">E3</option>
                        <option value="174.61">F3</option>
                        <option value="196.00" selected>G3</option>
                        <option value="220.00">A3</option>
                        <option value="246.94">B3</option>
                    </select>
                </label>
                <label>Octaves: <input type="number" id="musicOctaves" value="3" min="1" max="5" style="width:50px;"></label>
                <label>Duration: 
                    <select id="musicDuration">
                        <option value="8">8 bars</option>
                        <option value="16" selected>16 bars</option>
                        <option value="32">32 bars</option>
                        <option value="64">64 bars (long)</option>
                        <option value="0">‚àû Loop</option>
                    </select>
                </label>
            </div>
            
            <!-- Pattern & Source Row -->
            <div class="control-row" style="margin-bottom:10px;">
                <label>Pattern: 
                    <select id="musicPattern">
                        <option value="arpeggio">Arpeggio Sweep</option>
                        <option value="melody" selected>Melodic Line</option>
                        <option value="chords">Chord Progression</option>
                        <option value="bassline">Bassline + Lead</option>
                        <option value="counterpoint">Counterpoint</option>
                    </select>
                </label>
                <label>Data Source: 
                    <select id="musicSource">
                        <option value="sectors" selected>Sector Fractions</option>
                        <option value="primes">Prime Denoms Only</option>
                        <option value="farey">Full Farey Sequence</option>
                        <option value="gaps">Gap Sizes</option>
                        <option value="errors">Prediction Errors</option>
                    </select>
                </label>
                <label>Sector Range: <input type="number" id="musicSectorStart" value="1" min="1" style="width:45px;"> - <input type="number" id="musicSectorEnd" value="10" min="1" style="width:45px;"></label>
                <label><input type="checkbox" id="musicAddBass" checked> Bass</label>
                <label><input type="checkbox" id="musicAddDrums"> Drums</label>
            </div>
            
            <!-- Playback Controls -->
            <div style="display:flex;align-items:center;gap:15px;margin-bottom:15px;padding:12px;background:#0f172a;border-radius:8px;">
                <button id="musicPlayBtn" onclick="toggleMathMusic()" style="background:linear-gradient(135deg,#22c55e,#16a34a);border:none;padding:12px 30px;border-radius:6px;color:white;cursor:pointer;font-size:14px;font-weight:600;display:flex;align-items:center;gap:8px;">
                    <span style="font-size:18px;">‚ñ∂</span> Generate & Play
                </button>
                <button onclick="stopMathMusic()" style="background:#ef4444;border:none;padding:12px 20px;border-radius:6px;color:white;cursor:pointer;font-size:14px;">‚ñ† Stop</button>
                <button onclick="exportMathMusicMIDI()" class="secondary" style="padding:10px 15px;font-size:12px;">Export Sequence</button>
                <div style="flex:1;text-align:center;">
                    <div id="musicStatusDisplay" style="color:#a5b4fc;font-size:12px;">Ready to generate mathematical music</div>
                    <div id="musicProgressBar" style="height:4px;background:#334155;border-radius:2px;margin-top:6px;overflow:hidden;display:none;">
                        <div id="musicProgressFill" style="height:100%;background:linear-gradient(90deg,#8b5cf6,#22c55e);width:0%;transition:width 0.1s;"></div>
                    </div>
                </div>
                <div style="text-align:right;">
                    <div style="color:#64748b;font-size:10px;">Current Note</div>
                    <div id="musicCurrentNote" style="color:#22c55e;font-size:18px;font-weight:bold;font-family:monospace;">‚Äî</div>
                </div>
            </div>
            
            <!-- Visualization Canvas -->
            <div style="position:relative;">
                <canvas id="musicVisualizerCanvas" width="880" height="120" style="width:100%;background:#0f172a;border-radius:6px;border:1px solid #334155;"></canvas>
                <div id="musicNoteOverlay" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;color:#8b5cf6;opacity:0;transition:opacity 0.15s;pointer-events:none;text-shadow:0 0 20px #8b5cf6;"></div>
            </div>
            
            <!-- Info -->
            <div style="margin-top:10px;padding:10px;background:#0f172a;border-radius:5px;font-size:11px;color:#64748b;">
                <strong style="color:#a5b4fc;">How it works:</strong> Farey fractions are mapped to musical notes using the selected scale. Sector boundaries create phrase structures, prime denominators trigger accent notes, and gap sizes influence rhythm/dynamics. Each style applies different transformations to create unique mathematical compositions.
            </div>
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('main')" style="padding:12px 24px; font-size:14px;">Screenshot Full Main Tab</button>
            <button class="secondary" onclick="exportMainTabData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Main Tab Data</button>
        </div>
    </div>
    
    <!-- THEORY TAB -->
    <div id="tab-theory" class="tab-content">
        <div class="panel">
            <h2 style="text-align:center; font-size:1.3em; margin-bottom:8px;">Directional Density of Coprime Lattice Points in Farey Sectors</h2>
            <p style="text-align:center; color:#94a3b8; font-style:italic; margin-bottom:20px;">Wessen Getachew</p>
            
            <div class="theorem-box" style="background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%); border-left-color: #8b5cf6;">
                <h4 style="color:#e0e7ff; margin-top:0;">Abstract</h4>
                <p style="margin:0; font-size:0.95em;">We study the distribution of coprime integer pairs (a,b) with bounded height whose rational slope lies in a fixed Farey sector S_n = (1/(n+1), 1/n]. Using classical summatory totient estimates together with a geometric decomposition of rational directions, we derive an explicit asymptotic formula for the number of primitive lattice points in each sector. This result provides a localized refinement of the global coprime density 1/zeta(2), revealing directional structure in the distribution of visible lattice points.</p>
            </div>
            
            <h3 style="margin-top:20px;">1. Introduction and Motivation</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #f59e0b; margin:10px 0;">
                <p>The probability that two randomly chosen integers are coprime is 1/zeta(2) = 6/pi^2 approximately 0.6079, a classical result with interpretations in analytic number theory and geometry of numbers. Geometrically, this corresponds to the density of visible lattice points in Z^2.</p>
                <p style="margin-top:8px;">Farey sequences organize rational numbers in [0,1] by increasing denominator and naturally partition rational directions into intervals. While global coprime density is well understood, we focus on <strong>directional coprime density</strong> - how primitive lattice points distribute across specific rational slope bands.</p>
            </div>
            
            <h3 style="margin-top:20px;">2. Definitions</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Farey Sector</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        S_n = (1/(n+1), 1/n]
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Intervals partitioning (0,1], bounded by consecutive Farey fractions.</p>
                </div>
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Primitive Lattice Point</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        (a,b) in Z^2 where gcd(a,b) = 1, b >= 1
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Pairs with coprime coordinates representing visible lattice points.</p>
                </div>
            </div>
            
            <h3>3. Main Result</h3>
            <div class="derivation-box" style="background: linear-gradient(135deg, #422006 0%, #5a3a1a 100%); border-left-color: #fbbf24;">
                <strong style="color:#fcd34d; font-size:1.1em;">Farey Sector Density Theorem</strong>
                <p style="margin:12px 0 0 0;">Let n be fixed. As N approaches infinity, the number of coprime integer pairs with slope in the Farey sector S_n satisfies:</p>
                <div style="background:#0f172a; padding:12px; border-radius:5px; font-family:monospace; font-size:1em; margin:10px 0; text-align:center;">
                    <strong>C(n,N) ~ (3/pi^2) * N^2 / (n(n+1))</strong>
                </div>
                <p style="margin:10px 0 0 0; font-size:0.9em;">Where C(n,N) counts pairs (a,b) with 1 <= b <= N, gcd(a,b)=1, and a/b in S_n.</p>
            </div>
            
            <h3 style="margin-top:20px;">4. Proof Sketch</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #22c55e; margin:10px 0;">
                <p><strong>Step 1:</strong> The condition a/b in S_n = (1/(n+1), 1/n] is equivalent to b/(n+1) < a <= b/n.</p>
                <p style="margin:8px 0;"><strong>Step 2:</strong> For each b, the number of integers a in this range is b/(n(n+1)) + O(1).</p>
                <p style="margin:8px 0;"><strong>Step 3:</strong> Restricting to coprime pairs: Sum over b<=N of phi(b)/(n(n+1)) + O(N)</p>
                <p style="margin:8px 0;"><strong>Step 4:</strong> Apply the classical summatory totient estimate:</p>
                <div style="background:#0a0f1a; padding:8px; margin:8px 0; border-radius:4px; font-family:monospace;">
                    Sum of phi(b) = (3/pi^2)N^2 + O(N log N)
                </div>
                <p style="margin:8px 0;"><strong>Conclusion:</strong> C(n,N) = (1/(n(n+1))) * ((3/pi^2)N^2 + O(N log N))</p>
            </div>
            
            <h3 style="margin-top:20px;">5. Computational Verification</h3>
            <table style="width:100%; margin-top:10px; border-collapse:collapse; font-size:0.85em;">
                <thead><tr style="background:#334155;"><th style="padding:8px;">Sector n</th><th>Width 1/(n(n+1))</th><th>Asymptotic Factor</th><th>Global Fraction</th></tr></thead>
                <tbody>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">1</td><td style="padding:8px;">1/2</td><td style="padding:8px;">3/(2pi^2)</td><td style="padding:8px;">approximately 0.1519</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">2</td><td style="padding:8px;">1/6</td><td style="padding:8px;">3/(6pi^2)</td><td style="padding:8px;">approximately 0.0506</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">3</td><td style="padding:8px;">1/12</td><td style="padding:8px;">3/(12pi^2)</td><td style="padding:8px;">approximately 0.0253</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">n</td><td style="padding:8px;">1/(n(n+1))</td><td style="padding:8px;">3/(pi^2 n(n+1))</td><td style="padding:8px;">1/n(n+1) * 6/pi^2</td></tr>
                </tbody>
            </table>
            <p style="margin-top:10px; font-size:0.85em; color:#94a3b8;">Numerical experiments confirm convergence to predicted asymptotics at rates consistent with O(N log N) error decay. Interactive visualizations above display accumulation of primitive lattice points within each Farey sector.</p>
            
            <h3 style="margin-top:20px;">6. Key Theoretical Connections</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Euler and Coprime Density</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Global density 1/zeta(2) = 6/pi^2 emerges as sum of sectoral contributions.</p>
                </div>
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Franel-Landau Connection</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Farey gap distribution relates to RH via: Sum|F_k - k/|F_N|| = O(N^(1/2+epsilon)) iff RH</p>
                </div>
            </div>
            
            <h3>7. Conclusion</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #3b82f6; margin:10px 0;">
                <p style="margin:0;">Farey sectors provide a natural geometric decomposition of rational directions. By combining this structure with classical coprime density results, we obtain an explicit directional refinement of visible lattice point counts. This framework enables anisotropic analysis of arithmetic distributions and provides foundation for modular constraints, higher-dimensional generalizations, and computational number theory.</p>
            </div>
            
            <p style="margin-top:20px; text-align:center; color:#64748b; font-size:0.85em;">Acknowledgments: Foundational work of Euler, Mertens, and others on totient summation and Farey geometry.</p>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('theory')">Screenshot Full Theory Tab</button></div>
        </div>
    </div>
    
    <!-- THEORY VIZ TAB -->
    <div id="tab-theoryviz" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Interactive Theory Visualization</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Visual exploration of the Farey Sector Density Theorem with interactive elements</p>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Max Sectors:</label>
                    <input type="number" id="tvMaxSectors" value="8" min="3" max="20" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Max N:</label>
                    <input type="number" id="tvMaxN" value="150" min="20" max="500" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Lattice Size:</label>
                    <input type="number" id="tvLatticeSize" value="22" min="10" max="40" onchange="drawTheoryViz()">
                </div>
                <div class="control-group">
                    <label>Highlight Sector:</label>
                    <input type="number" id="tvHighlightSector" value="2" min="1" max="10" onchange="drawTheoryViz()">
                </div>
                <button onclick="drawTheoryViz()">Refresh All</button>
                <button class="secondary" onclick="animateTheoryViz()">Animate Growth</button>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Sector Partition of (0,1]</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowSectorValues" checked onchange="drawSectorPartition()"> Values</label>
                    <label><input type="checkbox" id="tvShowSectorWidths" onchange="drawSectorPartition()"> Widths</label>
                    <label>Style: <select id="tvPartitionStyle" onchange="drawSectorPartition()"><option value="bar">Bar</option><option value="arc">Arc</option><option value="number">Number Line</option></select></label>
                </div>
                <canvas id="sectorPartitionCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="sectorPartitionLegend"></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Cone: C(n,N) ~ N¬≤/n(n+1)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sectors to show: <input type="number" id="tvConeSectors" value="4" min="1" max="10" onchange="drawDensityCone()"></label>
                    <label><input type="checkbox" id="tvShowConeRef" checked onchange="drawDensityCone()"> 6/œÄ¬≤ ref</label>
                    <label><input type="checkbox" id="tvLogScale" onchange="drawDensityCone()"> Log Y</label>
                </div>
                <canvas id="densityConeCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="densityConeLegend"></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Summatory Totient: Œ£œÜ(b) ~ 3N¬≤/œÄ¬≤</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowTotientActual" checked onchange="drawTotientSum()"> Actual</label>
                    <label><input type="checkbox" id="tvShowTotientPredicted" checked onchange="drawTotientSum()"> Predicted</label>
                    <label><input type="checkbox" id="tvShowTotientError" onchange="drawTotientSum()"> Error</label>
                    <label><input type="checkbox" id="tvTotientFill" onchange="drawTotientSum()"> Fill</label>
                </div>
                <canvas id="totientSumCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual Œ£œÜ(b)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Asymptotic 3N¬≤/œÄ¬≤</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Visible Lattice Points by Direction</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowHidden" checked onchange="drawLatticeViz()"> Hidden pts</label>
                    <label><input type="checkbox" id="tvShowSectorLines" checked onchange="drawLatticeViz()"> Sector lines</label>
                    <label><input type="checkbox" id="tvColorBySector" onchange="drawLatticeViz()"> Color by sector</label>
                    <label>Point size: <input type="range" id="tvPointSize" min="2" max="8" value="4" onchange="drawLatticeViz()"></label>
                </div>
                <canvas id="latticeVizCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Visible (gcd=1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Hidden (gcd>1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Sector Boundary</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Proof Visualization: Step-by-Step Accumulation</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sector n: <input type="number" id="tvProofSector" value="2" min="1" max="10" onchange="drawProofSteps()"></label>
                    <label><input type="checkbox" id="tvShowContribBars" checked onchange="drawProofSteps()"> Contrib bars</label>
                    <label><input type="checkbox" id="tvShowProofPredicted" checked onchange="drawProofSteps()"> Predicted</label>
                </div>
                <canvas id="proofStepsCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Cumulative count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted asymptotic</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>œÜ(b)/(n(n+1)) contribution</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Convergence Rate Analysis</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Analysis type: <select id="tvConvergenceType" onchange="drawConvergenceAnalysis()"><option value="relative">Relative Error</option><option value="absolute">Absolute Error</option><option value="ratio">Actual/Predicted</option></select></label>
                    <label><input type="checkbox" id="tvShowConvergenceTrend" checked onchange="drawConvergenceAnalysis()"> Trend line</label>
                </div>
                <canvas id="convergenceCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="convergenceLegend"></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Sector Density Heatmap: C(n,N) across parameters</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>N range: <input type="number" id="tvHeatmapNMin" value="20" min="10" max="100"> to <input type="number" id="tvHeatmapNMax" value="150" min="50" max="300"></label>
                <label>Sectors: <input type="number" id="tvHeatmapSectors" value="10" min="3" max="15"></label>
                <label>Color: <select id="tvHeatmapColor" onchange="drawDensityHeatmap()"><option value="viridis">Viridis</option><option value="plasma">Plasma</option><option value="coolwarm">Cool-Warm</option></select></label>
                <button onclick="drawDensityHeatmap()">Generate</button>
            </div>
            <canvas id="densityHeatmapCanvas" width="1100" height="300"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#440154"></div>Low density</div><div class="color-legend-item"><div class="color-swatch" style="background:#21918c"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#fde725"></div>High density</div></div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Theorem Summary:</strong> For fixed sector n, as N approaches infinity: C(n,N) = (3/œÄ¬≤) √ó N¬≤ / (n(n+1)) + O(N log N). This follows from summing œÜ(b)/(n(n+1)) over denominators b ‚â§ N and applying the classical totient summation formula.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('theoryviz')">Screenshot Full Theory Viz Tab</button></div>
    </div>
    
    <!-- GAPS TAB -->
    <div id="tab-gaps" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Farey Gap Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.2em;text-align:center;color:#8b5cf6;">gap(a/b, c/d) = |c/d - a/b| = 1/(b*d)</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">For consecutive Farey fractions a/b and c/d, the gap between them equals exactly 1/(b*d). This elegant formula shows that gaps decrease as denominators grow. The distribution reveals how fractions cluster and spread across the unit interval.</p>
        </div>
        <div class="stat-grid" id="gapStats" style="margin-top:12px;"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Gap Distribution (Color = Size)</h4><canvas id="gapDistChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Gap vs Denominator Product</h4><canvas id="gapVsDenomChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px; background:#0f172a;">
            <h4>Largest Gaps <span style="font-weight:normal;color:#64748b;">(sorted by gap size)</span></h4>
            <div class="table-scroll">
                <table id="gapTable">
                    <thead><tr><th>#</th><th>Left Fraction</th><th>Right Fraction</th><th>Actual Gap</th><th>Theoretical 1/(bd)</th><th>Match</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        <div class="connection-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> Every gap exactly equals 1/(bd) where b and d are the denominators of consecutive Farey fractions. This is a consequence of the mediant property: for neighbors a/b and c/d, we have |ad - bc| = 1.
        </div>
        <div style="margin-top:15px; padding:12px; background:#1e293b; border-radius:8px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <span style="color:#94a3b8; font-size:12px;">Hear the gaps as intervals:</span>
            <button onclick="playGapsAsIntervals('forward')" style="padding:8px 14px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Play Forward</button>
            <button onclick="playGapsAsIntervals('backward')" style="padding:8px 14px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:5px;color:white;cursor:pointer;">‚óÄ Play Backward</button>
            <button onclick="stopAllPlayback()" style="padding:8px 14px;background:#ef4444;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ† Stop</button>
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('gaps')">Screenshot Full Gaps Tab</button></div>
    </div>
    
    <!-- FRANEL-LANDAU TAB -->
    <div id="tab-franel" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #06b6d4;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Franel-Landau Theorem</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#06b6d4;">Œ£|Œ¥_k| = O(N^(1/2+Œµ)) ‚ü∫ Riemann Hypothesis</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Define Œ¥_k = F_k - k/|F_N| as the k-th Farey fraction deviation. The growth rate of Œ£|Œ¥_k| is directly equivalent to the Riemann Hypothesis. If RH is true, the sum grows slower than N^(1/2+Œµ) for any Œµ > 0. This provides a concrete computational test for RH properties through Farey sequence analysis. <strong style="color:#f87171;">Note: These computations illustrate known equivalences but do not constitute a proof or disproof of RH.</strong></p>
        </div>
        <div class="stat-grid" id="franelStats" style="margin-top:12px;"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Deviation Œ¥_k vs k</h4><canvas id="franelDeviationChart"></canvas></div>
                <div class="chart-box"><h4>Cumulative |Œ¥| / N^Œ±</h4><canvas id="franelCumulativeChart"></canvas></div>
            </div>
            <div class="chart-box" style="margin-top:15px;"><h4>Œ£|Œ¥| / N^Œ± for various Œ±</h4><canvas id="franelAlphaChart"></canvas></div>
            <div class="derivation-box" style="margin-top:15px;"><strong>Interpretation:</strong> If RH is true, the normalized sum should stay bounded. Divergence for alpha <= 1/2 would contradict RH.</div>
            <div style="margin-top:15px; padding:12px; background:#1e293b; border-radius:8px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span style="color:#94a3b8; font-size:12px;">Hear the Farey sequence:</span>
                <button onclick="playFareySequence('forward')" style="padding:8px 14px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Forward (0‚Üí1)</button>
                <button onclick="playFareySequence('backward')" style="padding:8px 14px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:5px;color:white;cursor:pointer;">‚óÄ Backward (1‚Üí0)</button>
                <button onclick="stopAllPlayback()" style="padding:8px 14px;background:#ef4444;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ† Stop</button>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('franel')">Screenshot Full Franel Tab</button></div>
    </div>
    
    <!-- DEDEKIND TAB -->
    <div id="tab-dedekind" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #f59e0b;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Dedekind Sums</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#f59e0b;">s(h,k) = Œ£_{j=1}^{k-1} ((j/k))((hj/k))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Dedekind sums are arithmetic functions encoding properties of coprime pairs (h,k). They satisfy reciprocity formulas: s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk)). These sums connect to modular forms and are fundamental in algebraic number theory.</p>
        </div>
        <div class="panel">
            <h3>Dedekind Sums</h3>
            <div class="theorem-box"><strong>Definition:</strong> s(h,k) = Œ£_{j=1}^{k-1} ((j/k))((hj/k)) where ((x)) = x - ‚åäx‚åã - 1/2 if x‚àâ‚Ñ§, else 0</div>
            <div class="control-row" style="margin:12px 0;"><label>Max k: <input type="number" id="dedekindMaxK" value="20" min="2" onchange="computeDedekind()"></label></div>
            <div class="grid-2">
                <div class="chart-box"><h4>s(h,k) Heatmap</h4><canvas id="dedekindHeatmap" width="400" height="400"></canvas></div>
                <div class="chart-box"><h4>s(1,k) vs k</h4><canvas id="dedekindChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Dedekind Sum Table</h4><div class="table-scroll"><table id="dedekindTable"><thead><tr><th>h</th><th>k</th><th>s(h,k)</th><th>12k¬∑s(h,k)</th><th>gcd</th></tr></thead><tbody></tbody></table></div></div>
            <div class="connection-box" style="margin-top:12px;"><strong>Reciprocity:</strong> s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk))</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('dedekind')">Screenshot Full Dedekind Tab</button></div>
        </div>
    </div>
    
    <!-- CONTINUED FRACTIONS TAB -->
    <div id="tab-cf" class="tab-content">
        <div class="panel">
            <h3>Continued Fractions</h3>
            <div class="theorem-box"><strong>Stern-Brocot Encoding:</strong> Path L^a R^b L^c... encodes CF [0; a, b, c, ...]</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Sector: <input type="number" id="cfSector" value="2" min="1" onchange="updateCFDisplay()"></label>
                <label>Max terms: <input type="number" id="cfMaxTerms" value="50" onchange="updateCFDisplay()"></label>
                <button onclick="updateCFDisplay()">Refresh</button>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playCFSelected()" title="Play selected CF fraction">‚ñ∂ Play</button>
                <button class="secondary" onclick="playCFConvergents()" title="Play convergents as scale">‚ô™ Convergents</button>
                <button class="secondary" onclick="playCFAll()" title="Play all fractions in sector">‚ô™ All</button>
            </div>
            
            <div class="panel" style="background:#1e1b4b; border:1px solid #6366f1; margin-bottom:15px;">
                <h4 style="color:#a5b4fc; margin-top:0;">Selected Fraction</h4>
                <div id="cfSelectedInfo" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:12px;">
                    <div style="color:#64748b; grid-column:1/-1;">Click a row in the table below to select a fraction</div>
                </div>
            </div>
            
            <div class="panel" style="background:#0f172a;"><h4>Continued Fraction Expansions <span style="font-weight:normal;color:#64748b;">(click row to select & play)</span></h4><div class="table-scroll"><table id="cfTable"><thead><tr><th>r/m</th><th>CF [a0; a1, a2, ...]</th><th>Path</th><th>Length</th><th>Sum(a_i)</th><th>Freq</th><th>Play</th></tr></thead><tbody></tbody></table></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>CF Length Distribution</h4><canvas id="cfLengthChart"></canvas></div>
                <div class="chart-box"><h4>First Partial Quotient</h4><canvas id="cfFirstChart"></canvas></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('cf')">Screenshot Full CF Tab</button></div>
        </div>
    </div>
    
    <!-- PSL(2,Z) TAB -->
    <div id="tab-psl" class="tab-content">
        <div class="panel">
            <h3>PSL(2,‚Ñ§) Matrices</h3>
            <div class="theorem-box"><strong>Farey Neighbor Property:</strong> For consecutive Farey fractions a/b, c/d: |ad - bc| = 1, giving matrix [a,c; b,d] ‚àà SL(2,‚Ñ§)</div>
            <div class="control-row" style="margin:12px 0;"><label>Max denom: <input type="number" id="pslMaxDenom" value="12" min="3" onchange="computePSL()"></label></div>
            <div class="panel" style="background:#0f172a;"><h4>Neighbor Matrices</h4><div id="pslMatrices" style="max-height:300px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Ford Circles</h4><canvas id="fordCanvas" width="500" height="250"></canvas></div>
                <div class="chart-box"><h4>Determinant Verification</h4><div id="pslVerification"></div></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('psl')">Screenshot Full PSL Tab</button></div>
        </div>
    </div>
    
    <!-- EULER PRODUCT TAB -->
    <div id="tab-euler" class="tab-content">
        <div class="panel">
            <h3>Euler Product for Œ∂(2)</h3>
            <div class="theorem-box"><strong>Euler:</strong> Œ∂(2) = Œ£ 1/n¬≤ = ‚àè_p 1/(1-1/p¬≤) = œÄ¬≤/6, hence 6/œÄ¬≤ = ‚àè_p (1-1/p¬≤)</div>
            <div class="control-row" style="margin:12px 0;"><label>Primes up to: <input type="number" id="eulerMaxP" value="50" min="5" onchange="computeEulerProduct()"></label></div>
            <div class="stat-grid" id="eulerStats"></div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Product Terms</h4><div id="eulerTerms" style="max-height:200px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Partial Product ‚Üí 6/œÄ¬≤</h4><canvas id="eulerProductChart"></canvas></div>
                <div class="chart-box"><h4>Partial Sum ‚Üí œÄ¬≤/6</h4><canvas id="eulerSumChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:12px;"><strong>Connection:</strong> The coprime probability 6/pi^2 emerges from excluding multiples of each prime p with probability 1/p^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('euler')">Screenshot Full Euler Tab</button></div>
        </div>
    </div>
    
    <!-- MODULAR TAB -->
    <div id="tab-modular" class="tab-content">
        <div class="panel">
            <h3>Modular Arithmetic Analysis</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Filter mod k: <input type="number" id="modK" value="6" min="2" onchange="updateModularAnalysis()"></label>
                <label>Residue a: <input type="number" id="modA" value="1" min="0" onchange="updateModularAnalysis()"></label>
                <button onclick="updateModularAnalysis()">Apply Filter</button>
            </div>
            <div class="stat-grid" id="modularStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Residue Class Distribution</h4><canvas id="residueClassChart"></canvas></div>
                <div class="chart-box"><h4>Prime Channel Ownership</h4><canvas id="primeChannelChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Lifting Tower: m ‚Üí 2m, 3m, ...</h4>
                <div id="liftingDisplay"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('modular')">Screenshot Full Modular Tab</button></div>
        </div>
    </div>
    
    <!-- 3D VIEW TAB -->
    <div id="tab-3d" class="tab-content">
        <div class="panel">
            <h3>3D Sector Cone</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Rotate X: <input type="range" id="rot3dX" min="-90" max="90" value="30" onchange="draw3D()"></label>
                <label>Rotate Z: <input type="range" id="rot3dZ" min="0" max="360" value="45" onchange="draw3D()"></label>
                <label>Perspective: <input type="range" id="perspective3d" min="100" max="1000" value="500" onchange="draw3D()"></label>
            </div>
            <div style="text-align:center;"><canvas id="canvas3d" class="ring-canvas" width="700" height="600"></canvas></div>
            <div class="derivation-box" style="margin-top:12px;">Third axis represents denominator m. Points at height m have coprime numerators r with r/m in the sector range. The cone structure shows density increasing with m^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('3d')">Screenshot Full 3D Tab</button></div>
        </div>
    </div>
    
    <!-- HYPERBOLIC TAB -->
    <div id="tab-hyperbolic" class="tab-content">
        <div class="panel">
            <h3>Hyperbolic Plane / Poincar√© Disk</h3>
            <div class="theorem-box"><strong>Farey Tessellation:</strong> The hyperbolic plane is tessellated by ideal triangles with vertices at Farey fractions on ‚àÇH.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Max denom: <input type="number" id="hypMaxDenom" value="15" min="3" onchange="drawHyperbolic()"></label>
                <label>Highlight sector: <input type="number" id="hypSector" value="2" min="1" onchange="drawHyperbolic()"></label>
            </div>
            <div style="text-align:center;"><canvas id="hypCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('hyperbolic')">Screenshot Full Hyperbolic Tab</button></div>
        </div>
    </div>
    
    <!-- ANIMATION TAB -->
    <div id="tab-animation" class="tab-content">
        <div class="panel">
            <h3>Farey Sequence Growth</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Animate to N: <input type="number" id="animMaxN" value="50" min="5"></label>
                <label>Speed (ms): <input type="number" id="animSpeed" value="200" min="50"></label>
                <button onclick="startAnimation()">Start</button>
                <button class="secondary" onclick="stopAnimation()">Stop</button>
                <span id="animStatus" class="info-badge">Ready</span>
            </div>
            <div style="text-align:center;"><canvas id="animCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div class="stat-grid" id="animStats" style="margin-top:12px;"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('animation')">Screenshot Full Animation Tab</button></div>
        </div>
    </div>
    
    <!-- SMITH CHART TAB -->
    <div id="tab-smith" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Smith Chart Transform (Cayley Map)</h3>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Cayley Transform</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">Œì = (z - 1)/(z + 1)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Input z</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">z = R¬∑e^(iŒ∏), Œ∏ = 2œÄr/M + Œ±</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Properties</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">Conformal ‚Ä¢ Angle-preserving</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Sector:</label>
                    <input type="number" id="smithSector" value="2" min="1" max="15" onchange="drawSmithChart()">
                </div>
                <div class="control-group highlight">
                    <label>Phase Œ±:</label>
                    <input type="range" id="smithPhase" min="0" max="360" value="90" onchange="updateSmithPhaseLabel(); drawSmithChart()">
                    <span id="smithPhaseLabel">90¬∞</span>
                </div>
                <div class="control-group">
                    <label>Radius Mode:</label>
                    <select id="smithRadiusMode" onchange="drawSmithChart()">
                        <option value="unit">Unit (R=1)</option>
                        <option value="index">By Index</option>
                        <option value="modulus" selected>By Modulus</option>
                        <option value="custom">Custom Scale</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Scale:</label>
                    <input type="number" id="smithCustomScale" value="1.0" min="0.1" max="5" step="0.1" onchange="drawSmithChart()">
                </div>
            </div>
            <div class="control-row">
                <label><input type="checkbox" id="smithShowGrid" checked onchange="drawSmithChart()"> Smith Grid</label>
                <label><input type="checkbox" id="smithShowConstR" checked onchange="drawSmithChart()"> Constant-R Circles</label>
                <label><input type="checkbox" id="smithShowConstX" checked onchange="drawSmithChart()"> Constant-X Arcs</label>
                <label><input type="checkbox" id="smithShowLabels" onchange="drawSmithChart()"> Point Labels</label>
                <label><input type="checkbox" id="smithColorByPrime" onchange="drawSmithChart()"> Color by Prime</label>
                <label><input type="checkbox" id="smithShowAllSectors" onchange="drawSmithChart()"> All Sectors</label>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Smith Chart (Cayley Transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Transformed points</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime moduli</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Constant-R</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#475569"></div>Constant-X</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Original z-plane (Pre-transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithOriginalCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>z = R¬∑e^(iŒ∏)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Unit circle</div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;background:#0f172a;">
            <h4>Transform Mathematics</h4>
            <div class="grid-3" style="gap:15px;">
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Cayley Transform</strong>
                    <div style="font-family:monospace;font-size:0.9em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Œì = (z - 1)/(z + 1)<br>
                        z = R¬∑e^(iŒ∏)
                    </div>
                </div>
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Real Part</strong>
                    <div style="font-family:monospace;font-size:0.85em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Re(Œì) = (AC + B¬≤)/(C¬≤ + B¬≤)<br>
                        A = RcosŒ∏ - 1, B = RsinŒ∏<br>
                        C = RcosŒ∏ + 1
                    </div>
                </div>
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Imaginary Part</strong>
                    <div style="font-family:monospace;font-size:0.85em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Im(Œì) = B(C - A)/(C¬≤ + B¬≤)<br>
                        Special (R=1):<br>
                        Œì(Œ∏) = i¬∑tan(Œ∏/2)
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Transform Data</h4>
            <div class="table-scroll" style="max-height:250px;">
                <table id="smithDataTable">
                    <thead><tr><th>r/m</th><th>Œ∏ (rad)</th><th>R</th><th>z = Re^iŒ∏</th><th>Œì = (z-1)/(z+1)</th><th>|Œì|</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('smith')">Screenshot Full Smith Tab</button></div>
    </div>
    
    <!-- STATISTICS TAB -->
    <div id="tab-stats" class="tab-content">
        <div class="panel">
            <h3>Statistical Analysis</h3>
            <div class="grid-2">
                <div class="chart-box"><h4>Random vs Actual Distribution</h4><canvas id="randomCompareChart"></canvas></div>
                <div class="chart-box"><h4>Cross-Sector Correlation</h4><canvas id="correlationChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Error Term O(N log N)</h4><canvas id="errorTermChart"></canvas></div>
                <div class="chart-box"><h4>Local Density Analysis</h4><canvas id="localDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Correlation Matrix</h4>
                <div id="correlationMatrix"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('stats')">Screenshot Full Statistics Tab</button></div>
        </div>
    </div>
    
    <!-- PRIMES TAB -->
    <div id="tab-primes" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #f59e0b;margin-bottom:20px;">
            <h3 style="color:#fcd34d;margin-top:0;">Prime Analysis</h3>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;"><strong>Overview:</strong> This tab explores how prime numbers manifest within the Farey sequence structure. Primes play a special role: for prime p, we have œÜ(p) = p-1 coprime residues, giving primes maximal density. The distribution of prime denominators across sectors reveals deep connections to the Prime Number Theorem and twin prime conjectures.</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Prime Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÄ(x) ~ x/ln(x)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Twin Prime Gap</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">p, p+2 both prime</div>
                </div>
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Euler's œÜ for prime p</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÜ(p) = p - 1</div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <div class="stat-grid" id="primeStats"></div>
            
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box chart-wrapper">
                    <h4>Twin Prime Gap Markers</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Scatter plot showing Farey gaps where both neighboring denominators are twin primes (p, p+2). The x-axis shows the position in [0,1], y-axis shows gap size. Clusters indicate regions rich in twin prime structure.</p>
                    <canvas id="twinPrimeChart"></canvas>
                </div>
                <div class="chart-box chart-wrapper">
                    <h4>Prime vs Composite Moduli</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Compares count of fractions with prime denominators (orange) vs composite denominators (purple) in each sector. Prime moduli contribute more fractions per unit since œÜ(p)/p = 1-1/p is larger for primes.</p>
                    <canvas id="primeVsCompositeChart"></canvas>
                </div>
            </div>
            
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box chart-wrapper">
                    <h4>Prime k-tuple Correlations</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Counts prime constellations appearing in Farey denominators: <strong>Twin</strong> (p, p+2), <strong>Cousin</strong> (p, p+4), <strong>Sexy</strong> (p, p+6), and prime triplets. These patterns connect to the Hardy-Littlewood conjectures on prime gaps.</p>
                    <canvas id="ktupleChart"></canvas>
                </div>
                <div class="chart-box chart-wrapper">
                    <h4>Prime Denominator Density</h4>
                    <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Shows œÜ(p) = p-1 for each prime denominator p. This linear growth demonstrates why primes contribute heavily to Farey sequences. The PNT reference line shows expected prime density œÄ(x) ~ x/ln(x).</p>
                    <canvas id="primeDenomDensityChart"></canvas>
                </div>
            </div>
            
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Twin Prime Gaps in Farey Sequence 
                    <button class="secondary" onclick="playTwinPrimeGaps()" style="font-size:10px;padding:4px 8px;margin-left:10px;">‚ñ∂ Play All</button>
                    <button class="secondary" onclick="stopAllPlayback()" style="font-size:10px;padding:4px 8px;">‚ñ† Stop</button>
                </h4>
                <p style="color:#64748b;font-size:0.8em;margin-bottom:10px;">Lists Farey neighbors where both denominators form a twin prime pair. Click any pair to hear the interval between them as frequencies. Twin primes create distinctive harmonic relationships due to their close denominators.</p>
                <div id="twinPrimeList" class="residue-list"></div>
            </div>
            
            <div class="derivation-box" style="margin-top:15px;">
                <strong>Mathematical Background:</strong> The distribution of primes among Farey denominators reflects the Prime Number Theorem: œÄ(N) ~ N/ln(N). Twin primes (p, p+2) are conjectured to be infinite (unproven), with density governed by the twin prime constant C‚ÇÇ ‚âà 0.66. The Hardy-Littlewood conjecture predicts ~2C‚ÇÇN/(ln N)¬≤ twin primes up to N. In harmonic terms, prime denominators produce "pure" frequency ratios with fewer overtone conflicts.
            </div>
            
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('primes')">Screenshot Full Primes Tab</button></div>
        </div>
    </div>
    
    <!-- HARMONIC ANALYSIS TAB -->
    <div id="tab-harmonic" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Harmonic Analysis & Arnold Tongues</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Map Farey fractions to musical frequencies, explore consonance/dissonance, and visualize Arnold tongues</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Frequency Ratio</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">f = f‚ÇÄ √ó (p/q)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Consonance Principle</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">Small q = Pure intervals</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Arnold Tongue Width</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">‚àù K/q (coupling/denom)</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Base Frequency:</label>
                    <input type="number" id="harmonicBaseFreq" value="220" min="20" max="2000" onchange="updateHarmonicTab()">
                    <span>Hz</span>
                </div>
                <div class="control-group">
                    <label>Sector:</label>
                    <input type="number" id="harmonicSector" value="2" min="1" max="15" onchange="updateHarmonicTab()">
                </div>
                <div class="control-group">
                    <label>Max Denom:</label>
                    <input type="number" id="harmonicMaxDenom" value="32" min="4" max="100" onchange="updateHarmonicTab()">
                </div>
                <button onclick="updateHarmonicTab()">Refresh</button>
                <button class="secondary" onclick="playHarmonicScale()">Play Scale</button>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Arnold Tongues (Stern-Brocot)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Coupling K: <input type="range" id="arnoldCoupling" min="0" max="100" value="60" oninput="drawArnoldTongues()"></label>
                    <span id="arnoldCouplingVal" style="color:#8b5cf6;">0.60</span>
                    <label><input type="checkbox" id="arnoldShowLabels" checked onchange="drawArnoldTongues()"> Labels</label>
                </div>
                <canvas id="arnoldTongueCanvas" width="550" height="400"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Unison (q=1)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>Consonant (q‚â§4)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Complex (q‚â§16)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Dissonant (q>16)</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Frequency Spectrum</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="freqLogScale" onchange="drawFrequencySpectrum()"> Log scale</label>
                    <label><input type="checkbox" id="freqShowOctaves" checked onchange="drawFrequencySpectrum()"> Octaves</label>
                    <label>Sort: <select id="freqSortMode" onchange="drawFrequencySpectrum()"><option value="freq">Frequency</option><option value="consonance">Consonance</option><option value="denom">Denominator</option></select></label>
                </div>
                <canvas id="freqSpectrumCanvas" width="550" height="400"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Frequency bars</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Octave lines</div>
                </div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Consonance Map</h4>
                <canvas id="consonanceMapCanvas" width="550" height="350"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>High consonance</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Low consonance</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Interval Circle (Pitch Class)</h4>
                <canvas id="intervalCircleCanvas" width="550" height="350"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Fraction position</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>12-TET reference</div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Musical Intervals in Sector</h4>
            <div class="table-scroll" style="max-height:300px;">
                <table id="intervalTable">
                    <thead><tr><th>Fraction</th><th>Ratio</th><th>Frequency</th><th>Cents</th><th>Closest Note</th><th>Interval Name</th><th>Mode</th><th>Play</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Harmonic Theory:</strong> Fractions p/q with small denominators q produce consonant intervals. The ancient Greeks discovered that simple ratios like 2:1 (octave), 3:2 (fifth), and 4:3 (fourth) sound harmonious. Arnold tongues show how these ratios create stable "locking" regions in coupled oscillator systems - wider tongues indicate more robust synchronization.
        </div>
        
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('harmonic')">Screenshot Full Harmonic Tab</button></div>
    </div>
    
    <!-- PRIMORIAL SIEVE TAB -->
    <div id="tab-primorial" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Primorial Sieve & Farey Sector Connection</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Exploring how primorial residue classes connect to Farey sector distribution</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Primorial Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÜ(P_k)/P_k = ‚àè(1-1/p)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Unified Formula</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">C(n,N,a,k) = 3N¬≤/(œÄ¬≤n(n+1)œÜ(k))</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">30√ó2‚Åø Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">œÜ(30√ó2‚Åø)/(30√ó2‚Åø) = 4/15</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Primorial Base:</label>
                    <select id="primorialBase" onchange="updatePrimorialSieve()">
                        <option value="6">P‚ÇÇ = 6 (2√ó3)</option>
                        <option value="30" selected>P‚ÇÉ = 30 (2√ó3√ó5)</option>
                        <option value="210">P‚ÇÑ = 210 (2√ó3√ó5√ó7)</option>
                        <option value="2310">P‚ÇÖ = 2310 (2√ó3√ó5√ó7√ó11)</option>
                    </select>
                </div>
                <div class="control-group highlight">
                    <label>Power 2‚Åø:</label>
                    <input type="number" id="primorialPower" value="0" min="0" max="6" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Max N:</label>
                    <input type="number" id="primorialN" value="200" min="50" max="1000" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Sectors:</label>
                    <input type="number" id="primorialSectors" value="8" min="3" max="15" onchange="updatePrimorialSieve()">
                </div>
                <button onclick="updatePrimorialSieve()">Compute</button>
                <button class="secondary" onclick="animateLiftingTree()">Animate Lifting</button>
            </div>
        </div>
        
        <div class="stat-grid" id="primorialStats"></div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Sector √ó Residue Heatmap</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="heatmapNormalize" checked onchange="drawSectorResidueHeatmap()"> Normalize rows</label>
                    <label><input type="checkbox" id="heatmapShowValues" onchange="drawSectorResidueHeatmap()"> Show values</label>
                    <label>Color: <select id="heatmapColorScheme" onchange="drawSectorResidueHeatmap()"><option value="purple">Purple</option><option value="heat">Heat</option><option value="viridis">Viridis</option></select></label>
                </div>
                <canvas id="sectorResidueHeatmap" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#1e1b4b"></div>Low</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#c4b5fd"></div>High</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Constant Verification: œÜ(k√ó2‚Åø)/(k√ó2‚Åø)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Show up to 2^<input type="number" id="densityMaxPower" value="8" min="1" max="12" onchange="drawDensityConstant()"></label>
                    <label><input type="checkbox" id="densityShowTheory" checked onchange="drawDensityConstant()"> Theory line</label>
                </div>
                <canvas id="densityConstantCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual œÜ(m)/m</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Constant = œÜ(P_k)/P_k</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Lifting Tree: Residue Class Splitting</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Levels: <input type="number" id="liftingLevels" value="4" min="2" max="6" onchange="drawLiftingTree()"></label>
                    <label>Highlight sector: <input type="number" id="liftingSector" value="2" min="1" max="10" onchange="drawLiftingTree()"></label>
                    <label><input type="checkbox" id="liftingShowCounts" checked onchange="drawLiftingTree()"> Counts</label>
                </div>
                <canvas id="liftingTreeCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Residue class</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>In sector</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Split children</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Unified Formula Verification</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Residue class a: <select id="unifiedResidueClass" onchange="drawUnifiedFormulaChart()"></select></label>
                    <label><input type="checkbox" id="unifiedShowAll" onchange="drawUnifiedFormulaChart()"> All classes</label>
                </div>
                <canvas id="unifiedFormulaCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual C(n,N,a,k)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted 3N¬≤/(œÄ¬≤n(n+1)œÜ(k))</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Prime Distribution Across Residue Classes</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="primeDistShowExpected" checked onchange="drawPrimeDistribution()"> Expected line</label>
                    <label><input type="checkbox" id="primeDistBySector" onchange="drawPrimeDistribution()"> Split by sector</label>
                </div>
                <canvas id="primeDistributionCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected (uniform)</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Sector Uniformity Test</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Test sector: <input type="number" id="uniformitySector" value="2" min="1" max="10" onchange="drawUniformityTest()"></label>
                    <label><input type="checkbox" id="uniformityShowChiSq" checked onchange="drawUniformityTest()"> œá¬≤ stat</label>
                </div>
                <canvas id="uniformityTestCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Actual per class</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected C(n,N)/œÜ(k)</div></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Primorial Comparison: œÜ(P_k)/P_k ‚Üí 6/œÄ¬≤ Convergence</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>Show primorials up to P_<input type="number" id="primorialCompareMax" value="8" min="3" max="12" onchange="drawPrimorialComparison()"></label>
                <label><input type="checkbox" id="primorialShowProduct" checked onchange="drawPrimorialComparison()"> Show ‚àè(1-1/p¬≤)</label>
                <label><input type="checkbox" id="primorialShowRatio" onchange="drawPrimorialComparison()"> Show ratio</label>
            </div>
            <canvas id="primorialComparisonCanvas" width="1100" height="350"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>œÜ(P_k)/P_k</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>‚àè(1-1/p¬≤) partial</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/œÄ¬≤</div></div>
        </div>
        
        <div class="panel" style="margin-top:15px;background:#0f172a;">
            <h4>Coprime Residue Classes for Current Modulus</h4>
            <div id="residueClassList" class="residue-list" style="max-height:150px;"></div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Sector √ó Residue Data Table</h4>
            <div class="table-scroll" style="max-height:300px;">
                <table id="sectorResidueTable">
                    <thead><tr><th>Sector</th><th>Total</th><th>Per Class Avg</th><th>œá¬≤ Stat</th><th>Uniform?</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> The unified formula C(n,N,a,k) = 3N¬≤/(œÄ¬≤n(n+1)œÜ(k)) combines Farey sector distribution with primorial residue filtering. This shows that coprimes distribute uniformly across residue classes within each sector, and the density œÜ(30√ó2‚Åø)/(30√ó2‚Åø) = 4/15 remains constant under power-of-2 scaling.
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('primorial')" style="padding:12px 24px; font-size:14px;">Screenshot Full Primorial Tab</button>
            <button class="secondary" onclick="exportPrimorialData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Primorial Data</button>
        </div>
    </div>
    
    <!-- RESEARCH TAB -->
    <!-- HORIZON TAB -->
    <div id="tab-horizon" class="tab-content">
        <div class="panel">
            <h3 style="color:#00ff88;">Farey Horizon & Mediant Generation</h3>
            
            <div style="background:#1a1a2e;padding:20px;border-radius:8px;border-left:4px solid #00ff88;margin-bottom:20px;">
                <h4 style="color:#00ff88;margin-top:0;">The Mediant Operation</h4>
                <p>Given two Farey neighbors <span style="font-family:monospace;">a/b</span> and <span style="font-family:monospace;">c/d</span>, their <span style="color:#ff9f43;font-weight:bold;">mediant</span> is:</p>
                <div style="background:#0f172a;padding:15px;border-radius:6px;text-align:center;font-size:1.3em;font-family:monospace;color:#00ff88;margin:15px 0;">med(a/b, c/d) = (a+c)/(b+d)</div>
                <p style="color:#94a3b8;font-size:0.9em;">The mediant always lies strictly between its parents and is in lowest terms when the parents are Farey neighbors (|ad - bc| = 1).</p>
            </div>
            
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;">
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;border-left:4px solid #5588ff;">
                    <h4 style="color:#5588ff;margin-top:0;">Sector Boundaries</h4>
                    <p>Sector S<sub>n</sub> = (1/(n+1), 1/n] is bounded by:</p>
                    <ul style="color:#94a3b8;">
                        <li><strong style="color:#e2e8f0;">Left boundary:</strong> 1/(n+1)</li>
                        <li><strong style="color:#e2e8f0;">Right boundary:</strong> 1/n</li>
                    </ul>
                    <p>The <span style="color:#ff6b6b;font-weight:bold;">Gatekeeper</span> 2/(2n+1) is the mediant of these boundaries.</p>
                </div>
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;border-left:4px solid #a855f7;">
                    <h4 style="color:#a855f7;margin-top:0;">Tree Confinement</h4>
                    <p><strong style="color:#e2e8f0;">Key insight:</strong> Mediants generated within a sector stay confined to that sector.</p>
                    <p style="color:#94a3b8;font-size:0.9em;">If a/b ‚àà S<sub>n</sub> and we take mediants with the sector boundaries, all descendants remain in S<sub>n</sub>.</p>
                    <p style="color:#94a3b8;font-size:0.9em;">The Stern-Brocot subtree rooted at the Gatekeeper generates exactly the fractions in S<sub>n</sub> ‚à© F<sub>N</sub>.</p>
                </div>
            </div>
            
            <div style="background:#1e2d3d;padding:20px;border-radius:8px;margin-bottom:20px;">
                <h4 style="margin-top:0;">Explorer Controls</h4>
                <div class="control-row">
                    <label>Sector n:</label>
                    <input type="number" id="horizonSectorN" value="5" min="1" max="500">
                    <label>Max Denom N:</label>
                    <input type="number" id="horizonMaxN" value="50" min="3" max="1000">
                    <button onclick="generateHorizon()">Generate</button>
                    <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playHorizonSequence()">‚ñ∂ Play</button>
                    <button style="background:linear-gradient(135deg,#6366f1,#8b5cf6);" onclick="playHorizonSequenceBackward()">‚óÄ Backward</button>
                    <button style="background:#ef4444;" onclick="stopAllPlayback()">‚ñ† Stop</button>
                </div>
            </div>
            
            <div id="horizonHarmonicInfo" style="background:linear-gradient(135deg,#1e1b4b,#312e81);padding:15px;border-radius:8px;margin-bottom:20px;display:none;">
                <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap;">
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Selected:</span>
                        <span id="horizonSelectedFrac" style="color:#8b5cf6;font-size:1.3em;font-weight:bold;margin-left:8px;">-</span>
                    </div>
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Frequency:</span>
                        <span id="horizonFreq" style="color:#22c55e;font-size:1.1em;margin-left:8px;">- Hz</span>
                    </div>
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Note:</span>
                        <span id="horizonNote" style="color:#f59e0b;font-size:1.1em;margin-left:8px;">-</span>
                    </div>
                    <div>
                        <span style="color:#94a3b8;font-size:11px;">Mode:</span>
                        <span id="horizonMode" style="margin-left:8px;">-</span>
                    </div>
                </div>
            </div>
            
            <div style="background:#111;border-radius:10px;padding:15px;margin-bottom:20px;">
                <canvas id="horizonCanvas" width="1100" height="200"></canvas>
                <div style="display:flex;gap:20px;justify-content:center;margin-top:15px;flex-wrap:wrap;">
                    <div style="display:flex;align-items:center;gap:5px;font-size:0.85em;"><div style="width:16px;height:16px;border-radius:3px;background:#5588ff;"></div> Boundary</div>
                    <div style="display:flex;align-items:center;gap:5px;font-size:0.85em;"><div style="width:16px;height:16px;border-radius:3px;background:#ff6b6b;"></div> Gatekeeper</div>
                    <div style="display:flex;align-items:center;gap:5px;font-size:0.85em;"><div style="width:16px;height:16px;border-radius:3px;background:#00ff88;"></div> Mediant Children</div>
                </div>
            </div>
            
            <div id="horizonStats" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:20px;"></div>
            
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px;">
                        <h4 style="color:#a78bfa;margin:0;">Mediant Generation Tree</h4>
                        <div style="display:flex;gap:6px;align-items:center;">
                            <select id="horizonTreeFormat" onchange="updateHorizonTree(horizonData, parseInt(document.getElementById('horizonSectorN').value))" style="padding:4px 8px;font-size:11px;background:#1e1b4b;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                                <option value="fraction">Use Global</option>
                                <option value="decimal2">Decimal (2)</option>
                                <option value="decimal4">Decimal (4)</option>
                                <option value="decimal6">Decimal (6)</option>
                                <option value="decimal8">Decimal (8)</option>
                            </select>
                            <button onclick="playHorizonByGeneration('forward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play generations forward">‚ñ∂ Gen‚Üí</button>
                            <button onclick="playHorizonByGeneration('backward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play generations backward">‚ÜêGen ‚óÄ</button>
                        </div>
                    </div>
                    <div id="horizonTreeDisplay" style="background:#0f172a;padding:15px;border-radius:6px;font-family:monospace;font-size:0.85em;max-height:300px;overflow-y:auto;">Select parameters and click Generate</div>
                </div>
                <div style="background:#1a1a2e;padding:20px;border-radius:8px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px;">
                        <h4 style="color:#a78bfa;margin:0;">Fractions in Sector (by value)</h4>
                        <div style="display:flex;gap:6px;align-items:center;">
                            <select id="horizonListFormat" onchange="updateHorizonFractionList(horizonData)" style="padding:4px 8px;font-size:11px;background:#1e1b4b;border:1px solid #6366f1;border-radius:4px;color:#e2e8f0;">
                                <option value="fraction">Use Global</option>
                                <option value="decimal2">Decimal (2)</option>
                                <option value="decimal4">Decimal (4)</option>
                                <option value="decimal6">Decimal (6)</option>
                                <option value="decimal8">Decimal (8)</option>
                            </select>
                            <button onclick="playHorizonByValue('forward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play by value ascending">‚ñ∂ 0‚Üí1</button>
                            <button onclick="playHorizonByValue('backward')" style="padding:5px 10px;font-size:11px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;" title="Play by value descending">1‚Üí0 ‚óÄ</button>
                        </div>
                    </div>
                    <div id="horizonFractionList" style="background:#0f172a;padding:15px;border-radius:6px;font-family:monospace;font-size:0.85em;max-height:300px;overflow-y:auto;">-</div>
                </div>
            </div>
            
            <div style="margin-top:20px;display:flex;gap:10px;flex-wrap:wrap;">
                <button onclick="screenshotFullTab('horizon')">Screenshot Full Horizon Tab</button>
                <button onclick="exportHorizonCanvas()" class="secondary">Export Number Line (4K)</button>
                <button onclick="exportHorizonData()" class="secondary">Export Data (CSV)</button>
            </div>
        </div>
    </div>

    <div id="tab-research" class="tab-content">
        <div class="panel">
            <h3>Research Tools</h3>
            
            <h4>Custom Formula Tester</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>Formula C(n,N) = </label>
                <input type="text" id="customFormula" value="3*N*N/(Math.PI*Math.PI*n*(n+1))" style="width:300px;">
                <button onclick="testCustomFormula()">Test</button>
            </div>
            <div class="chart-box" style="margin-top:12px;"><h4>Custom vs Standard</h4><canvas id="customFormulaChart"></canvas></div>
            
            <h4 style="margin-top:20px;">Batch Parameter Sweep</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>N range: <input type="number" id="batchNMin" value="50"> to <input type="number" id="batchNMax" value="200"> step <input type="number" id="batchNStep" value="10"></label>
                <button onclick="runBatchSweep()">Run Sweep</button>
            </div>
            <div class="table-scroll" style="margin-top:12px;"><table id="batchTable"><thead><tr><th>N</th><th>|F_N|</th><th>Œ£|Œ¥|</th><th>Œ£|Œ¥|/‚àöN</th><th>Max Gap</th><th>Mean Gap</th></tr></thead><tbody></tbody></table></div>
            
            <h4 style="margin-top:20px;">Publication Export</h4>
            <div class="control-row" style="margin:12px 0;">
                <button onclick="exportLatexFigures()">LaTeX Figures</button>
                <button onclick="exportCSVAll()">Full CSV</button>
                <button onclick="exportJSON()">JSON Data</button>
            </div>
            <div class="latex-output" id="latexFigures"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('research')">Screenshot Full Research Tab</button></div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="pointModal"><div class="modal-content" style="max-width:450px;"><div class="modal-header"><h3 id="pointModalTitle">Point</h3><button class="modal-close" onclick="closePointModal()">x</button></div><div class="modal-body" id="pointModalBody"></div></div></div>

<div class="modal-overlay" id="sectorModal"><div class="modal-content" style="max-width:700px;"><div class="modal-header"><h3 id="sectorModalTitle">Sector Details</h3><button class="modal-close" onclick="closeSectorModal()">x</button></div><div class="modal-body" id="sectorModalBody"></div></div></div>

<div class="screenshot-overlay" id="screenshotOverlay">
    <h3 style="color:#f1f5f9; margin-bottom:20px;">Screenshot Preview (with Legend)</h3>
    <img id="screenshotPreview" class="screenshot-preview">
    <div class="screenshot-actions">
        <button onclick="downloadScreenshot()">Download PNG</button>
        <button onclick="copyScreenshot()">Copy to Clipboard</button>
        <button class="secondary" onclick="closeScreenshotOverlay()">Close</button>
    </div>
</div>

<script>
const state = {
    mode: 'exact', nMin: 1, nMax: 500, sectorMin: 1, sectorMax: 275,
    sectors: [], residuesBySector: {}, allResidues: [], gaps: [], farey: [],
    computing: false, charts: {}, ringPoints: [], animationId: null,
    sectorBoundConstant: Math.sqrt(3) / Math.PI, // Default ‚àö3/œÄ
    // Bounded window data for P/C analysis in large N mode
    boundedResiduesBySector: {},
    boundedN: 1500,
    useBoundedPC: true
};

const sectorColors = ['#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899','#f43f5e','#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6','#06b6d4','#0ea5e9','#3b82f6'];
function getSectorColor(n) { return sectorColors[(n) % sectorColors.length]; }

// Canvas state
let currentScreenshotData = null;

function downloadScreenshot() {
    if (!currentScreenshotData) return;
    const a = document.createElement('a');
    a.href = currentScreenshotData;
    a.download = 'farey_chart_' + Date.now() + '.png';
    a.click();
}

async function copyScreenshot() {
    if (!currentScreenshotData) return;
    try {
        const blob = await (await fetch(currentScreenshotData)).blob();
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        alert('Copied to clipboard!');
    } catch (e) {
        alert('Copy failed: ' + e.message);
    }
}

function closeScreenshotOverlay() {
    document.getElementById('screenshotOverlay').classList.remove('active');
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = 'Sector ' + n + ': (1/' + (n+1) + ', 1/' + n + ']';
    
    let primesHtml = primes.length > 0 
        ? primes.map(p => '<span class="residue-item prime" title="m=' + p.m + ' is prime">' + p.r + '/' + p.m + '</span>').join('') 
        : '<span style="color:#64748b">No prime moduli in this sector</span>';
    
    let compositesHtml = composites.length > 0 
        ? composites.slice(0,100).map(c => '<span class="residue-item">' + c.r + '/' + c.m + '</span>').join('') 
        : '<span style="color:#64748b">No composite moduli in this sector</span>';
    
    if (composites.length > 100) {
        compositesHtml += '<span style="color:#64748b; display:block; margin-top:8px;">... and ' + (composites.length - 100) + ' more</span>';
    }
    
    let html = '<div class="stat-grid" style="margin-bottom:15px;">' +
        '<div class="stat-card"><div class="stat-value">' + res.length + '</div><div class="stat-label">Total Pairs</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#f59e0b">' + primes.length + '</div><div class="stat-label">Prime Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#6366f1">' + composites.length + '</div><div class="stat-label">Composite Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector ? fmt(sector.predicted) : '-') + '</div><div class="stat-label">Predicted</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-') + '</div><div class="stat-label">Error</div></div>' +
        '</div>' +
        '<h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (' + primes.length + ')</h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(245,158,11,0.3);">' + primesHtml + '</div>' +
        '<h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (' + composites.length + ') <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(99,102,241,0.3);">' + compositesHtml + '</div>' +
        '<div style="margin-top:15px; display:flex; gap:10px; flex-wrap:wrap;">' +
        '<button onclick="playSectorAudio(' + n + ',\'forward\')" style="background:linear-gradient(135deg,#22c55e,#16a34a);padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Play All Forward</button>' +
        '<button onclick="playSectorAudio(' + n + ',\'backward\')" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚óÄ Play Backward</button>' +
        '<button onclick="playSectorPrimes(' + n + ')" style="background:linear-gradient(135deg,#f59e0b,#d97706);padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ∂ Primes Only</button>' +
        '<button onclick="stopAllPlayback()" style="background:#ef4444;padding:8px 16px;border:none;border-radius:5px;color:white;cursor:pointer;">‚ñ† Stop</button>' +
        '<button onclick="exportSectorData(' + n + ')">Export CSV</button>' +
        '<button class="secondary" onclick="viewSectorOnRing(' + n + ')">View on Ring</button>' +
        '</div>';
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += r.r + ',' + r.m + ',' + r.value + ',' + r.isPrime + '\n';
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sector_' + n + '_data.csv';
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

function screenshotFullTab(tabName) {
    const tabElement = document.getElementById('tab-' + tabName);
    if (!tabElement) { alert('Tab not found'); return; }
    
    // For horizon tab, use html2canvas for better capture of all elements
    if (tabName === 'horizon') {
        screenshotHorizonTab();
        return;
    }
    
    const canvases = tabElement.querySelectorAll('canvas');
    const statGrids = tabElement.querySelectorAll('.stat-grid');
    const tables = tabElement.querySelectorAll('table');
    
    const padding = 40;
    const titleHeight = 80;
    const statsHeight = statGrids.length > 0 ? 100 : 0;
    
    // Calculate canvas section - 2 per row
    const canvasCount = canvases.length;
    const canvasRows = Math.ceil(canvasCount / 2);
    const canvasSectionHeight = canvasRows * 340;
    
    // Check if we have odd number of canvases (will have empty space)
    const hasEmptySpace = canvasCount % 2 === 1;
    
    // Calculate table height
    let tableHeight = 0;
    if (tables.length > 0) {
        const rows = Math.min(tables[0].querySelectorAll('tbody tr').length, 12);
        tableHeight = rows * 24 + 60;
    }
    tableHeight = Math.min(tableHeight, 350);
    
    // Formula panel height (for empty space or bottom)
    const formulaPanelHeight = 200;
    
    const totalWidth = 1000;
    const totalHeight = titleHeight + statsHeight + canvasSectionHeight + tableHeight + formulaPanelHeight + padding * 2;
    
    const composite = document.createElement('canvas');
    composite.width = totalWidth * 2;
    composite.height = totalHeight * 2;
    const ctx = composite.getContext('2d');
    ctx.scale(2, 2);
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    
    let currentY = padding;
    
    // Tab info for formulas
    const tabInfo = {
        'main': {
            title: 'Main Sector Analysis',
            formula: 'C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))',
            description: 'Asymptotic count of coprime pairs (r, m) with r/m in sector S‚Çô = (1/(n+1), 1/n]',
            params: (function() {
                const baseParams = ['Coprime density: 6/œÄ¬≤ ‚âà 0.6079', 'P(m)=Prime denom, C(m)=Comp denom', 'P/C = P(m)/C(m) ratio'];
                const showCats = document.getElementById('showCategoryColumns')?.checked;
                if (showCats) {
                    baseParams.push('PP=Both prime, PC=Prime r Comp m');
                    baseParams.push('CP=Comp r Prime m, CC=Both comp');
                }
                return baseParams;
            })()
        },
        'theory': {
            title: 'Farey Sector Density Theory',
            formula: 'C(n, N) ~ (3/œÄ¬≤) ¬∑ N¬≤ / n(n+1)',
            description: 'Distribution of coprime integer pairs with bounded height whose rational slope lies in a fixed Farey sector',
            params: ['Œ£œÜ(b) = 3N¬≤/œÄ¬≤ + O(N log N)', 'Global density: 1/Œ∂(2) = 6/œÄ¬≤', 'Visible lattice points']
        },
        'theoryviz': {
            title: 'Theory Visualization',
            formula: 'C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))',
            description: 'Interactive visual exploration of the Farey Sector Density Theorem',
            params: ['Summatory totient: Œ£œÜ(b) ~ 3N¬≤/œÄ¬≤', 'Sector partition of (0,1]', 'Convergence analysis']
        },
        'gaps': {
            title: 'Farey Gap Analysis',
            formula: 'gap(a/b, c/d) = |c/d - a/b| = 1/(b¬∑d)',
            description: 'For consecutive Farey fractions, the gap equals exactly 1/(b¬∑d)',
            params: ['Mediant property: |ad - bc| = 1', 'Gap decreases with denominator', 'Uniform distribution']
        },
        'franel': {
            title: 'Franel-Landau Theorem',
            formula: 'Œ£|Œ¥‚Çñ| = O(N^(1/2+Œµ)) ‚ü∫ RH',
            description: 'Equivalence between Farey sequence deviation growth and the Riemann Hypothesis',
            params: ['Œ¥‚Çñ = F‚Çñ - k/|F‚Çô|', 'RH implies bounded Œ£|Œ¥|/‚àöN', 'Computational verification']
        },
        'dedekind': {
            title: 'Dedekind Sums',
            formula: 's(h,k) = Œ£‚±º‚Çå‚ÇÅ·µè‚Åª¬π ((j/k))((hj/k))',
            description: 'Arithmetic functions encoding properties of coprime pairs with reciprocity laws',
            params: ['Reciprocity: s(h,k) + s(k,h) = -1/4 + ...', 'Sawtooth function ((x))', 'Modular forms connection']
        },
        'cf': {
            title: 'Continued Fractions',
            formula: 'r/m = [a‚ÇÄ; a‚ÇÅ, a‚ÇÇ, ...]',
            description: 'Stern-Brocot tree encoding via continued fraction expansion',
            params: ['Path L^a R^b encodes [0; a, b, ...]', 'Convergents approximate r/m', 'Best rational approximations']
        },
        'psl': {
            title: 'PSL(2,‚Ñ§) Matrices',
            formula: '[a,c; b,d] ‚àà SL(2,‚Ñ§) with |ad-bc|=1',
            description: 'Farey neighbors correspond to matrices with determinant ¬±1',
            params: ['Ford circles tangency', 'Hyperbolic tessellation', 'Modular group action']
        },
        'euler': {
            title: 'Euler Product for Œ∂(2)',
            formula: 'Œ∂(2) = Œ†‚Çö 1/(1-1/p¬≤) = œÄ¬≤/6',
            description: 'The coprime density emerges from excluding prime multiples',
            params: ['6/œÄ¬≤ = Œ†‚Çö(1-1/p¬≤)', 'Prime sieve interpretation', 'Basel problem solution']
        },
        'modular': {
            title: 'Modular Arithmetic Analysis',
            formula: 'm ‚â° a (mod k)',
            description: 'Residue class distribution and prime channel analysis',
            params: ['Lifting tower: m ‚Üí 2m, 3m, ...', 'Prime channel ownership', 'Residue class uniformity']
        },
        '3d': {
            title: '3D Sector Cone Visualization',
            formula: 'Points at height m have coprime r with r/m ‚àà S‚Çô',
            description: 'Third axis represents denominator m, showing density growth with m¬≤',
            params: ['Perspective projection', 'Color by prime/composite', 'Rotation controls']
        },
        'hyperbolic': {
            title: 'Hyperbolic Plane / Poincar√© Disk',
            formula: 'Farey tessellation of ‚Ñç',
            description: 'The hyperbolic plane is tessellated by ideal triangles with Farey vertices',
            params: ['Geodesics between neighbors', 'Ford circles on boundary', 'PSL(2,‚Ñ§) action']
        },
        'animation': {
            title: 'Farey Sequence Growth Animation',
            formula: '|F‚Çô| ~ 3N¬≤/œÄ¬≤',
            description: 'Watch the Farey sequence grow as N increases',
            params: ['Progressive density increase', 'Prime/composite distribution', 'Mediant insertion']
        },
        'smith': {
            title: 'Smith Chart Transform',
            formula: 'Œì = (Z-1)/(Z+1)',
            description: 'Map Farey fractions to Smith chart coordinates',
            params: ['Impedance transformation', 'Reflection coefficient', 'Complex plane mapping']
        },
        'stats': {
            title: 'Statistical Analysis',
            formula: 'Expected: 6N¬≤/œÄ¬≤, Actual: |coprimes|',
            description: 'Statistical comparison of actual vs theoretical distributions',
            params: ['Cross-sector correlation', 'Error term analysis', 'Local density variation']
        },
        'primes': {
            title: 'Prime Analysis',
            formula: 'œÜ(p) = p-1 for prime p',
            description: 'Prime denominator distribution and twin prime patterns',
            params: ['Prime vs composite ratio', 'k-tuple correlations', 'Gap patterns at primes']
        },
        'harmonic': {
            title: 'Harmonic Analysis',
            formula: 'freq = baseHz √ó (r/m)',
            description: 'Musical interpretation of Farey fractions as harmonic ratios',
            params: ['Just intonation ratios', 'Consonance by denominator', 'Interval relationships']
        },
        'primorial': {
            title: 'Primorial Sieve',
            formula: 'P# = Œ† p‚â§n',
            description: 'Analysis using primorial moduli to study coprime structure',
            params: ['Coprime residue classes', 'Sieve density œÜ(k)/k', 'Prime channel distribution']
        },
        'horizon': {
            title: 'Farey Horizon & Mediant Generation',
            formula: 'med(a/b, c/d) = (a+c)/(b+d)',
            description: 'Mediant operation generates all Farey fractions within a sector from boundaries',
            params: ['Gatekeeper: 2/(2n+1)', 'BFS tree generation', 'Sector confinement property']
        },
        'research': {
            title: 'Research Tools',
            formula: 'Custom: C(n,N) = f(n,N)',
            description: 'Tools for testing custom formulas and batch parameter sweeps',
            params: ['LaTeX export', 'CSV/JSON data export', 'Parameter sweep analysis']
        }
    };
    
    const info = tabInfo[tabName] || { title: tabName, formula: '', description: '', params: [] };
    
    // Header with gradient
    const gradient = ctx.createLinearGradient(0, 0, totalWidth, titleHeight);
    gradient.addColorStop(0, '#1e1b4b');
    gradient.addColorStop(1, '#312e81');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, totalWidth, titleHeight);
    
    // Title
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 24px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Farey Sector Formula - ' + info.title, padding, currentY + 30);
    
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText('N = ' + state.nMax + ' | Sectors ' + state.sectorMin + '-' + state.sectorMax + ' | ' + new Date().toLocaleString(), padding, currentY + 55);
    
    // Formula badge
    ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
    const formulaWidth = ctx.measureText(info.formula).width + 30;
    ctx.fillRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.strokeStyle = '#6366f1';
    ctx.strokeRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.fillStyle = '#e0e7ff';
    ctx.font = 'bold 14px "Cambria Math", serif';
    ctx.textAlign = 'right';
    ctx.fillText(info.formula, totalWidth - padding - 5, currentY + 38);
    
    currentY = titleHeight;
    
    // Stats section
    if (statGrids.length > 0) {
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(padding, currentY + 10, totalWidth - padding * 2, statsHeight - 20);
        ctx.strokeStyle = '#334155';
        ctx.strokeRect(padding, currentY + 10, totalWidth - padding * 2, statsHeight - 20);
        
        const statCards = statGrids[0].querySelectorAll('.stat-card');
        const statWidth = (totalWidth - padding * 2) / Math.min(statCards.length, 6);
        
        statCards.forEach((card, i) => {
            if (i >= 6) return;
            const x = padding + i * statWidth + statWidth / 2;
            const label = card.querySelector('.stat-label');
            const value = card.querySelector('.stat-value');
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '11px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(label ? label.textContent : '', x, currentY + 35);
            
            const valueEl = card.querySelector('.stat-value');
            ctx.fillStyle = valueEl && valueEl.style.color ? valueEl.style.color : '#6366f1';
            ctx.font = 'bold 18px system-ui';
            ctx.fillText(value ? value.textContent : '', x, currentY + 60);
        });
        currentY += statsHeight;
    }
    
    // Canvases - 2 per row
    const canvasWidth = (totalWidth - padding * 3) / 2;
    const canvasHeight = 300;
    
    canvases.forEach((canvas, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        // Get title from parent chart-box
        const chartBox = canvas.closest('.chart-box');
        const title = chartBox ? (chartBox.querySelector('h4') ? chartBox.querySelector('h4').textContent : 'Chart') : 'Chart';
        
        // Background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title bar
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x, y, canvasWidth, 25);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(title, x + 10, y + 17);
        
        // Draw canvas scaled
        const scale = Math.min((canvasWidth - 20) / canvas.width, (canvasHeight - 45) / canvas.height);
        const drawWidth = canvas.width * scale;
        const drawHeight = canvas.height * scale;
        const drawX = x + (canvasWidth - drawWidth) / 2;
        const drawY = y + 30 + (canvasHeight - 40 - drawHeight) / 2;
        
        try {
            ctx.drawImage(canvas, drawX, drawY, drawWidth, drawHeight);
        } catch (e) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('Canvas render error', drawX + 20, drawY + 50);
        }
    });
    
    // Fill empty space if odd number of canvases
    if (hasEmptySpace && canvasCount > 0) {
        const col = canvasCount % 2;
        const row = Math.floor(canvasCount / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        // Formula/Info panel in empty space
        ctx.fillStyle = '#1e1b4b';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title
        ctx.fillStyle = '#c7d2fe';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Key Formulas & Parameters', x + canvasWidth/2, y + 30);
        
        // Main formula box
        ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
        ctx.fillRect(x + 20, y + 50, canvasWidth - 40, 50);
        ctx.strokeStyle = '#8b5cf6';
        ctx.strokeRect(x + 20, y + 50, canvasWidth - 40, 50);
        ctx.fillStyle = '#f1f5f9';
        ctx.font = 'bold 16px "Cambria Math", serif';
        ctx.fillText(info.formula, x + canvasWidth/2, y + 82);
        
        // Computed example
        const viewSector = parseInt(document.getElementById('viewSector')?.value || 1);
        const N = state.nMax;
        const pi2 = Math.PI * Math.PI;
        const computedResult = (3 * N * N) / (pi2 * viewSector * (viewSector + 1));
        ctx.fillStyle = '#22c55e';
        ctx.font = '12px system-ui';
        ctx.fillText(`Example: C(${viewSector}, ${N.toLocaleString()}) = ${computedResult.toFixed(4)}`, x + canvasWidth/2, y + 115);
        
        // Description
        ctx.fillStyle = '#94a3b8';
        ctx.font = '11px system-ui';
        const descLines = wrapText(ctx, info.description, canvasWidth - 40);
        descLines.forEach((line, i) => {
            ctx.fillText(line, x + canvasWidth/2, y + 140 + i * 16);
        });
        
        // Parameters
        ctx.fillStyle = '#cbd5e1';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Definitions:', x + 25, y + 185);
        
        ctx.font = '11px system-ui';
        ctx.fillStyle = '#a5b4fc';
        info.params.forEach((param, i) => {
            ctx.fillText('‚Ä¢ ' + param, x + 30, y + 203 + i * 18);
        });
        
        // Current values
        ctx.fillStyle = '#64748b';
        ctx.font = '10px system-ui';
        ctx.fillText('Current: N=' + state.nMax + ', Sectors=' + state.sectorMin + '-' + state.sectorMax, x + 25, y + canvasHeight - 20);
    }
    
    currentY += canvasSectionHeight;
    
    // Tables section
    if (tables.length > 0 && tableHeight > 60) {
        const table = tables[0];
        const headers = table.querySelectorAll('thead th');
        const rows = table.querySelectorAll('tbody tr');
        
        ctx.fillStyle = '#cbd5e1';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Data Table', padding, currentY + 20);
        currentY += 30;
        
        // Header
        ctx.fillStyle = '#334155';
        ctx.fillRect(padding, currentY, totalWidth - padding * 2, 24);
        
        const colWidth = (totalWidth - padding * 2) / Math.max(headers.length, 1);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 10px system-ui';
        headers.forEach((h, i) => {
            ctx.fillText(h.textContent.substring(0, 12), padding + 8 + i * colWidth, currentY + 16);
        });
        currentY += 24;
        
        // Rows
        ctx.font = '10px system-ui';
        const maxRows = Math.min(rows.length, 10);
        for (let r = 0; r < maxRows; r++) {
            const row = rows[r];
            const cells = row.querySelectorAll('td');
            
            if (r % 2 === 0) {
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(padding, currentY, totalWidth - padding * 2, 20);
            }
            
            cells.forEach((cell, i) => {
                ctx.fillStyle = cell.style.color || '#e2e8f0';
                ctx.fillText(cell.textContent.substring(0, 15), padding + 8 + i * colWidth, currentY + 14);
            });
            currentY += 20;
        }
        
        if (rows.length > maxRows) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('... and ' + (rows.length - maxRows) + ' more rows', padding + 8, currentY + 14);
            currentY += 20;
        }
    }
    
    // Bottom formula panel
    currentY = totalHeight - formulaPanelHeight - padding;
    
    ctx.fillStyle = '#1e293b';
    ctx.fillRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    
    // Left side - Main formula
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Core Formula', padding + 20, currentY + 25);
    
    ctx.fillStyle = 'rgba(99, 102, 241, 0.15)';
    ctx.fillRect(padding + 20, currentY + 35, (totalWidth - padding * 2) / 2 - 40, 45);
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 18px "Cambria Math", serif';
    ctx.textAlign = 'center';
    ctx.fillText(info.formula, padding + 20 + ((totalWidth - padding * 2) / 2 - 40) / 2, currentY + 65);
    
    // Computed example
    const bottomViewSector = parseInt(document.getElementById('viewSector')?.value || 1);
    const bottomN = state.nMax;
    const bottomPi2 = Math.PI * Math.PI;
    const bottomResult = (3 * bottomN * bottomN) / (bottomPi2 * bottomViewSector * (bottomViewSector + 1));
    ctx.fillStyle = '#22c55e';
    ctx.font = '11px system-ui';
    ctx.fillText(`C(${bottomViewSector}, ${bottomN.toLocaleString()}) = ${bottomResult.toFixed(4)}`, padding + 20 + ((totalWidth - padding * 2) / 2 - 40) / 2, currentY + 90);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    const descLines2 = wrapText(ctx, info.description, (totalWidth - padding * 2) / 2 - 50);
    descLines2.forEach((line, i) => {
        ctx.fillText(line, padding + 25, currentY + 110 + i * 14);
    });
    
    // Right side - Parameters and constants
    const rightX = padding + (totalWidth - padding * 2) / 2 + 20;
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText('Definitions', rightX, currentY + 25);
    
    ctx.fillStyle = '#a5b4fc';
    ctx.font = '10px system-ui';
    info.params.forEach((param, i) => {
        ctx.fillText('‚Ä¢ ' + param, rightX + 5, currentY + 45 + i * 16);
    });
    
    // Constants box
    const constY = currentY + 45 + info.params.length * 16 + 10;
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(rightX, constY, 200, 55);
    ctx.strokeStyle = '#334155';
    ctx.strokeRect(rightX, constY, 200, 55);
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.fillText('Universal Constants:', rightX + 10, constY + 18);
    ctx.fillStyle = '#6366f1';
    ctx.font = '11px monospace';
    ctx.fillText('6/œÄ¬≤ = ' + (6/Math.PI/Math.PI).toFixed(8), rightX + 10, constY + 35);
    ctx.fillText('œÄ¬≤/6 = ' + (Math.PI*Math.PI/6).toFixed(8), rightX + 10, constY + 50);
    
    // Footer
    ctx.fillStyle = '#475569';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', totalWidth / 2, totalHeight - 15);
    
    currentScreenshotData = composite.toDataURL('image/png');
    document.getElementById('screenshotPreview').src = currentScreenshotData;
    document.getElementById('screenshotOverlay').classList.add('active');
}

// Special screenshot function for Horizon tab using html2canvas
async function screenshotHorizonTab() {
    const tabElement = document.getElementById('tab-horizon');
    if (!tabElement) { alert('Tab not found'); return; }
    
    // Show loading
    const loadingDiv = document.createElement('div');
    loadingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1e1b4b;padding:30px 50px;border-radius:10px;z-index:10000;color:#fff;font-size:16px;border:2px solid #8b5cf6;';
    loadingDiv.textContent = 'Capturing screenshot...';
    document.body.appendChild(loadingDiv);
    
    try {
        // Use html2canvas to capture the entire tab
        const canvas = await html2canvas(tabElement, {
            backgroundColor: '#0a0f1a',
            scale: 2,
            logging: false,
            useCORS: true,
            allowTaint: true
        });
        
        // Add header and footer
        const finalCanvas = document.createElement('canvas');
        const headerHeight = 80;
        const footerHeight = 40;
        finalCanvas.width = canvas.width;
        finalCanvas.height = canvas.height + headerHeight + footerHeight;
        const ctx = finalCanvas.getContext('2d');
        
        // Background
        ctx.fillStyle = '#0a0f1a';
        ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
        
        // Header gradient
        const gradient = ctx.createLinearGradient(0, 0, finalCanvas.width, headerHeight);
        gradient.addColorStop(0, '#1e1b4b');
        gradient.addColorStop(1, '#312e81');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, finalCanvas.width, headerHeight);
        
        // Header text
        ctx.fillStyle = '#f8fafc';
        ctx.font = 'bold 32px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Farey Horizon & Mediant Generation', 40, 45);
        
        const n = document.getElementById('horizonSectorN')?.value || 5;
        const maxN = document.getElementById('horizonMaxN')?.value || 50;
        ctx.font = '18px system-ui';
        ctx.fillStyle = '#a5b4fc';
        ctx.fillText('Sector ' + n + ' | N = ' + maxN + ' | Fractions: ' + (horizonData.fractions?.length || 0) + ' | ' + new Date().toLocaleString(), 40, 70);
        
        // Formula badge
        ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
        const formula = 'med(a/b, c/d) = (a+c)/(b+d)';
        ctx.font = 'bold 20px serif';
        const formulaWidth = ctx.measureText(formula).width + 40;
        ctx.fillRect(finalCanvas.width - formulaWidth - 40, 20, formulaWidth, 40);
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.strokeRect(finalCanvas.width - formulaWidth - 40, 20, formulaWidth, 40);
        ctx.fillStyle = '#e0e7ff';
        ctx.textAlign = 'right';
        ctx.fillText(formula, finalCanvas.width - 60, 48);
        
        // Main content
        ctx.drawImage(canvas, 0, headerHeight);
        
        // Footer
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(0, finalCanvas.height - footerHeight, finalCanvas.width, footerHeight);
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', finalCanvas.width / 2, finalCanvas.height - 15);
        
        currentScreenshotData = finalCanvas.toDataURL('image/png');
        document.getElementById('screenshotPreview').src = currentScreenshotData;
        document.getElementById('screenshotOverlay').classList.add('active');
        
    } catch (e) {
        alert('Screenshot failed: ' + e.message);
    } finally {
        document.body.removeChild(loadingDiv);
    }
}

// Helper function to wrap text
function wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        if (ctx.measureText(testLine).width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    });
    if (currentLine) lines.push(currentLine);
    return lines.slice(0, 3); // Max 3 lines
}

// Utilities
function gcd(a, b) { while(b) { [a,b] = [b, a%b]; } return a; }
function isPrime(n) { if(n<2) return false; if(n===2) return true; if(n%2===0) return false; for(let i=3;i*i<=n;i+=2) if(n%i===0) return false; return true; }
function mobius(n) { if(n===1) return 1; let c=0; for(let p=2;p*p<=n;p++) { if(n%p===0) { if(n%(p*p)===0) return 0; c++; n/=p; } } if(n>1) c++; return c%2===0?1:-1; }
function getSector(r,m) { const f=r/m; if(f<=0||f>1) return null; return Math.floor(1/f); }
function formula(n,N) { return (3*N*N)/(Math.PI*Math.PI*n*(n+1)); }
function fmt(x) { if(x>=1e9) return (x/1e9).toFixed(1)+'B'; if(x>=1e6) return (x/1e6).toFixed(1)+'M'; if(x>=1e3) return (x/1e3).toFixed(1)+'K'; return x.toFixed(x<10?2:0); }

// Continued fraction
function toCF(r, m) {
    const cf = [];
    while(m !== 0) { const q = Math.floor(r/m); cf.push(q); [r,m] = [m, r - q*m]; }
    return cf;
}
function cfPath(cf) {
    let path = '';
    for(let i=0; i<cf.length; i++) { path += (i%2===0?'R':'L').repeat(cf[i]); }
    return path;
}

// Dedekind sum
function sawtoothSum(h, k) {
    let s = 0;
    for(let j=1; j<k; j++) {
        const jk = j/k, hjk = (h*j/k) % 1;
        const s1 = jk - Math.floor(jk) - 0.5;
        const s2 = hjk - Math.floor(hjk) - 0.5;
        s += s1 * s2;
    }
    return s;
}

function setMode(mode) {
    state.mode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('mode-'+mode).classList.add('active');
    const descriptions = {
        exact: 'Full enumeration (N‚â§1500)',
        hybrid: 'Smart hybrid mode',
        formula: 'Instant formula only (any N)'
    };
    document.getElementById('modeDescription').textContent = descriptions[mode];
}

// =============================================
// SECTOR BOUND FUNCTIONS
// =============================================

function parseMathExpression(expr) {
    // Parse mathematical expressions like sqrt(3)/pi, sqrt(6)/pi, etc.
    try {
        let parsed = expr.toLowerCase()
            .replace(/sqrt\s*\(\s*(\d+)\s*\)/g, 'Math.sqrt($1)')
            .replace(/pi/g, 'Math.PI')
            .replace(/e(?![a-z])/g, 'Math.E')
            .replace(/ln\s*\(\s*([^)]+)\s*\)/g, 'Math.log($1)')
            .replace(/log\s*\(\s*([^)]+)\s*\)/g, 'Math.log10($1)');
        return eval(parsed);
    } catch (e) {
        console.warn('Failed to parse:', expr, e);
        return null;
    }
}

function updateSectorBound() {
    const useBound = document.getElementById('useSectorBound').checked;
    if (useBound) {
        const N = +document.getElementById('nMax').value || 500;
        const maxSector = Math.floor(N * state.sectorBoundConstant);
        document.getElementById('sectorMax').value = maxSector;
        document.getElementById('sectorBoundResult').textContent = `‚Üí Max sector: ${maxSector}`;
    }
}

function applySectorBoundPreset() {
    const preset = document.getElementById('sectorBoundPreset').value;
    let constant, displayExpr;
    
    switch(preset) {
        case 'sqrt3pi':
            constant = Math.sqrt(3) / Math.PI;
            displayExpr = 'sqrt(3)/pi';
            break;
        case 'sqrt6pi':
            constant = Math.sqrt(6) / Math.PI;
            displayExpr = 'sqrt(6)/pi';
            break;
        case '1pi':
            constant = 1 / Math.PI;
            displayExpr = '1/pi';
            break;
        case '2pi':
            constant = 2 / Math.PI;
            displayExpr = '2/pi';
            break;
        case 'sqrt2pi':
            constant = Math.sqrt(2) / Math.PI;
            displayExpr = 'sqrt(2)/pi';
            break;
        case '1':
            constant = 1;
            displayExpr = '1';
            break;
        case 'custom':
            // Don't change anything, let user enter custom
            return;
        default:
            constant = Math.sqrt(3) / Math.PI;
            displayExpr = 'sqrt(3)/pi';
    }
    
    state.sectorBoundConstant = constant;
    document.getElementById('customSectorBound').value = displayExpr;
    document.getElementById('sectorBoundValue').textContent = `= ${constant.toFixed(4)}`;
    updateSectorBound();
}

function applyCustomSectorBound() {
    const expr = document.getElementById('customSectorBound').value;
    const constant = parseMathExpression(expr);
    
    if (constant !== null && isFinite(constant) && constant > 0) {
        state.sectorBoundConstant = constant;
        document.getElementById('sectorBoundValue').textContent = `= ${constant.toFixed(4)}`;
        document.getElementById('sectorBoundPreset').value = 'custom';
        updateSectorBound();
    } else {
        document.getElementById('sectorBoundValue').textContent = '= invalid';
    }
}

// Update sector bound when N changes
document.addEventListener('DOMContentLoaded', function() {
    const nMaxInput = document.getElementById('nMax');
    if (nMaxInput) {
        nMaxInput.addEventListener('change', function() {
            if (document.getElementById('useSectorBound')?.checked) {
                updateSectorBound();
            }
        });
        nMaxInput.addEventListener('input', function() {
            if (document.getElementById('useSectorBound')?.checked) {
                updateSectorBound();
            }
        });
    }
    
    // Initialize sector bound display
    setTimeout(() => {
        applySectorBoundPreset();
    }, 100);
});

async function computeAll() {
    if(state.computing) return;
    state.computing = true;
    state.nMin = +document.getElementById('nMin').value;
    state.nMax = +document.getElementById('nMax').value;
    state.sectorMin = +document.getElementById('sectorMin').value;
    state.sectorMax = +document.getElementById('sectorMax').value;
    
    // Get bounded P/C settings
    state.useBoundedPC = document.getElementById('computeBoundedPC')?.checked ?? true;
    state.boundedN = +(document.getElementById('boundedWindowN')?.value || 1500);
    
    document.getElementById('progressBar').style.display = 'block';
    document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing...</span>';
    
    state.sectors = []; state.residuesBySector = {}; state.allResidues = []; state.gaps = []; state.farey = [];
    state.boundedResiduesBySector = {};
    
    const N = state.nMax;
    
    // Formula mode: fast path - no enumeration needed
    if(state.mode === 'formula') {
        // First compute bounded window for P/C ratios if enabled
        if (state.useBoundedPC) {
            document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing bounded P/C window...</span>';
            await computeBoundedWindow();
        }
        computeFormulaOnly();
        updateFormulaOnlyDisplays();
        document.getElementById('progressBar').style.display = 'none';
        document.getElementById('statusArea').innerHTML = '<span class="info-badge success">Done (Formula' + (state.useBoundedPC ? ' + Bounded P/C' : '') + ')</span>';
        state.computing = false;
        return;
    }
    
    // Exact/Hybrid modes with reasonable N
    if(N <= 1500) {
        await computeExact(N);
    } else {
        // Large N in non-formula mode: compute bounded window first for P/C
        if (state.useBoundedPC) {
            document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing bounded P/C window...</span>';
            await computeBoundedWindow();
        }
        // Then compute formula
        computeFormulaOnly();
        document.getElementById('statusArea').innerHTML = '<span class="info-badge" style="background:#f59e0b;">N > 1500 - using formula' + (state.useBoundedPC ? ' + bounded P/C' : '') + '</span>';
    }
    
    computeGaps();
    updateAllDisplays();
    
    document.getElementById('progressBar').style.display = 'none';
    if(N <= 1500) {
        document.getElementById('statusArea').innerHTML = '<span class="info-badge success">Done</span>';
    }
    state.computing = false;
}

async function computeExact(N) {
    let ops = 0;
    for(let m=2; m<=N; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const s = getSector(r,m);
                const isPrimeM = isPrime(m);
                const isPrimeR = isPrime(r);
                const res = {
                    r, m, sector:s, 
                    isPrime: isPrimeM,      // Denominator is prime
                    isPrimeNum: isPrimeR,   // Numerator is prime
                    category: isPrimeR && isPrimeM ? 'PP' :
                              isPrimeR && !isPrimeM ? 'PC' :
                              !isPrimeR && isPrimeM ? 'CP' : 'CC',
                    value: r/m
                };
                state.allResidues.push(res);
                if(s && s>=state.sectorMin && s<=state.sectorMax) {
                    if(!state.residuesBySector[s]) state.residuesBySector[s] = [];
                    state.residuesBySector[s].push(res);
                }
            }
        }
        ops += m;
        if(m%50===0) { document.getElementById('progressFill').style.width = (m/N*100)+'%'; await new Promise(r=>setTimeout(r,0)); }
        if(!state.computing) return;
    }
    state.allResidues.sort((a,b) => a.value - b.value);
    state.farey = state.allResidues.map(r => ({r:r.r, m:r.m, value:r.value}));
    
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        const res = state.residuesBySector[n] || [];
        const exact = res.length, pred = formula(n,N);
        const primeCount = res.filter(x=>x.isPrime).length;  // Prime denominator
        const primeNumCount = res.filter(x=>x.isPrimeNum).length;  // Prime numerator
        // Category counts
        const ppCount = res.filter(x=>x.category==='PP').length;  // Both prime
        const pcCount = res.filter(x=>x.category==='PC').length;  // Prime num, Composite denom
        const cpCount = res.filter(x=>x.category==='CP').length;  // Composite num, Prime denom
        const ccCount = res.filter(x=>x.category==='CC').length;  // Both composite
        
        state.sectors.push({
            n, exact, predicted:pred, error:exact-pred, 
            relError:exact>0?((exact-pred)/exact)*100:0, 
            width:1/(n*(n+1)), 
            primeCount,      // Prime denominators
            primeNumCount,   // Prime numerators
            ppCount, pcCount, cpCount, ccCount
        });
    }
}

function computeFormulaOnly() {
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        // Get bounded P/C data if available
        const boundedRes = state.boundedResiduesBySector[n] || [];
        const boundedPrimeCount = boundedRes.filter(x => x.isPrime).length;  // Prime denom
        const boundedPrimeNumCount = boundedRes.filter(x => x.isPrimeNum).length;  // Prime num
        const boundedCompositeCount = boundedRes.length - boundedPrimeCount;
        const boundedPCRatio = boundedCompositeCount > 0 ? boundedPrimeCount / boundedCompositeCount : null;
        
        // Category counts from bounded data
        const boundedPP = boundedRes.filter(x => x.category === 'PP').length;
        const boundedPC = boundedRes.filter(x => x.category === 'PC').length;
        const boundedCP = boundedRes.filter(x => x.category === 'CP').length;
        const boundedCC = boundedRes.filter(x => x.category === 'CC').length;
        
        state.sectors.push({
            n, 
            exact: null, 
            predicted: formula(n, state.nMax), 
            error: null, 
            relError: null, 
            width: 1/(n*(n+1)), 
            primeCount: null,
            primeNumCount: null,
            ppCount: null, pcCount: null, cpCount: null, ccCount: null,
            // Bounded window data
            boundedPrimeCount: boundedRes.length > 0 ? boundedPrimeCount : null,
            boundedPrimeNumCount: boundedRes.length > 0 ? boundedPrimeNumCount : null,
            boundedCompositeCount: boundedRes.length > 0 ? boundedCompositeCount : null,
            boundedPCRatio: boundedPCRatio,
            boundedTotal: boundedRes.length > 0 ? boundedRes.length : null,
            boundedExact: boundedRes.length > 0 ? boundedRes.length : null,
            boundedPredicted: formula(n, state.boundedN),
            boundedError: boundedRes.length > 0 ? boundedRes.length - formula(n, state.boundedN) : null,
            boundedRelError: boundedRes.length > 0 ? ((boundedRes.length - formula(n, state.boundedN)) / boundedRes.length) * 100 : null,
            // Bounded category counts
            boundedPP: boundedRes.length > 0 ? boundedPP : null,
            boundedPC: boundedRes.length > 0 ? boundedPC : null,
            boundedCP: boundedRes.length > 0 ? boundedCP : null,
            boundedCC: boundedRes.length > 0 ? boundedCC : null
        });
    }
}

// Compute bounded window for P/C ratios (async to not block UI)
async function computeBoundedWindow() {
    const boundedN = state.boundedN;
    state.boundedResiduesBySector = {};
    
    let ops = 0;
    for(let m = 2; m <= boundedN; m++) {
        for(let r = 1; r < m; r++) {
            if(gcd(r, m) === 1) {
                const s = getSector(r, m);
                if(s !== null && s >= state.sectorMin && s <= state.sectorMax) {
                    if(!state.boundedResiduesBySector[s]) state.boundedResiduesBySector[s] = [];
                    const isPrimeM = isPrime(m);
                    const isPrimeR = isPrime(r);
                    state.boundedResiduesBySector[s].push({
                        r, m, 
                        sector: s, 
                        isPrime: isPrimeM,      // Denominator is prime
                        isPrimeNum: isPrimeR,   // Numerator is prime
                        // Classification
                        category: isPrimeR && isPrimeM ? 'PP' :    // Both prime
                                  isPrimeR && !isPrimeM ? 'PC' :   // Prime num, Composite denom
                                  !isPrimeR && isPrimeM ? 'CP' :   // Composite num, Prime denom
                                  'CC',                             // Both composite
                        value: r/m
                    });
                }
            }
        }
        ops += m;
        if(m % 100 === 0) {
            document.getElementById('progressFill').style.width = (m / boundedN * 100) + '%';
            await new Promise(r => setTimeout(r, 0));
        }
        if(!state.computing) return;
    }
}

// Convergence analysis - show how error and P/C converge as N increases
function showConvergenceAnalysis() {
    // Compute data at multiple N values
    const nValues = [100, 200, 500, 1000, 1500, 2000, 5000, 10000, 50000, 100000, 1000000, 10000000];
    const sectorN = +(document.getElementById('viewSector')?.value || 2);
    
    let html = '<div style="max-height:500px;overflow-y:auto;">';
    html += '<h4 style="color:#a5b4fc;margin-bottom:12px;">Convergence Analysis for Sector ' + sectorN + '</h4>';
    html += '<p style="color:#94a3b8;font-size:12px;margin-bottom:12px;">Shows how error and P/C ratio converge as N ‚Üí ‚àû</p>';
    
    html += '<table style="width:100%;font-size:11px;border-collapse:collapse;">';
    html += '<thead><tr style="background:#1e293b;">';
    html += '<th style="padding:8px;text-align:left;border-bottom:1px solid #475569;">N</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Formula Pred</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Bounded Exact</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Rel Error %</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Primes</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">Composites</th>';
    html += '<th style="padding:8px;text-align:right;border-bottom:1px solid #475569;">P/C Ratio</th>';
    html += '</tr></thead><tbody>';
    
    // Use cached bounded data for actual counts
    const boundedRes = state.boundedResiduesBySector[sectorN] || [];
    const actualPrimes = boundedRes.filter(x => x.isPrime).length;
    const actualComposites = boundedRes.length - actualPrimes;
    const actualPCRatio = actualComposites > 0 ? actualPrimes / actualComposites : null;
    
    nValues.forEach(N => {
        const pred = formula(sectorN, N);
        
        // For bounded N, we can compute exact
        let exact = null, primes = null, composites = null, pcRatio = null, relError = null;
        
        if (N <= state.boundedN && boundedRes.length > 0) {
            // Filter bounded data to N
            const filtered = boundedRes.filter(f => f.m <= N);
            exact = filtered.length;
            primes = filtered.filter(f => f.isPrime).length;
            composites = exact - primes;
            pcRatio = composites > 0 ? primes / composites : null;
            relError = exact > 0 ? ((exact - pred) / exact) * 100 : 0;
        } else {
            // Extrapolate P/C ratio based on bounded data
            // P/C ratio should scale roughly as 1/ln(N) based on prime density
            if (actualPCRatio !== null) {
                const scaleFactor = Math.log(state.boundedN) / Math.log(N);
                pcRatio = actualPCRatio * scaleFactor;
            }
        }
        
        const errColor = relError !== null ? (Math.abs(relError) < 1 ? '#22c55e' : Math.abs(relError) < 5 ? '#f59e0b' : '#ef4444') : '#64748b';
        const pcColor = pcRatio !== null ? (pcRatio > 1 ? '#f59e0b' : '#6366f1') : '#64748b';
        
        html += '<tr style="border-bottom:1px solid #334155;">';
        html += '<td style="padding:6px 8px;font-family:monospace;">' + N.toLocaleString() + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;">' + pred.toFixed(2) + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;">' + (exact !== null ? exact : '-') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;color:' + errColor + '">' + (relError !== null ? relError.toFixed(4) + '%' : '-') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;color:#f59e0b;">' + (primes !== null ? primes : '-') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;color:#6366f1;">' + (composites !== null ? composites : '-') + '</td>';
        html += '<td style="padding:6px 8px;text-align:right;font-family:monospace;color:' + pcColor + '">' + (pcRatio !== null ? pcRatio.toFixed(6) : '-') + '</td>';
        html += '</tr>';
    });
    
    html += '</tbody></table>';
    
    // Add theoretical notes
    html += '<div style="margin-top:15px;padding:12px;background:#1e293b;border-radius:6px;font-size:11px;">';
    html += '<h5 style="color:#a5b4fc;margin:0 0 8px 0;">Theoretical Notes</h5>';
    html += '<p style="color:#94a3b8;margin:4px 0;"><strong>Error Convergence:</strong> Relative error ‚Üí 0 as N ‚Üí ‚àû (formula becomes exact asymptotically)</p>';
    html += '<p style="color:#94a3b8;margin:4px 0;"><strong>P/C Ratio Convergence:</strong> P/C ‚Üí 0 as N ‚Üí ‚àû (primes become sparse, density ~ 1/ln(N))</p>';
    html += '<p style="color:#94a3b8;margin:4px 0;"><strong>Rate:</strong> Error ‚àù O(N^Œµ) for small Œµ; P/C ‚àù O(1/ln(N))</p>';
    html += '</div>';
    html += '</div>';
    
    // Show in modal
    showModal('Convergence Analysis', html);
}

function showModal(title, content) {
    let modal = document.getElementById('convergenceModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'convergenceModal';
        modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';
        modal.innerHTML = `
            <div style="background:#0f172a;border:1px solid #6366f1;border-radius:12px;padding:20px;max-width:900px;width:90%;max-height:90vh;overflow:auto;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">
                    <h3 id="modalTitle" style="margin:0;color:#e2e8f0;"></h3>
                    <button onclick="document.getElementById('convergenceModal').style.display='none'" style="background:#ef4444;border:none;border-radius:4px;color:white;padding:6px 12px;cursor:pointer;">Close</button>
                </div>
                <div id="modalContent"></div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    document.getElementById('modalTitle').textContent = title;
    document.getElementById('modalContent').innerHTML = content;
    modal.style.display = 'flex';
}

function computeGaps() {
    state.gaps = [];
    for(let i=0; i<state.allResidues.length-1; i++) {
        const l = state.allResidues[i], r = state.allResidues[i+1];
        const gap = r.value - l.value;
        state.gaps.push({left:l, right:r, gap, theoretical:1/(l.m*r.m), denomProduct:l.m*r.m, sector:l.sector});
        state.allResidues[i].gapRight = gap;
    }
    state.gaps.sort((a,b) => b.gap - a.gap);
}

function cancelComputation() { state.computing = false; }

// Fast update for formula-only mode - skip heavy computations
function updateFormulaOnlyDisplays() {
    updateMainStats();
    updateMainChartsFormulaOnly();
    updateMainTable();
    // Skip: drawMainRing, drawSectorTree, drawTheoryViz, updateGapAnalysis, 
    // computeFranel, computeDedekind, updateCFDisplay, computePSL, 
    // computeEulerProduct, updateModularAnalysis, draw3D, drawHyperbolic, 
    // drawSmithChart, updateStatistics, updatePrimeAnalysis
    // These require actual residue data which formula mode doesn't compute
}

function updateMainChartsFormulaOnly() {
    const labels = state.sectors.map(s=>s.n);
    const hasBoundedData = state.sectors.some(s => s.boundedExact !== null);
    
    if(state.charts.mainCount) state.charts.mainCount.destroy();
    
    const datasets = [{
        label:'Predicted (Formula N=' + state.nMax + ')',
        data:state.sectors.map(s=>s.predicted),
        borderColor:'#22c55e',
        backgroundColor:'rgba(34,197,94,0.1)',
        fill:true
    }];
    
    // Add bounded data if available
    if (hasBoundedData) {
        datasets.unshift({
            label: 'Bounded Exact (N‚â§' + state.boundedN + ')',
            data: state.sectors.map(s => s.boundedExact),
            borderColor: '#6366f1',
            backgroundColor: 'rgba(99,102,241,0.1)',
            fill: false,
            borderDash: [5, 5]
        });
        datasets.push({
            label: 'Bounded Predicted (N=' + state.boundedN + ')',
            data: state.sectors.map(s => s.boundedPredicted),
            borderColor: '#f59e0b',
            backgroundColor: 'transparent',
            fill: false,
            borderDash: [2, 2]
        });
    }
    
    state.charts.mainCount = new Chart(document.getElementById('mainCountChart'),{
        type:'line',
        data:{
            labels,
            datasets
        },
        options:{
            responsive:true,
            plugins:{
                legend:{labels:{color:'#94a3b8'}},
                title:{display:true, text: hasBoundedData ? 'Formula + Bounded Window Data' : 'Formula Predictions Only (No Exact Data)', color: hasBoundedData ? '#22c55e' : '#f59e0b'}
            },
            scales:{
                x:{ticks:{color:'#94a3b8'}},
                y:{ticks:{color:'#94a3b8'}}
            }
        }
    });
    
    // Show bounded error chart if available
    if(state.charts.mainError) state.charts.mainError.destroy();
    
    if (hasBoundedData) {
        state.charts.mainError = new Chart(document.getElementById('mainErrorChart'),{
            type:'bar',
            data:{
                labels,
                datasets:[{
                    label:'Bounded Rel Err% (N‚â§' + state.boundedN + ')',
                    data:state.sectors.map(s=>s.boundedRelError),
                    backgroundColor: state.sectors.map((s, i) => 
                        errorChartSelection.start !== null && i >= errorChartSelection.start && i <= errorChartSelection.end 
                            ? 'rgba(34,197,94,0.9)' 
                            : 'rgba(245,158,11,0.7)'
                    )
                }]
            },
            options:{
                responsive:true,
                plugins:{
                    legend:{display:false},
                    title:{display:true, text:'Bounded Window Error (N‚â§' + state.boundedN + ')', color:'#a5b4fc'}
                },
                scales:{
                    x:{
                        ticks:{
                            color:'#94a3b8',
                            maxRotation: 45,
                            autoSkip: true,
                            maxTicksLimit: 30
                        },
                        title: {display: true, text: 'Sector n', color: '#64748b'}
                    },
                    y:{ticks:{color:'#94a3b8'}}
                },
                onClick: (evt, elements) => {
                    if (elements && elements.length > 0) {
                        playErrorChartBar(elements[0].index);
                    }
                }
            }
        });
        
        // Setup selection handlers
        setupErrorChartSelection();
    } else {
        const ctx = document.getElementById('mainErrorChart').getContext('2d');
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('No error data in Formula mode', ctx.canvas.width/2, ctx.canvas.height/2 - 10);
        ctx.fillText('(Enable "Compute bounded window" for P/C data)', ctx.canvas.width/2, ctx.canvas.height/2 + 15);
    }
}

function updateAllDisplays() {
    updateMainStats(); updateMainCharts(); updateMainTable(); drawMainRing(); drawSectorTree();
    drawTheoryViz();
    updateGapAnalysis(); computeFranel(); computeDedekind(); updateCFDisplay();
    computePSL(); computeEulerProduct(); updateModularAnalysis(); draw3D();
    drawHyperbolic(); drawSmithChart(); updateStatistics(); updatePrimeAnalysis();
}

// THEORY VIZ FUNCTIONS
function phi(n) { let r=0; for(let i=1; i<n; i++) if(gcd(i,n)===1) r++; return r; }

function drawTheoryViz() {
    drawSectorPartition();
    drawDensityCone();
    drawTotientSum();
    drawLatticeViz();
    drawProofSteps();
    drawConvergenceAnalysis();
    drawDensityHeatmap();
}

function drawSectorPartition() {
    const canvas = document.getElementById('sectorPartitionCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxSectors = +(document.getElementById('tvMaxSectors')?.value || 8);
    const showValues = document.getElementById('tvShowSectorValues')?.checked ?? true;
    const showWidths = document.getElementById('tvShowSectorWidths')?.checked ?? false;
    const style = document.getElementById('tvPartitionStyle')?.value || 'bar';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 50, barH = 40;
    const centerY = H/2;
    
    let legendHtml = '';
    
    if (style === 'arc') {
        // Arc/pie style
        const cx = W/2, cy = H/2, radius = Math.min(W,H)/2 - 60;
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, 2*Math.PI); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const a1 = left * 2 * Math.PI - Math.PI/2;
            const a2 = right * 2 * Math.PI - Math.PI/2;
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, a1, a2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.stroke();
            
            if (showValues && n <= 6) {
                const midAngle = (a1 + a2) / 2;
                const labelR = radius * 0.7;
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 11px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`S${n}`, cx + Math.cos(midAngle)*labelR, cy + Math.sin(midAngle)*labelR + 4);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else if (style === 'number') {
        // Number line style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        // Tick marks
        for (let i = 0; i <= 10; i++) {
            const x = margin + (i/10) * (W - 2*margin);
            ctx.beginPath(); ctx.moveTo(x, centerY - 10); ctx.lineTo(x, centerY + 10); ctx.stroke();
            ctx.fillStyle = '#94a3b8'; ctx.font = '10px system-ui'; ctx.textAlign = 'center';
            ctx.fillText((i/10).toFixed(1), x, centerY + 25);
        }
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color;
            ctx.fillRect(x1, centerY - 5, x2 - x1, 10);
            
            if (showValues && x2-x1 > 20) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.fillText(`S${n}`, (x1+x2)/2, centerY - 15);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else {
        // Default bar style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.fillRect(x1, centerY - barH, x2 - x1, barH * 2);
            ctx.strokeStyle = color; ctx.lineWidth = 1;
            ctx.strokeRect(x1, centerY - barH, x2 - x1, barH * 2);
            
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 11px system-ui';
            ctx.textAlign = 'center';
            if(x2-x1 > 25) ctx.fillText(`S${n}`, (x1+x2)/2, centerY + 4);
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px system-ui';
            ctx.fillText(`1/${n+1}`, x1, centerY + barH + 18);
            
            if (showWidths && x2-x1 > 30) {
                const width = 1/(n*(n+1));
                ctx.fillStyle = '#64748b';
                ctx.font = '8px system-ui';
                ctx.fillText(`w=${width.toFixed(3)}`, (x1+x2)/2, centerY + barH + 35);
            }
            
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}=(1/${n+1},1/${n}]</div>`;
        }
        
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('0', margin - 12, centerY + barH + 18);
        ctx.textAlign = 'right';
        ctx.fillText('1', W - margin + 12, centerY + barH + 18);
    }
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sectors Partition (0,1]', W/2, 25);
    
    document.getElementById('sectorPartitionLegend').innerHTML = legendHtml;
}

function drawDensityCone() {
    const canvas = document.getElementById('densityConeCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const numSectors = +(document.getElementById('tvConeSectors')?.value || 4);
    const showRef = document.getElementById('tvShowConeRef')?.checked ?? true;
    const logScale = document.getElementById('tvLogScale')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:55, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    const maxY = formula(1, maxN);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY * i / 4), margin.l - 5, y + 3);
    }
    
    let legendHtml = '';
    for (let n = 1; n <= numSectors; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let N = 10; N <= maxN; N += 3) {
            const C = formula(n, N);
            const x = margin.l + (N / maxN) * plotW;
            const yVal = logScale ? Math.log(C + 1) / Math.log(maxY + 1) : C / maxY;
            const y = margin.t + plotH - yVal * plotH;
            N === 10 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.font = '10px system-ui';
        const labelY = margin.t + plotH - (formula(n, maxN) / maxY) * plotH;
        ctx.fillText(`n=${n}`, W - margin.r - 30, Math.max(margin.t + 15, labelY + 4));
        
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    if (showRef) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        const refY = margin.t + plotH * 0.4;
        ctx.moveTo(margin.l, refY);
        ctx.lineTo(W - margin.r, refY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.fillText('6/œÄ¬≤ ref', W - margin.r - 35, refY - 5);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/œÄ¬≤</div>`;
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N ‚Üí', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('C(n,N) ‚Üí', 0, 0);
    ctx.restore();
    
    document.getElementById('densityConeLegend').innerHTML = legendHtml;
}

function drawTotientSum() {
    const canvas = document.getElementById('totientSumCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const showActual = document.getElementById('tvShowTotientActual')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowTotientPredicted')?.checked ?? true;
    const showError = document.getElementById('tvShowTotientError')?.checked ?? false;
    const fill = document.getElementById('tvTotientFill')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:65, r:20, t:20, b:40};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumPhi = 0;
    const data = [];
    for (let b = 1; b <= maxN; b++) {
        cumPhi += phi(b);
        data.push({b, cumPhi, predicted: 3*b*b/(Math.PI*Math.PI)});
    }
    
    const maxY = data[data.length-1].cumPhi;
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY*i/4), margin.l - 5, y+3);
    }
    
    if (showActual) {
        if (fill) {
            ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
            ctx.beginPath();
            ctx.moveTo(margin.l, margin.t + plotH);
            data.forEach((d, i) => {
                const x = margin.l + (d.b / maxN) * plotW;
                const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
                ctx.lineTo(x, y);
            });
            ctx.lineTo(margin.l + plotW, margin.t + plotH);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    if (showError) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const maxErr = Math.max(...data.map(d => Math.abs(d.cumPhi - d.predicted)));
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const err = Math.abs(d.cumPhi - d.predicted) / maxErr;
            const y = margin.t + plotH - err * plotH * 0.3;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('b ‚Üí', W/2, H - 10);
}

function drawLatticeViz() {
    const canvas = document.getElementById('latticeVizCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const highlightSector = +(document.getElementById('tvHighlightSector')?.value || 2);
    const showHidden = document.getElementById('tvShowHidden')?.checked ?? true;
    const showSectorLines = document.getElementById('tvShowSectorLines')?.checked ?? true;
    const colorBySector = document.getElementById('tvColorBySector')?.checked ?? false;
    const pointSize = +(document.getElementById('tvPointSize')?.value || 4);
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 45;
    const scale = (Math.min(W, H) - 2*margin) / maxB;
    
    // Draw sector boundary lines first
    if (showSectorLines) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        
        // Lines for highlighted sector boundaries
        const leftSlope = 1/(highlightSector+1);
        const rightSlope = 1/highlightSector;
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * leftSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * rightSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    for (let b = 1; b <= maxB; b++) {
        for (let a = 1; a <= b; a++) {
            const x = margin + a * scale;
            const y = H - margin - b * scale;
            
            const visible = gcd(a, b) === 1;
            
            if (!visible && !showHidden) continue;
            
            let color;
            if (!visible) {
                color = '#334155';
            } else if (colorBySector) {
                const sector = getSector(a, b);
                color = sector ? getSectorColor(sector) : '#6366f1';
            } else {
                color = '#6366f1';
            }
            
            // Highlight points in selected sector
            const inSector = visible && a/b > 1/(highlightSector+1) && a/b <= 1/highlightSector;
            
            ctx.fillStyle = inSector ? '#22c55e' : color;
            ctx.beginPath();
            ctx.arc(x, y, visible ? pointSize : pointSize/2, 0, 2*Math.PI);
            ctx.fill();
        }
    }
    
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, H - margin);
    ctx.lineTo(W - margin, H - margin);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('a ‚Üí', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('b ‚Üí', 0, 0);
    ctx.restore();
    
    // Sector label
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector ${highlightSector} highlighted`, W/2, 20);
}

function drawProofSteps() {
    const canvas = document.getElementById('proofStepsCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const n = +(document.getElementById('tvProofSector')?.value || 2);
    const maxB = +(document.getElementById('tvMaxN')?.value || 100);
    const showContrib = document.getElementById('tvShowContribBars')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowProofPredicted')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumCount = 0;
    const data = [];
    for (let b = 2; b <= maxB; b++) {
        const sectorRes = (state.residuesBySector[n]||[]).filter(r => r.m === b).length;
        const contrib = sectorRes > 0 ? sectorRes : Math.round(phi(b) / (n * (n+1)));
        cumCount += contrib;
        data.push({b, cumCount, predicted: formula(n, b), contrib});
    }
    
    const maxY = Math.max(data[data.length-1].cumCount, data[data.length-1].predicted);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
    }
    
    if (showContrib) {
        ctx.fillStyle = '#f59e0b30';
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const h = (d.contrib / maxY) * plotH * 3;
            ctx.fillRect(x - 2, margin.t + plotH - h, 4, h);
        });
    }
    
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (d.b / maxB) * plotW;
        const y = margin.t + plotH - (d.cumCount / maxY) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Denominator b ‚Üí', W/2, H - 10);
    
    ctx.fillStyle = '#8b5cf6';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector n=${n}`, W/2, 18);
}

function drawConvergenceAnalysis() {
    const canvas = document.getElementById('convergenceCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const analysisType = document.getElementById('tvConvergenceType')?.value || 'relative';
    const showTrend = document.getElementById('tvShowConvergenceTrend')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:30, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate convergence data for multiple N values
    const data = [];
    for (let N = 20; N <= 200; N += 10) {
        const sectorData = [];
        for (let n = 1; n <= 5; n++) {
            // Simulate exact count based on formula with random error
            const predicted = formula(n, N);
            const exactEstimate = predicted + (Math.random() - 0.5) * Math.sqrt(N) * 2;
            
            let value;
            if (analysisType === 'relative') {
                value = ((exactEstimate - predicted) / predicted) * 100;
            } else if (analysisType === 'absolute') {
                value = exactEstimate - predicted;
            } else {
                value = exactEstimate / predicted;
            }
            sectorData.push({n, value});
        }
        data.push({N, sectors: sectorData});
    }
    
    // Find y-axis range
    let minY = Infinity, maxY = -Infinity;
    data.forEach(d => {
        d.sectors.forEach(s => {
            if (s.value < minY) minY = s.value;
            if (s.value > maxY) maxY = s.value;
        });
    });
    const yRange = maxY - minY || 1;
    
    // Grid
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        const label = minY + (i/4) * yRange;
        ctx.fillText(label.toFixed(analysisType === 'ratio' ? 2 : 1), margin.l - 5, y + 3);
    }
    
    // Draw lines for each sector
    let legendHtml = '';
    for (let n = 1; n <= 5; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        data.forEach((d, i) => {
            const sectorData = d.sectors.find(s => s.n === n);
            if (sectorData) {
                const x = margin.l + (i / (data.length - 1)) * plotW;
                const y = margin.t + plotH - ((sectorData.value - minY) / yRange) * plotH;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    // Trend line (zero for relative/absolute, 1 for ratio)
    if (showTrend) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        const targetY = analysisType === 'ratio' ? 1 : 0;
        const y = margin.t + plotH - ((targetY - minY) / yRange) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.setLineDash([]);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Target</div>`;
    }
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N ‚Üí', W/2, H - 10);
    
    const titles = {relative: 'Relative Error %', absolute: 'Absolute Error', ratio: 'Actual / Predicted'};
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(titles[analysisType], W/2, 18);
    
    document.getElementById('convergenceLegend').innerHTML = legendHtml;
}

function drawDensityHeatmap() {
    const canvas = document.getElementById('densityHeatmapCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const nMin = +(document.getElementById('tvHeatmapNMin')?.value || 20);
    const nMax = +(document.getElementById('tvHeatmapNMax')?.value || 150);
    const numSectors = +(document.getElementById('tvHeatmapSectors')?.value || 10);
    const colorScheme = document.getElementById('tvHeatmapColor')?.value || 'viridis';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:80, t:30, b:50};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate heatmap data
    const nSteps = 20;
    const nStep = (nMax - nMin) / nSteps;
    
    let minVal = Infinity, maxVal = -Infinity;
    const heatData = [];
    
    for (let i = 0; i <= nSteps; i++) {
        const N = nMin + i * nStep;
        const row = [];
        for (let n = 1; n <= numSectors; n++) {
            const val = formula(n, N);
            row.push(val);
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
        }
        heatData.push({N, values: row});
    }
    
    // Color functions
    function getColor(t, scheme) {
        if (scheme === 'viridis') {
            const r = Math.round(68 + t * (253 - 68));
            const g = Math.round(1 + t * (231 - 1));
            const b = Math.round(84 + t * (37 - 84));
            return `rgb(${r},${g},${b})`;
        } else if (scheme === 'plasma') {
            const r = Math.round(13 + t * (240 - 13));
            const g = Math.round(8 + t * (249 - 8));
            const b = Math.round(135 + t * (33 - 135));
            return `rgb(${r},${g},${b})`;
        } else {
            // Cool-warm
            if (t < 0.5) {
                const r = Math.round(59 + t * 2 * (255 - 59));
                const g = Math.round(76 + t * 2 * (255 - 76));
                const b = Math.round(192 - t * 2 * (192 - 255));
                return `rgb(${r},${g},${b})`;
            } else {
                const r = 255;
                const g = Math.round(255 - (t - 0.5) * 2 * (255 - 59));
                const b = Math.round(255 - (t - 0.5) * 2 * (255 - 76));
                return `rgb(${r},${g},${b})`;
            }
        }
    }
    
    // Draw heatmap cells
    const cellW = plotW / numSectors;
    const cellH = plotH / (nSteps + 1);
    
    heatData.forEach((row, i) => {
        row.values.forEach((val, j) => {
            const t = (val - minVal) / (maxVal - minVal);
            ctx.fillStyle = getColor(t, colorScheme);
            ctx.fillRect(margin.l + j * cellW, margin.t + i * cellH, cellW - 1, cellH - 1);
        });
    });
    
    // X-axis labels (sectors)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    for (let n = 1; n <= numSectors; n++) {
        ctx.fillText(`S${n}`, margin.l + (n - 0.5) * cellW, H - margin.b + 20);
    }
    ctx.fillText('Sector n', margin.l + plotW/2, H - 10);
    
    // Y-axis labels (N values)
    ctx.textAlign = 'right';
    for (let i = 0; i <= nSteps; i += 4) {
        const N = Math.round(nMin + i * nStep);
        ctx.fillText(N, margin.l - 5, margin.t + i * cellH + cellH/2 + 3);
    }
    ctx.save();
    ctx.translate(15, margin.t + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.fillText('N ‚Üí', 0, 0);
    ctx.restore();
    
    // Color bar
    const barW = 20, barH = plotH;
    const barX = W - margin.r + 20;
    for (let i = 0; i < barH; i++) {
        const t = 1 - i / barH;
        ctx.fillStyle = getColor(t, colorScheme);
        ctx.fillRect(barX, margin.t + i, barW, 1);
    }
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(barX, margin.t, barW, barH);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(fmt(maxVal), barX + barW + 5, margin.t + 10);
    ctx.fillText(fmt(minVal), barX + barW + 5, margin.t + barH);
    ctx.fillText('C(n,N)', barX + barW + 5, margin.t + barH/2);
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Sector Density Heatmap (N: ${nMin}-${nMax})`, W/2, 18);
}

let theoryAnimationId = null;
function animateTheoryViz() {
    if (theoryAnimationId) {
        cancelAnimationFrame(theoryAnimationId);
        theoryAnimationId = null;
        return;
    }
    
    let currentN = 20;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const originalN = document.getElementById('tvMaxN').value;
    
    function step() {
        document.getElementById('tvMaxN').value = currentN;
        drawTheoryViz();
        
        currentN += 5;
        if (currentN <= maxN) {
            theoryAnimationId = requestAnimationFrame(() => setTimeout(step, 100));
        } else {
            document.getElementById('tvMaxN').value = originalN;
            theoryAnimationId = null;
        }
    }
    step();
}

function updateMainStats() {
    const hasExact = state.sectors.some(s=>s.exact!==null);
    const hasBounded = state.sectors.some(s=>s.boundedExact!==null);
    const total = hasExact ? state.sectors.reduce((s,x)=>s+(x.exact||0),0) : null;
    const totalBounded = hasBounded ? state.sectors.reduce((s,x)=>s+(x.boundedExact||0),0) : null;
    const totalPred = state.sectors.reduce((s,x)=>s+x.predicted,0);
    const modeLabel = state.mode === 'formula' ? '<div class="stat-card" style="border-color:#f59e0b;"><div class="stat-value" style="color:#f59e0b;">Formula</div><div class="stat-label">Mode (instant)</div></div>' : '';
    const boundedLabel = hasBounded && !hasExact ? `<div class="stat-card" style="border-color:#a5b4fc;"><div class="stat-value" style="color:#a5b4fc;">${fmt(totalBounded)}</div><div class="stat-label">Bounded (N‚â§${state.boundedN})</div></div>` : '';
    document.getElementById('mainStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${fmt(state.nMax)}</div><div class="stat-label">N</div></div>
        <div class="stat-card"><div class="stat-value">${state.sectorMax}</div><div class="stat-label">Sectors</div></div>
        ${hasExact?`<div class="stat-card"><div class="stat-value">${fmt(total)}</div><div class="stat-label">Exact</div></div>`:''}
        ${boundedLabel}
        <div class="stat-card"><div class="stat-value">${fmt(totalPred)}</div><div class="stat-label">Predicted</div></div>
        <div class="stat-card"><div class="stat-value">${(6/Math.PI/Math.PI).toFixed(4)}</div><div class="stat-label">6/œÄ¬≤</div></div>
        ${modeLabel}
    `;
    
    // Update formula display with computed values
    updateFormulaDisplay();
}

function updateFormulaDisplay() {
    const formulaComputed = document.getElementById('formulaComputed');
    if (!formulaComputed) return;
    
    const N = state.nMax;
    const n = document.getElementById('viewSector')?.value || 1;
    let nVal = parseInt(n) || 1;
    if (nVal < 1) nVal = 1; // Prevent division by zero
    
    // Calculate the formula result for current sector
    const N2 = N * N;
    const pi2 = Math.PI * Math.PI;
    const denominator = nVal * (nVal + 1);
    const result = (3 * N2) / (pi2 * denominator);
    
    // Show computed values
    formulaComputed.innerHTML = `<span style="color:#94a3b8;">For n=${nVal}, N=${N.toLocaleString()}:</span> ` +
        `C(${nVal}, ${N.toLocaleString()}) = 3√ó${N.toLocaleString()}¬≤ / (œÄ¬≤√ó${nVal}√ó${nVal+1}) = ` +
        `<span style="color:#22c55e;font-weight:bold;">${result.toFixed(4)}</span>`;
    formulaComputed.style.display = 'block';
}

function updateMainCharts() {
    const labels = state.sectors.map(s=>s.n);
    const hasExact = state.sectors.some(s=>s.exact!==null);
    
    if(state.charts.mainCount) state.charts.mainCount.destroy();
    const ds = [{label:'Predicted',data:state.sectors.map(s=>s.predicted),borderColor:'#22c55e',borderDash:[5,5],fill:false}];
    if(hasExact) ds.unshift({label:'Exact',data:state.sectors.map(s=>s.exact),borderColor:'#6366f1',backgroundColor:'rgba(99,102,241,0.1)',fill:true});
    state.charts.mainCount = new Chart(document.getElementById('mainCountChart'),{type:'line',data:{labels,datasets:ds},options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.mainError) state.charts.mainError.destroy();
    if(hasExact) {
        state.charts.mainError = new Chart(document.getElementById('mainErrorChart'),{
            type:'bar',
            data:{
                labels,
                datasets:[{
                    label:'Rel Err%',
                    data:state.sectors.map(s=>s.relError),
                    backgroundColor: state.sectors.map((s, i) => 
                        errorChartSelection.start !== null && i >= errorChartSelection.start && i <= errorChartSelection.end 
                            ? 'rgba(34,197,94,0.9)' 
                            : 'rgba(245,158,11,0.7)'
                    )
                }]
            },
            options:{
                responsive:true,
                plugins:{legend:{display:false}},
                scales:{
                    x:{
                        ticks:{
                            color:'#94a3b8',
                            maxRotation: 45,
                            autoSkip: true,
                            maxTicksLimit: 30
                        },
                        title: {display: true, text: 'Sector n', color: '#64748b'}
                    },
                    y:{ticks:{color:'#94a3b8'}}
                },
                onClick: (evt, elements) => {
                    if (elements.length > 0) {
                        const idx = elements[0].index;
                        playErrorChartBar(idx);
                    }
                }
            }
        });
        
        // Add drag selection for region
        setupErrorChartSelection();
    }
}

function updateMainTable() {
    const tbody = document.querySelector('#mainTable tbody');
    const theadRow = document.getElementById('mainTableHeader');
    const sectorSelect = document.getElementById('sectorDataSelect');
    const showCategories = document.getElementById('showCategoryColumns')?.checked || false;
    const categoryLegend = document.getElementById('categoryLegend');
    
    // Show/hide legend
    if (categoryLegend) categoryLegend.style.display = showCategories ? 'block' : 'none';
    
    // Update header based on category toggle
    if (theadRow) {
        if (showCategories) {
            theadRow.innerHTML = '<th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th>' +
                '<th title="P(m) = Prime denominator count (m is prime: 2,3,5,7,...)" style="color:#f59e0b;">P(m)</th>' +
                '<th title="C(m) = Composite denominator count (m is composite: 4,6,8,9,...)" style="color:#6366f1;">C(m)</th>' +
                '<th title="P/C = P(m)/C(m) ratio">P/C</th>' +
                '<th title="P(r) = Prime numerator count (r is prime)" style="color:#a5b4fc;">P(r)</th>' +
                '<th title="PP = Both prime (r prime AND m prime)" style="color:#22c55e;">PP</th>' +
                '<th title="PC = Prime numerator, Composite denominator" style="color:#f59e0b;">PC</th>' +
                '<th title="CP = Composite numerator, Prime denominator" style="color:#6366f1;">CP</th>' +
                '<th title="CC = Both composite (r composite AND m composite)" style="color:#94a3b8;">CC</th>';
        } else {
            theadRow.innerHTML = '<th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th>' +
                '<th title="P(m) = Prime denominator count (m is prime: 2,3,5,7,...)">P(m)</th>' +
                '<th title="C(m) = Composite denominator count (m is composite: 4,6,8,9,...)">C(m)</th>' +
                '<th title="P/C = P(m)/C(m) ratio">P/C</th>';
        }
    }
    
    let html = '';
    let optionsHtml = '<option value="">-- Select Sector --</option>';
    
    // Check if we're in formula/large N mode and have bounded data
    const usesBoundedData = state.nMax > 1500 || state.mode === 'formula';
    const hasBoundedData = Object.keys(state.boundedResiduesBySector).length > 0;
    
    state.sectors.forEach((s, idx) => {
        // Use actual residues if available, otherwise use bounded data
        let res = state.residuesBySector[s.n] || [];
        let primeCount, compositeCount, primeNumCount, ppCount, pcCount, cpCount, ccCount;
        let dataSource = '';
        
        if (res.length > 0) {
            // We have exact data for this sector
            primeCount = res.filter(r => r.isPrime).length;
            compositeCount = res.length - primeCount;
            primeNumCount = s.primeNumCount || res.filter(r => r.isPrimeNum).length;
            ppCount = s.ppCount || res.filter(r => r.category === 'PP').length;
            pcCount = s.pcCount || res.filter(r => r.category === 'PC').length;
            cpCount = s.cpCount || res.filter(r => r.category === 'CP').length;
            ccCount = s.ccCount || res.filter(r => r.category === 'CC').length;
        } else if (hasBoundedData && state.boundedResiduesBySector[s.n]) {
            // Use bounded window data
            res = state.boundedResiduesBySector[s.n];
            primeCount = s.boundedPrimeCount || res.filter(r => r.isPrime).length;
            compositeCount = s.boundedCompositeCount || (res.length - primeCount);
            primeNumCount = s.boundedPrimeNumCount || res.filter(r => r.isPrimeNum).length;
            ppCount = s.boundedPP || res.filter(r => r.category === 'PP').length;
            pcCount = s.boundedPC || res.filter(r => r.category === 'PC').length;
            cpCount = s.boundedCP || res.filter(r => r.category === 'CP').length;
            ccCount = s.boundedCC || res.filter(r => r.category === 'CC').length;
            dataSource = '*';
        } else {
            primeCount = 0;
            compositeCount = 0;
            primeNumCount = 0;
            ppCount = 0; pcCount = 0; cpCount = 0; ccCount = 0;
        }
        
        const errColor = s.relError !== null && Math.abs(s.relError) > 10 ? '#f87171' : '#4ade80';
        
        // Calculate P/C ratio (use bounded if available)
        let pcRatio = '-';
        let pcColor = '#94a3b8';
        if (s.boundedPCRatio !== undefined && s.boundedPCRatio !== null) {
            pcRatio = s.boundedPCRatio.toFixed(6);
            pcColor = s.boundedPCRatio > 1 ? '#f59e0b' : s.boundedPCRatio < 1 ? '#6366f1' : '#22c55e';
        } else if (compositeCount > 0) {
            const ratio = primeCount / compositeCount;
            pcRatio = ratio.toFixed(6);
            pcColor = ratio > 1 ? '#f59e0b' : ratio < 1 ? '#6366f1' : '#22c55e';
        } else if (primeCount > 0) {
            pcRatio = '‚àû';
            pcColor = '#f59e0b';
        }
        
        // Format predicted with more precision
        const predStr = s.predicted !== null ? s.predicted.toFixed(10) : '-';
        
        // Show bounded error if available, otherwise regular error
        let errStr = '-';
        let errValue = null;
        if (s.relError !== null) {
            errStr = s.relError.toFixed(6) + '%';
            errValue = s.relError;
        } else if (s.boundedRelError !== null) {
            errStr = s.boundedRelError.toFixed(6) + '%*';
            errValue = s.boundedRelError;
        }
        const displayErrColor = errValue !== null && Math.abs(errValue) > 10 ? '#f87171' : '#4ade80';
        
        // Show exact count or bounded exact
        let exactDisplay = '-';
        if (s.exact !== null) {
            exactDisplay = s.exact;
        } else if (s.boundedExact !== null) {
            exactDisplay = s.boundedExact + '*';
        }
        
        // Prime/composite display
        const primeDisplay = primeCount > 0 ? primeCount + dataSource : '-';
        const compositeDisplay = compositeCount > 0 ? compositeCount + dataSource : '-';
        const primeNumDisplay = primeNumCount > 0 ? primeNumCount + dataSource : '-';
        
        html += '<tr data-sector="' + s.n + '" data-idx="' + idx + '" onclick="showSectorDataDetail(' + s.n + ')" style="cursor:pointer" title="Click to see sector ' + s.n + ' details">' +
            '<td><strong>' + s.n + '</strong></td>' +
            '<td>(1/' + (s.n+1) + ', 1/' + s.n + ']</td>' +
            '<td>' + exactDisplay + '</td>' +
            '<td style="font-family:monospace;font-size:11px;">' + predStr + '</td>' +
            '<td style="color:' + displayErrColor + ';font-family:monospace;font-size:11px;">' + errStr + '</td>' +
            '<td style="color:#f59e0b;font-size:11px;">' + primeDisplay + '</td>' +
            '<td style="color:#6366f1;font-size:11px;">' + compositeDisplay + '</td>' +
            '<td style="color:' + pcColor + ';font-family:monospace;">' + pcRatio + '</td>';
        
        // Add category columns if enabled
        if (showCategories) {
            html += '<td style="color:#a5b4fc;font-size:11px;">' + primeNumDisplay + '</td>' +
                    '<td style="color:#22c55e;font-size:11px;">' + (ppCount > 0 ? ppCount + dataSource : '-') + '</td>' +
                    '<td style="color:#f59e0b;font-size:11px;">' + (pcCount > 0 ? pcCount + dataSource : '-') + '</td>' +
                    '<td style="color:#6366f1;font-size:11px;">' + (cpCount > 0 ? cpCount + dataSource : '-') + '</td>' +
                    '<td style="color:#94a3b8;font-size:11px;">' + (ccCount > 0 ? ccCount + dataSource : '-') + '</td>';
        }
        
        html += '</tr>';
        
        optionsHtml += '<option value="' + s.n + '">Sector ' + s.n + ' (' + (res.length || 'formula') + ' fractions)</option>';
    });
    
    // Add footnote if using bounded data
    const colSpan = showCategories ? 13 : 8;
    if (usesBoundedData && hasBoundedData) {
        html += '<tr style="background:#1e1b4b;"><td colspan="' + colSpan + '" style="font-size:10px;color:#a5b4fc;padding:8px;text-align:center;">* Data from bounded window N ‚â§ ' + state.boundedN + ' | P(m)=Prime denom, C(m)=Composite denom, P(r)=Prime num | PP=Both prime, PC=P num C denom, CP=C num P denom, CC=Both composite</td></tr>';
    }
    
    tbody.innerHTML = html;
    if (sectorSelect) sectorSelect.innerHTML = optionsHtml;
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = `Sector ${n}: (1/${n+1}, 1/${n}]`;
    
    let html = `
        <div class="stat-grid" style="margin-bottom:15px;">
            <div class="stat-card"><div class="stat-value">${res.length}</div><div class="stat-label">Total Pairs</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#f59e0b">${primes.length}</div><div class="stat-label">Prime Moduli</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#6366f1">${composites.length}</div><div class="stat-label">Composite Moduli</div></div>
            <div class="stat-card"><div class="stat-value">${sector ? fmt(sector.predicted) : '-'}</div><div class="stat-label">Predicted</div></div>
            <div class="stat-card"><div class="stat-value">${sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-'}</div><div class="stat-label">Error</div></div>
        </div>
        
        <h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (${primes.length})</h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #f59e0b30;">
            ${primes.length > 0 ? primes.map(p => `<span class="residue-item prime" title="m=${p.m} is prime">${p.r}/${p.m}</span>`).join('') : '<span style="color:#64748b">No prime moduli in this sector</span>'}
        </div>
        
        <h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (${composites.length}) <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #6366f130;">
            ${composites.length > 0 ? composites.slice(0,100).map(c => `<span class="residue-item">${c.r}/${c.m}</span>`).join('') : '<span style="color:#64748b">No composite moduli in this sector</span>'}
            ${composites.length > 100 ? `<span style="color:#64748b; display:block; margin-top:8px;">... and ${composites.length - 100} more</span>` : ''}
        </div>
        
        <div style="margin-top:15px; display:flex; gap:10px; flex-wrap:wrap;">
            <button onclick="playSectorAudio(${n}, 'forward')" style="background:linear-gradient(135deg,#22c55e,#16a34a);">‚ñ∂ Play All Forward</button>
            <button onclick="playSectorAudio(${n}, 'backward')" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);">‚óÄ Play All Backward</button>
            <button onclick="playSectorPrimes(${n})" style="background:linear-gradient(135deg,#f59e0b,#d97706);">‚ñ∂ Play Primes</button>
            <button onclick="stopAllPlayback()" style="background:#ef4444;">‚ñ† Stop</button>
            <button onclick="exportSectorData(${n})">Export Sector CSV</button>
            <button class="secondary" onclick="viewSectorOnRing(${n})">View on Ring</button>
        </div>
    `;
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += `${r.r},${r.m},${r.value},${r.isPrime}\n`;
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `sector_${n}_data.csv`;
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

// =============================================
// GLOBAL DISPLAY FORMAT SYSTEM
// =============================================

const globalFormat = {
    type: 'fraction',
    precision: 4
};

function updateGlobalDisplayFormat() {
    globalFormat.type = document.getElementById('globalDisplayFormat')?.value || 'fraction';
    globalFormat.precision = parseInt(document.getElementById('globalPrecision')?.value) || 4;
    
    // Update preview
    const preview = document.getElementById('globalFormatPreview');
    if (preview) {
        preview.textContent = '1/2 = ' + formatValueGlobal(1, 2);
    }
    
    // Refresh displays that use global format
    if (document.getElementById('sectorDetailPanel')?.style.display !== 'none') {
        const sectorSelect = document.getElementById('sectorDataSelect');
        if (sectorSelect?.value) showSectorDataDetail(sectorSelect.value);
    }
    if (typeof updateHorizonTree === 'function' && typeof horizonData !== 'undefined' && horizonData?.gatekeeper) {
        const n = parseInt(document.getElementById('horizonSectorN')?.value) || 5;
        updateHorizonTree(horizonData, n);
        updateHorizonFractionList(horizonData);
    }
}

function formatValueGlobal(r, m) {
    const value = r / m;
    const prec = globalFormat.precision;
    
    switch (globalFormat.type) {
        case 'fraction':
            return r + '/' + m;
        case 'decimal':
            return value.toFixed(prec);
        case 'degree':
            return (value * 360).toFixed(prec) + '¬∞';
        case 'radian':
            return (value * 2 * Math.PI).toFixed(prec) + ' rad';
        case 'pi':
            return (value * 2).toFixed(prec) + 'œÄ';
        default:
            return r + '/' + m;
    }
}

function formatFractionGlobal(f) {
    if (f.r !== undefined && f.m !== undefined) {
        return formatValueGlobal(f.r, f.m);
    } else if (f.p !== undefined && f.q !== undefined) {
        return formatValueGlobal(f.p, f.q);
    }
    return '?/?';
}

// =============================================
// SECTOR DATA DETAIL FUNCTIONS
// =============================================

function showSectorDataDetail(n) {
    if (!n) {
        document.getElementById('sectorDetailPanel').style.display = 'none';
        return;
    }
    
    n = parseInt(n);
    
    // Use actual residues if available, otherwise use bounded data
    let res = state.residuesBySector[n] || [];
    let dataSource = '';
    
    if (res.length === 0 && state.boundedResiduesBySector[n]) {
        res = state.boundedResiduesBySector[n];
        dataSource = ' (from bounded N‚â§' + state.boundedN + ')';
    }
    
    const primes = res.filter(r => r.isPrime);        // Prime denominator
    const composites = res.filter(r => !r.isPrime);   // Composite denominator
    const primeNums = res.filter(r => r.isPrimeNum);  // Prime numerator
    
    // Category counts
    const ppFracs = res.filter(r => r.category === 'PP');  // Both prime
    const pcFracs = res.filter(r => r.category === 'PC');  // Prime num, Comp denom
    const cpFracs = res.filter(r => r.category === 'CP');  // Comp num, Prime denom
    const ccFracs = res.filter(r => r.category === 'CC');  // Both composite
    
    // Update dropdown
    document.getElementById('sectorDataSelect').value = n;
    
    // Update title
    document.getElementById('sectorDetailTitle').textContent = 
        'Sector ' + n + ': (1/' + (n+1) + ', 1/' + n + '] ‚Äî ' + res.length + ' fractions' + dataSource;
    
    // Update counts
    document.getElementById('sectorPrimeCount').textContent = primes.length;
    document.getElementById('sectorCompositeCount').textContent = composites.length;
    
    // Update category stats
    document.getElementById('statPrimeM').textContent = primes.length;
    document.getElementById('statCompM').textContent = composites.length;
    document.getElementById('statPrimeR').textContent = primeNums.length;
    document.getElementById('statPP').textContent = ppFracs.length;
    document.getElementById('statPC').textContent = pcFracs.length;
    document.getElementById('statCP').textContent = cpFracs.length;
    document.getElementById('statCC').textContent = ccFracs.length;
    
    // Calculate and display P/C ratio
    const pcRatioEl = document.getElementById('sectorPCRatio');
    if (composites.length > 0) {
        const ratio = primes.length / composites.length;
        pcRatioEl.textContent = ratio.toFixed(10) + dataSource;
        pcRatioEl.style.color = ratio > 1 ? '#f59e0b' : ratio < 1 ? '#6366f1' : '#22c55e';
    } else if (primes.length > 0) {
        pcRatioEl.textContent = '‚àû (no composites)' + dataSource;
        pcRatioEl.style.color = '#f59e0b';
    } else {
        pcRatioEl.textContent = '0/0 (empty)';
        pcRatioEl.style.color = '#64748b';
    }
    
    // Helper to format fraction with category color
    function formatFracWithCategory(f) {
        const catColors = { 'PP': '#22c55e', 'PC': '#f59e0b', 'CP': '#6366f1', 'CC': '#94a3b8' };
        const bgColors = { 'PP': '#22c55e33', 'PC': '#f59e0b33', 'CP': '#6366f133', 'CC': '#94a3b833' };
        const color = catColors[f.category] || '#94a3b8';
        const bg = bgColors[f.category] || '#94a3b833';
        return '<span onclick="triggerGlobalHarmonic(' + f.r + ',' + f.m + ')" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:' + bg + ';border:1px solid ' + color + ';cursor:pointer;color:' + color + ';" title="' + (f.r/f.m).toFixed(10) + ' [' + f.category + ']">' + formatValueGlobal(f.r, f.m) + '</span>';
    }
    
    // Format and display primes (sorted by value, showing category)
    const primesHtml = primes.length > 0 
        ? primes.sort((a,b) => a.r/a.m - b.r/b.m).map(formatFracWithCategory).join('')
        : '<span style="color:#64748b">No prime denominators in this sector</span>';
    
    // Format and display composites (limit to 200)
    const compositesHtml = composites.length > 0 
        ? composites.sort((a,b) => a.r/a.m - b.r/b.m).slice(0, 200).map(formatFracWithCategory).join('') + 
          (composites.length > 200 ? '<br><span style="color:#64748b;margin-top:8px;display:block;">... and ' + (composites.length - 200) + ' more</span>' : '')
        : '<span style="color:#64748b">No composite denominators in this sector</span>';
    
    document.getElementById('sectorPrimesList').innerHTML = primesHtml;
    document.getElementById('sectorCompositesList').innerHTML = compositesHtml;
    
    // Show panel
    document.getElementById('sectorDetailPanel').style.display = 'block';
}

function closeSectorDetail() {
    document.getElementById('sectorDetailPanel').style.display = 'none';
    document.getElementById('sectorDataSelect').value = '';
}

function playSectorDetailFractions(type, direction) {
    const n = parseInt(document.getElementById('sectorDataSelect').value);
    if (!n) {
        showPlaybackStatus('Select a sector first');
        return;
    }
    
    // Use actual residues if available, otherwise use bounded data
    let res = state.residuesBySector[n] || [];
    if (res.length === 0 && state.boundedResiduesBySector[n]) {
        res = state.boundedResiduesBySector[n];
    }
    
    let fracs;
    let typeLabel = type;
    
    // Filter by type
    switch(type) {
        case 'primes':
            fracs = res.filter(r => r.isPrime);
            typeLabel = 'prime denominators';
            break;
        case 'composites':
            fracs = res.filter(r => !r.isPrime);
            typeLabel = 'composite denominators';
            break;
        case 'primeNums':
            fracs = res.filter(r => r.isPrimeNum);
            typeLabel = 'prime numerators';
            break;
        case 'PP':
            fracs = res.filter(r => r.category === 'PP');
            typeLabel = 'PP (both prime)';
            break;
        case 'PC':
            fracs = res.filter(r => r.category === 'PC');
            typeLabel = 'PC (prime num, comp denom)';
            break;
        case 'CP':
            fracs = res.filter(r => r.category === 'CP');
            typeLabel = 'CP (comp num, prime denom)';
            break;
        case 'CC':
            fracs = res.filter(r => r.category === 'CC');
            typeLabel = 'CC (both composite)';
            break;
        default:
            fracs = res;
            typeLabel = 'all';
    }
    
    if (fracs.length === 0) {
        showPlaybackStatus('No ' + typeLabel + ' fractions in sector ' + n);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value
    fracs = [...fracs].sort((a, b) => direction === 'forward' ? a.r/a.m - b.r/b.m : b.r/b.m - a.r/a.m);
    
    // Limit to 150 for performance
    const limited = fracs.slice(0, 150);
    
    playbackState.queue = limited.map(f => ({ r: f.r, m: f.m }));
    playbackState.direction = direction;
    playbackState.mode = 'sector-detail';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    const countInfo = limited.length < fracs.length ? limited.length + '/' + fracs.length : limited.length;
    showPlaybackStatus(`Playing ${typeLabel} from sector ${n} (${countInfo} fractions)`);
    startPlaybackLoop();
}

function exportSectorCSV(n) {
    if (!n) {
        alert('Please select a sector first');
        return;
    }
    n = parseInt(n);
    
    // Use actual residues if available, otherwise use bounded data
    let res = state.residuesBySector[n] || [];
    let dataSource = '';
    if (res.length === 0 && state.boundedResiduesBySector[n]) {
        res = state.boundedResiduesBySector[n];
        dataSource = ' (from bounded N‚â§' + state.boundedN + ')';
    }
    
    if (res.length === 0) {
        alert('No data for sector ' + n);
        return;
    }
    
    const primeCount = res.filter(r => r.isPrime).length;
    const compositeCount = res.filter(r => !r.isPrime).length;
    const primeNumCount = res.filter(r => r.isPrimeNum).length;
    const ppCount = res.filter(r => r.category === 'PP').length;
    const pcCount = res.filter(r => r.category === 'PC').length;
    const cpCount = res.filter(r => r.category === 'CP').length;
    const ccCount = res.filter(r => r.category === 'CC').length;
    const pcRatio = compositeCount > 0 ? (primeCount / compositeCount).toFixed(10) : (primeCount > 0 ? 'Infinity' : 'N/A');
    
    const prec = 10; // Use 10 decimal places
    let csv = 'Sector ' + n + ' Data Export' + dataSource + '\n';
    csv += 'Interval,(1/' + (n+1) + ', 1/' + n + ']\n';
    csv += 'Total Fractions,' + res.length + '\n';
    csv += 'Prime Denominators P(m),' + primeCount + '\n';
    csv += 'Composite Denominators C(m),' + compositeCount + '\n';
    csv += 'Prime Numerators P(r),' + primeNumCount + '\n';
    csv += 'P/C Ratio (denom),' + pcRatio + '\n';
    csv += 'PP (both prime),' + ppCount + '\n';
    csv += 'PC (prime num comp denom),' + pcCount + '\n';
    csv += 'CP (comp num prime denom),' + cpCount + '\n';
    csv += 'CC (both composite),' + ccCount + '\n\n';
    csv += 'Numerator,Denominator,Value,Degrees,Radians,Pi-Fraction,Denom Type,Num Type,Category,Frequency (Hz)\n';
    
    res.sort((a, b) => a.r/a.m - b.r/b.m).forEach(f => {
        const val = f.r / f.m;
        const freq = (harmonicSettings?.baseFreq || 440) * val;
        csv += f.r + ',' + f.m + ',' + val.toFixed(prec) + ',' + 
               (val * 360).toFixed(prec) + ',' + 
               (val * 2 * Math.PI).toFixed(prec) + ',' + 
               (val * 2).toFixed(prec) + 'œÄ,' +
               (f.isPrime ? 'Prime' : 'Composite') + ',' +
               (f.isPrimeNum ? 'Prime' : 'Composite') + ',' +
               (f.category || '-') + ',' +
               freq.toFixed(2) + '\n';
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sector_' + n + '_N' + state.nMax + '_data.csv';
    a.click();
}

function exportAllSectorsCSV() {
    if (state.sectors.length === 0) {
        alert('No data to export. Run computation first.');
        return;
    }
    
    const prec = 10; // Use 10 decimal places
    const hasBoundedData = Object.keys(state.boundedResiduesBySector).length > 0;
    
    let csv = 'All Sectors Data Export\n';
    csv += 'N Range,' + state.nMin + ' to ' + state.nMax + '\n';
    csv += 'Sectors,' + state.sectorMin + ' to ' + state.sectorMax + '\n';
    csv += 'Total Fractions,' + state.allResidues.length + '\n';
    if (hasBoundedData) {
        csv += 'Bounded Window N,' + state.boundedN + '\n';
    }
    csv += '\n';
    
    // Add sector summary with P/C ratios and categories
    csv += 'SECTOR SUMMARY\n';
    csv += 'Sector,Interval,Exact,Predicted,Error%,P(m),C(m),P/C Ratio,P(r),PP,PC,CP,CC\n';
    state.sectors.forEach(s => {
        // Use actual residues if available, otherwise use bounded data
        let res = state.residuesBySector[s.n] || [];
        if (res.length === 0 && state.boundedResiduesBySector[s.n]) {
            res = state.boundedResiduesBySector[s.n];
        }
        
        const primeCount = res.filter(r => r.isPrime).length;
        const compositeCount = res.length - primeCount;
        const primeNumCount = res.filter(r => r.isPrimeNum).length;
        const ppCount = res.filter(r => r.category === 'PP').length;
        const pcCount = res.filter(r => r.category === 'PC').length;
        const cpCount = res.filter(r => r.category === 'CP').length;
        const ccCount = res.filter(r => r.category === 'CC').length;
        const pcRatio = compositeCount > 0 ? (primeCount / compositeCount).toFixed(10) : (primeCount > 0 ? 'Infinity' : 'N/A');
        
        csv += s.n + ',' +
               '(1/' + (s.n+1) + ' - 1/' + s.n + '],' +
               (s.exact !== null ? s.exact : (s.boundedExact || '')) + ',' +
               (s.predicted !== null ? s.predicted.toFixed(10) : '') + ',' +
               (s.relError !== null ? s.relError.toFixed(6) : (s.boundedRelError ? s.boundedRelError.toFixed(6) : '')) + ',' +
               primeCount + ',' +
               compositeCount + ',' +
               pcRatio + ',' +
               primeNumCount + ',' +
               ppCount + ',' +
               pcCount + ',' +
               cpCount + ',' +
               ccCount + '\n';
    });
    
    csv += '\nFRACTION DETAILS\n';
    csv += 'Sector,Numerator,Denominator,Value,Degrees,Radians,Pi-Fraction,Denom Type,Num Type,Category,Frequency (Hz)\n';
    
    for (let s = state.sectorMin; s <= state.sectorMax; s++) {
        // Use actual residues if available, otherwise use bounded data
        let res = state.residuesBySector[s] || [];
        if (res.length === 0 && state.boundedResiduesBySector[s]) {
            res = state.boundedResiduesBySector[s];
        }
        
        res.sort((a, b) => a.r/a.m - b.r/b.m).forEach(f => {
            const val = f.r / f.m;
            const freq = (harmonicSettings?.baseFreq || 440) * val;
            csv += s + ',' + f.r + ',' + f.m + ',' + val.toFixed(prec) + ',' + 
                   (val * 360).toFixed(prec) + ',' + 
                   (val * 2 * Math.PI).toFixed(prec) + ',' + 
                   (val * 2).toFixed(prec) + 'œÄ,' +
                   (f.isPrime ? 'Prime' : 'Composite') + ',' +
                   (f.isPrimeNum ? 'Prime' : 'Composite') + ',' +
                   (f.category || '-') + ',' +
                   freq.toFixed(2) + '\n';
        });
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'all_sectors_N' + state.nMax + '_data.csv';
    a.click();
}

function drawMainRing() {
    const canvas = document.getElementById('mainRing'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-35;
    const sector = +document.getElementById('viewSector').value;
    const colorMode = document.getElementById('colorMode').value;
    const showAll = document.getElementById('showAllSectors').checked;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
    for(let n=1; n<=Math.min(15,state.sectorMax); n++) {
        const angle = (1/n)*2*Math.PI;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(angle)*maxR, cy-Math.sin(angle)*maxR); ctx.stroke();
        ctx.fillStyle='#64748b'; ctx.font='9px system-ui';
        ctx.fillText(`1/${n}`, cx+Math.cos(angle)*(maxR+12)-8, cy-Math.sin(angle)*(maxR+12));
    }
    
    if(!showAll) {
        const a1=(1/(sector+1))*2*Math.PI, a2=(1/sector)*2*Math.PI;
        ctx.fillStyle='rgba(99,102,241,0.1)'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,maxR,-a2,-a1); ctx.closePath(); ctx.fill();
    }
    
    state.ringPoints = [];
    let residues = showAll ? Object.values(state.residuesBySector).flat() : (state.residuesBySector[sector]||[]);
    
    let maxGap=0, minGap=Infinity;
    residues.forEach(r => { const g=r.gapRight||0; if(g>maxGap)maxGap=g; if(g>0&&g<minGap)minGap=g; });
    
    residues.forEach(res => {
        const {r,m,sector:s,isPrime:ip} = res;
        const angle = (r/m)*2*Math.PI, rad = (m/state.nMax)*maxR;
        const x = cx+rad*Math.cos(angle), y = cy-rad*Math.sin(angle);
        let color;
        switch(colorMode) {
            case 'sector': color = getSectorColor(s); break;
            case 'prime': color = ip?'#f59e0b':'#6366f1'; break;
            case 'denominator': color = `hsl(${260-(m/state.nMax)*200},70%,60%)`; break;
            case 'gap': const g=res.gapRight||minGap; const gn=maxGap>minGap?(g-minGap)/(maxGap-minGap):0.5; color=`hsl(${120-gn*120},80%,50%)`; break;
            default: color='#6366f1';
        }
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,colorMode==='prime'&&ip?3:2,0,2*Math.PI); ctx.fill();
        state.ringPoints.push({x,y,r,m,sector:s,isPrime:ip,gap:res.gapRight,color});
    });
    
    ctx.fillStyle='#e2e8f0'; ctx.beginPath(); ctx.arc(cx,cy,4,0,2*Math.PI); ctx.fill();
    updateColorLegend(colorMode, showAll, sector);
}

function updateColorLegend(colorMode, showAll, sector) {
    const legend = document.getElementById('colorLegend');
    let html = '';
    switch(colorMode) {
        case 'sector': if(showAll) { for(let s=1;s<=Math.min(10,state.sectorMax);s++) html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(s)}"></div>S${s}</div>`; } else html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(sector)}"></div>Sector ${sector}</div>`; break;
        case 'prime': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Composite</div>`; break;
        case 'denominator': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(260,70%,60%)"></div>Small m</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(60,70%,60%)"></div>Large m</div>`; break;
        case 'gap': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(120,80%,50%)"></div>Small</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,80%,50%)"></div>Large</div>`; break;
    }
    legend.innerHTML = html;
}

document.getElementById('mainRing').addEventListener('click', function(e) {
    const rect = this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=15;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    if(closest) {
        openPointModal(closest);
        selectPointForTree(closest);
        selectFractionForHarmonic(closest.r, closest.m);
    }
});

document.getElementById('mainRing').addEventListener('mousemove', function(e) {
    const rect=this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=12;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    const tooltip = document.getElementById('pointTooltip');
    if(closest) {
        tooltip.innerHTML = `<h5>${closest.r}/${closest.m}</h5><div class="row"><span class="label">Value:</span><span class="val">${(closest.r/closest.m).toFixed(6)}</span></div><div class="row"><span class="label">Sector:</span><span class="val">${closest.sector}</span></div><div class="row"><span class="label">Mod:</span><span class="val">${closest.m} (${closest.isPrime?'P':'C'})</span></div>`;
        tooltip.style.left = (e.clientX-rect.left+10)+'px'; tooltip.style.top = (e.clientY-rect.top-10)+'px';
        tooltip.classList.add('visible');
    } else tooltip.classList.remove('visible');
});

function openPointModal(p) {
    document.getElementById('pointModalTitle').textContent = `${p.r}/${p.m}`;
    const cf = toCF(p.r, p.m);
    document.getElementById('pointModalBody').innerHTML = `
        <div class="detail-grid">
            <div class="detail-card"><h5>Fraction</h5><div class="value">${p.r}/${p.m}</div><div class="sub">= ${(p.r/p.m).toFixed(8)}</div></div>
            <div class="detail-card"><h5>Sector</h5><div class="value">${p.sector}</div><div class="sub">(1/${p.sector+1}, 1/${p.sector}]</div></div>
            <div class="detail-card"><h5>Modulus</h5><div class="value" style="color:${p.isPrime?'#f59e0b':'#6366f1'}">${p.m}</div><div class="sub">${p.isPrime?'Prime':'Composite'}</div></div>
        </div>
        <div class="theorem-box"><strong>CF:</strong> [${cf.join('; ')}]<br><strong>Path:</strong> ${cfPath(cf)}</div>
        <div style="margin-top:12px;">
            <button onclick="closePointModal(); openSectorModal(${p.sector});">View All in Sector ${p.sector}</button>
        </div>
    `;
    document.getElementById('pointModal').classList.add('active');
}
function closePointModal() { document.getElementById('pointModal').classList.remove('active'); }
function openSectorModal(n) { document.getElementById('viewSector').value=n; document.getElementById('showAllSectors').checked=false; drawMainRing(); }

// SECTOR TREE VISUALIZATION
let selectedTreePoint = null;
let treeAnimationId = null;

function drawSectorTree() {
    const canvas = document.getElementById('sectorTreeCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const depth = +document.getElementById('treeDepth').value;
    const showLabels = document.getElementById('showTreeLabels').checked;
    const showGrid = document.getElementById('showTreeGrid').checked;
    const sectorFilter = document.getElementById('treeSectorFilter')?.value || 'all';
    const colorMode = document.getElementById('treeColorMode')?.value || 'default';
    const highlightOnly = document.getElementById('treeHighlightOnly')?.checked || false;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw grid if enabled
    if (showGrid) {
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        for (let i = 1; i < depth; i++) {
            const y = 40 + (i / depth) * (H - 80);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
    }
    
    // Draw sector boundary lines if filtering
    if (sectorFilter !== 'all') {
        const sectorNum = parseInt(sectorFilter);
        const leftBound = 1 / (sectorNum + 1);
        const rightBound = 1 / sectorNum;
        
        // Convert to x positions (fractions map to horizontal position)
        const leftX = leftBound * W;
        const rightX = rightBound * W;
        
        // Draw sector region highlight
        ctx.fillStyle = 'rgba(99, 102, 241, 0.1)';
        ctx.fillRect(leftX, 0, rightX - leftX, H);
        
        // Draw boundary lines
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(leftX, 0);
        ctx.lineTo(leftX, H);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(rightX, 0);
        ctx.lineTo(rightX, H);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Label boundaries
        ctx.fillStyle = '#a5b4fc';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`1/${sectorNum + 1}`, leftX, H - 5);
        ctx.fillText(`1/${sectorNum}`, rightX, H - 5);
    }
    
    // Build and draw Stern-Brocot tree
    const treeNodes = buildSternBrocotTree(depth);
    
    // Calculate sector for each node
    treeNodes.forEach(node => {
        node.sector = getSector(node.r, node.m);
        node.isPrime = isPrime(node.m);
    });
    
    // Draw edges first
    treeNodes.forEach(node => {
        if (node.parent) {
            const inSector = sectorFilter === 'all' || node.sector === parseInt(sectorFilter);
            const parentInSector = sectorFilter === 'all' || node.parent.sector === parseInt(sectorFilter);
            
            if (highlightOnly && sectorFilter !== 'all' && !inSector && !parentInSector) {
                ctx.strokeStyle = '#1e293b';
            } else if (inSector && sectorFilter !== 'all') {
                ctx.strokeStyle = getSectorColor(node.sector);
            } else {
                ctx.strokeStyle = '#334155';
            }
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(node.parent.x, node.parent.y);
            ctx.lineTo(node.x, node.y);
            ctx.stroke();
        }
    });
    
    // Draw nodes
    treeNodes.forEach(node => {
        const isOnPath = selectedTreePoint && isNodeOnPath(node, selectedTreePoint);
        const isTarget = selectedTreePoint && node.r === selectedTreePoint.r && node.m === selectedTreePoint.m;
        const inSector = sectorFilter === 'all' || node.sector === parseInt(sectorFilter);
        
        // Skip dim nodes if highlight only
        if (highlightOnly && sectorFilter !== 'all' && !inSector && !isOnPath && !isTarget) {
            ctx.fillStyle = '#1e293b';
            ctx.beginPath();
            ctx.arc(node.x, node.y, 2, 0, 2 * Math.PI);
            ctx.fill();
            return;
        }
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, isTarget ? 10 : (isOnPath ? 7 : (inSector && sectorFilter !== 'all' ? 6 : 5)), 0, 2 * Math.PI);
        
        if (isTarget) {
            ctx.fillStyle = '#22c55e';
        } else if (isOnPath) {
            ctx.fillStyle = '#f59e0b';
        } else {
            // Apply color mode
            switch (colorMode) {
                case 'sector':
                    ctx.fillStyle = getSectorColor(node.sector);
                    break;
                case 'prime':
                    ctx.fillStyle = node.isPrime ? '#f59e0b' : '#6366f1';
                    break;
                case 'arnold':
                    if (typeof getHarmonicMode === 'function') {
                        const mode = getHarmonicMode(node.m);
                        ctx.fillStyle = mode.color;
                    } else {
                        ctx.fillStyle = '#6366f1';
                    }
                    break;
                default:
                    if (sectorFilter !== 'all' && inSector) {
                        ctx.fillStyle = getSectorColor(node.sector);
                    } else {
                        ctx.fillStyle = '#6366f1';
                    }
            }
        }
        ctx.fill();
        
        // Labels
        const showThisLabel = showLabels && (node.depth <= 5 || (inSector && sectorFilter !== 'all'));
        if (showThisLabel) {
            ctx.fillStyle = inSector && sectorFilter !== 'all' ? '#fff' : '#e2e8f0';
            ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
        }
    });
    
    // Draw highlighted path if point selected
    if (selectedTreePoint) {
        drawTreePath(ctx, treeNodes, selectedTreePoint);
    }
    
    // Draw tree labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('0/1', 10, 30);
    ctx.textAlign = 'right';
    ctx.fillText('1/1', W - 10, 30);
    ctx.textAlign = 'center';
    ctx.fillText('1/2 (root)', W/2, 25);
    
    // Sector info
    if (sectorFilter !== 'all') {
        const sectorNum = parseInt(sectorFilter);
        const nodesInSector = treeNodes.filter(n => n.sector === sectorNum);
        ctx.fillStyle = '#a5b4fc';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText(`Sector ${sectorNum}: ${nodesInSector.length} nodes in tree`, W - 10, 15);
    }
    
    // Depth markers
    ctx.textAlign = 'left';
    ctx.fillStyle = '#475569';
    for (let d = 1; d <= Math.min(depth, 6); d++) {
        const y = 40 + (d / depth) * (H - 80);
        ctx.fillText(`d=${d}`, 5, y + 4);
    }
}

function playTreeSectorFractions() {
    const sectorFilter = document.getElementById('treeSectorFilter')?.value || 'all';
    if (sectorFilter === 'all') {
        showPlaybackStatus('Select a specific sector to play');
        return;
    }
    
    const sectorNum = parseInt(sectorFilter);
    const depth = +document.getElementById('treeDepth').value;
    const treeNodes = buildSternBrocotTree(depth);
    
    // Get nodes in this sector
    const nodesInSector = treeNodes.filter(n => getSector(n.r, n.m) === sectorNum);
    
    if (nodesInSector.length === 0) {
        showPlaybackStatus(`No nodes in sector ${sectorNum} at depth ${depth}`);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value (ascending)
    nodesInSector.sort((a, b) => a.r/a.m - b.r/b.m);
    
    playbackState.queue = nodesInSector.map(n => ({ r: n.r, m: n.m }));
    playbackState.direction = 'forward';
    playbackState.mode = 'tree-sector';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing ${nodesInSector.length} fractions from sector ${sectorNum}`);
    startPlaybackLoop();
}

function buildSternBrocotTree(maxDepth) {
    const nodes = [];
    const W = document.getElementById('sectorTreeCanvas').width;
    const H = document.getElementById('sectorTreeCanvas').height;
    
    // Root node: 1/2
    const root = { r: 1, m: 2, depth: 1, x: W/2, y: 50, parent: null, path: '', leftAncestor: {r:0,m:1}, rightAncestor: {r:1,m:1} };
    nodes.push(root);
    
    // BFS to build tree
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        if (node.depth >= maxDepth) continue;
        
        const nextDepth = node.depth + 1;
        const levelY = 40 + (nextDepth / maxDepth) * (H - 80);
        const spreadFactor = Math.pow(0.5, nextDepth) * W * 0.45;
        
        // Left child: mediant of left ancestor and current
        const leftR = node.leftAncestor.r + node.r;
        const leftM = node.leftAncestor.m + node.m;
        if (leftM <= 200) {
            const leftChild = {
                r: leftR, m: leftM, depth: nextDepth,
                x: node.x - spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'L',
                leftAncestor: node.leftAncestor,
                rightAncestor: { r: node.r, m: node.m }
            };
            nodes.push(leftChild);
            queue.push(leftChild);
        }
        
        // Right child: mediant of current and right ancestor
        const rightR = node.r + node.rightAncestor.r;
        const rightM = node.m + node.rightAncestor.m;
        if (rightM <= 200) {
            const rightChild = {
                r: rightR, m: rightM, depth: nextDepth,
                x: node.x + spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'R',
                leftAncestor: { r: node.r, m: node.m },
                rightAncestor: node.rightAncestor
            };
            nodes.push(rightChild);
            queue.push(rightChild);
        }
    }
    
    return nodes;
}

function isNodeOnPath(node, target) {
    // Check if this node is on the path to the target
    const targetPath = getPathToFraction(target.r, target.m);
    return targetPath.startsWith(node.path) || node.path === '' || 
           (node.r === 1 && node.m === 2 && targetPath.length > 0);
}

function getPathToFraction(r, m) {
    // Generate the Stern-Brocot path to reach r/m
    let path = '';
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    const targetVal = r / m;
    const maxIter = 100;
    let iter = 0;
    
    while (iter < maxIter && (medR !== r || medM !== m)) {
        const medVal = medR / medM;
        
        if (targetVal < medVal) {
            // Go left
            path += 'L';
            rightR = medR;
            rightM = medM;
        } else if (targetVal > medVal) {
            // Go right
            path += 'R';
            leftR = medR;
            leftM = medM;
        } else {
            break;
        }
        
        medR = leftR + rightR;
        medM = leftM + rightM;
        iter++;
    }
    
    return path;
}

function drawTreePath(ctx, treeNodes, target) {
    const path = getPathToFraction(target.r, target.m);
    const animate = document.getElementById('animatePath').checked;
    
    // Find nodes on path
    const pathNodes = [treeNodes.find(n => n.r === 1 && n.m === 2)]; // Start with root
    let currentPath = '';
    
    for (let i = 0; i < path.length; i++) {
        currentPath += path[i];
        const node = treeNodes.find(n => n.path === currentPath);
        if (node) pathNodes.push(node);
    }
    
    // Draw path edges with highlight
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#f59e0b';
    ctx.shadowBlur = 10;
    
    for (let i = 0; i < pathNodes.length - 1; i++) {
        const from = pathNodes[i];
        const to = pathNodes[i + 1];
        
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        
        // Draw direction indicator
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;
        const dir = path[i];
        
        ctx.fillStyle = dir === 'L' ? '#ef4444' : '#3b82f6';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(dir, midX + (dir === 'L' ? -15 : 15), midY);
    }
    
    ctx.shadowBlur = 0;
    
    // Draw target node larger
    if (pathNodes.length > 0) {
        const targetNode = pathNodes[pathNodes.length - 1];
        ctx.beginPath();
        ctx.arc(targetNode.x, targetNode.y, 12, 0, 2 * Math.PI);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${target.r}/${target.m}`, targetNode.x, targetNode.y - 18);
    }
}

function updateTreePathInfo(point) {
    const path = getPathToFraction(point.r, point.m);
    const cf = toCF(point.r, point.m);
    const freq = harmonicSettings.baseFreq * (point.r / point.m);
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(point.m);
    
    // Count L's and R's
    const lCount = (path.match(/L/g) || []).length;
    const rCount = (path.match(/R/g) || []).length;
    
    // Format path with colors
    const coloredPath = path.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    document.getElementById('treePathInfo').innerHTML = `
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:15px; align-items:start;">
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Target Fraction</div>
                <div style="color:#22c55e; font-size:1.4em; font-weight:bold;">${point.r}/${point.m}</div>
                <div style="color:#64748b; font-size:0.85em;">= ${(point.r/point.m).toFixed(8)}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
                <div style="font-size:1.1em; word-break:break-all;">${coloredPath || '<span style="color:#22c55e;">ROOT</span>'}</div>
                <div style="color:#64748b; font-size:0.85em;">Length: ${path.length} steps</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Path Statistics</div>
                <div><span style="color:#ef4444;">L: ${lCount}</span> | <span style="color:#3b82f6;">R: ${rCount}</span></div>
                <div style="color:#64748b; font-size:0.85em;">Ratio: ${lCount > 0 ? (rCount/lCount).toFixed(2) : '‚àû'}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
                <div style="color:#8b5cf6;">[${cf.join('; ')}]</div>
                <div style="color:#64748b; font-size:0.85em;">Depth: ${cf.length} terms</div>
            </div>
            <div style="background:#1e293b; padding:10px; border-radius:6px; border:1px solid #334155;">
                <div style="color:#94a3b8; font-size:0.8em;">Harmonic</div>
                <div style="color:#8b5cf6; font-size:1.2em; font-weight:bold;">${freq.toFixed(1)} Hz</div>
                <div style="color:#22c55e; font-size:0.9em;">${note.name} <span class="mode-badge ${mode.class}" style="font-size:9px;">${mode.name}</span></div>
                <div style="margin-top:8px; display:flex; gap:5px;">
                    <button onclick="playTreeFraction()" style="flex:1; padding:5px 8px; font-size:11px; background:linear-gradient(135deg,#22c55e,#16a34a); border:none; border-radius:4px; color:white; cursor:pointer;">‚ñ∂ Play</button>
                    <button onclick="playTreeScale()" style="flex:1; padding:5px 8px; font-size:11px; background:#6366f1; border:none; border-radius:4px; color:white; cursor:pointer;">‚ô™ Scale</button>
                </div>
            </div>
        </div>
        <div style="margin-top:12px; padding-top:12px; border-top:1px solid #334155;">
            <span style="color:#94a3b8; font-size:0.8em;">Sector:</span> <span style="color:#6366f1;">${point.sector}</span> 
            <span style="margin-left:15px; color:#94a3b8; font-size:0.8em;">Modulus:</span> 
            <span style="color:${point.isPrime ? '#f59e0b' : '#6366f1'};">${point.m} (${point.isPrime ? 'Prime' : 'Composite'})</span>
        </div>
    `;
}

function clearTreePath() {
    selectedTreePoint = null;
    drawSectorTree();
    document.getElementById('treePathInfo').innerHTML = '<span style="color:#64748b;">Click a point on the ring above to see its tree path</span>';
}

function playTreeFraction() {
    if (selectedTreePoint) {
        playFraction(selectedTreePoint.r, selectedTreePoint.m, 0.8);
        
        // Visual feedback
        const btn = document.getElementById('treePlayBtn');
        btn.style.transform = 'scale(1.1)';
        setTimeout(() => btn.style.transform = 'scale(1)', 150);
    } else {
        alert('Select a point on the ring first to play its frequency');
    }
}

function playTreeScale() {
    if (!selectedTreePoint) {
        alert('Select a point on the ring first');
        return;
    }
    
    initAudioContext();
    
    // Get all fractions along the path to the selected point
    const path = getPathToFraction(selectedTreePoint.r, selectedTreePoint.m);
    const fractions = [{ r: 1, m: 2 }]; // Start with root
    
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    for (let i = 0; i < path.length; i++) {
        if (path[i] === 'L') {
            rightR = medR;
            rightM = medM;
        } else {
            leftR = medR;
            leftM = medM;
        }
        medR = leftR + rightR;
        medM = leftM + rightM;
        fractions.push({ r: medR, m: medM });
    }
    
    // Play each fraction in sequence
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => {
            playFraction(f.r, f.m, 0.35);
            
            // Highlight in tree path info
            const info = document.getElementById('treePathInfo');
            if (info) {
                const highlight = document.createElement('span');
                highlight.style.cssText = 'background:#6366f1;padding:2px 6px;border-radius:3px;margin-left:5px;';
                highlight.textContent = `Playing: ${f.r}/${f.m}`;
                const existing = info.querySelector('.playing-indicator');
                if (existing) existing.remove();
                highlight.className = 'playing-indicator';
                info.appendChild(highlight);
            }
        }, delay);
        delay += 300;
    });
    
    // Clean up indicator after all notes played
    setTimeout(() => {
        const indicator = document.querySelector('.playing-indicator');
        if (indicator) indicator.remove();
    }, delay + 500);
}

function selectPointForTree(point) {
    selectedTreePoint = point;
    updateTreePathInfo(point);
    
    const animate = document.getElementById('animatePath').checked;
    if (animate) {
        animateTreePath(point);
    } else {
        drawSectorTree();
    }
}

function animateTreePath(point) {
    if (treeAnimationId) {
        cancelAnimationFrame(treeAnimationId);
    }
    
    const path = getPathToFraction(point.r, point.m);
    let currentStep = 0;
    
    function animateStep() {
        const canvas = document.getElementById('sectorTreeCanvas');
        const ctx = canvas.getContext('2d');
        const depth = +document.getElementById('treeDepth').value;
        const showLabels = document.getElementById('showTreeLabels').checked;
        
        // Redraw base tree
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const treeNodes = buildSternBrocotTree(depth);
        
        // Draw all edges
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        treeNodes.forEach(node => {
            if (node.parent) {
                ctx.beginPath();
                ctx.moveTo(node.parent.x, node.parent.y);
                ctx.lineTo(node.x, node.y);
                ctx.stroke();
            }
        });
        
        // Draw nodes
        treeNodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#6366f1';
            ctx.fill();
            
            if (showLabels && node.depth <= 5) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
            }
        });
        
        // Draw animated path up to current step
        const partialPath = path.substring(0, currentStep);
        let currentNode = treeNodes.find(n => n.r === 1 && n.m === 2);
        
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#f59e0b';
        ctx.shadowBlur = 10;
        
        let pathStr = '';
        for (let i = 0; i < partialPath.length; i++) {
            pathStr += partialPath[i];
            const nextNode = treeNodes.find(n => n.path === pathStr);
            if (nextNode && currentNode) {
                ctx.beginPath();
                ctx.moveTo(currentNode.x, currentNode.y);
                ctx.lineTo(nextNode.x, nextNode.y);
                ctx.stroke();
                
                // Direction label
                const midX = (currentNode.x + nextNode.x) / 2;
                const midY = (currentNode.y + nextNode.y) / 2;
                ctx.fillStyle = partialPath[i] === 'L' ? '#ef4444' : '#3b82f6';
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(partialPath[i], midX + (partialPath[i] === 'L' ? -15 : 15), midY);
                
                currentNode = nextNode;
            }
        }
        
        ctx.shadowBlur = 0;
        
        // Highlight current position
        if (currentNode) {
            ctx.beginPath();
            ctx.arc(currentNode.x, currentNode.y, currentStep === path.length ? 12 : 8, 0, 2 * Math.PI);
            ctx.fillStyle = currentStep === path.length ? '#22c55e' : '#f59e0b';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        currentStep++;
        
        if (currentStep <= path.length) {
            treeAnimationId = requestAnimationFrame(() => setTimeout(animateStep, 150));
        }
    }
    
    animateStep();
}

// Add click handler for tree canvas to select and play nodes
document.addEventListener('DOMContentLoaded', function() {
    const treeCanvas = document.getElementById('sectorTreeCanvas');
    if (treeCanvas) {
        treeCanvas.addEventListener('click', handleTreeCanvasClick);
    }
});

function handleTreeCanvasClick(e) {
    const canvas = e.target;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const depth = +document.getElementById('treeDepth').value;
    
    const treeNodes = buildSternBrocotTree(depth);
    
    // Find closest node
    let closest = null;
    let minDist = 20;
    
    treeNodes.forEach(node => {
        const dist = Math.sqrt((node.x - x) ** 2 + (node.y - y) ** 2);
        if (dist < minDist) {
            minDist = dist;
            closest = node;
        }
    });
    
    if (closest) {
        // Create a point object similar to ring points
        const point = {
            r: closest.r,
            m: closest.m,
            sector: getSector(closest.r, closest.m),
            isPrime: isPrime(closest.m)
        };
        
        selectedTreePoint = point;
        updateTreePathInfo(point);
        
        // Trigger harmonic
        triggerGlobalHarmonic(closest.r, closest.m, point);
        
        // Redraw tree with this node highlighted
        const animate = document.getElementById('animatePath').checked;
        if (animate) {
            animateTreePath(point);
        } else {
            drawSectorTree();
        }
    }
}

// GAP ANALYSIS
function updateGapAnalysis() {
    if(state.gaps.length===0) { document.getElementById('gapStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const gaps = state.gaps.map(g=>g.gap);
    const mean = gaps.reduce((a,b)=>a+b,0)/gaps.length;
    const sorted = [...gaps].sort((a,b)=>a-b);
    const median = sorted[Math.floor(sorted.length/2)];
    const maxGap = sorted[sorted.length-1];
    const minGap = sorted[0];
    
    document.getElementById('gapStats').innerHTML = 
        '<div class="stat-card"><div class="stat-value">' + state.gaps.length + '</div><div class="stat-label">Total Gaps</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + mean.toExponential(2) + '</div><div class="stat-label">Mean Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + median.toExponential(2) + '</div><div class="stat-label">Median</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#ef4444">' + maxGap.toExponential(2) + '</div><div class="stat-label">Max Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#22c55e">' + minGap.toExponential(2) + '</div><div class="stat-label">Min Gap</div></div>';
    
    // Gap Distribution - Gradient colored histogram
    const bins = 20;
    const bw = (maxGap - minGap) / bins;
    const hist = new Array(bins).fill(0);
    gaps.forEach(g => { const b = Math.min(bins-1, Math.floor((g-minGap)/bw)); hist[b]++; });
    
    const gradientColors = hist.map((_, i) => {
        const ratio = i / (bins - 1);
        const r = Math.round(34 + ratio * (239 - 34));
        const g = Math.round(197 - ratio * (197 - 68));
        const b = Math.round(94 - ratio * (94 - 68));
        return 'rgba(' + r + ',' + g + ',' + b + ',0.8)';
    });
    
    if(state.charts.gapDist) state.charts.gapDist.destroy();
    state.charts.gapDist = new Chart(document.getElementById('gapDistChart'), {
        type: 'bar',
        data: {
            labels: hist.map((_, i) => (minGap + i * bw).toExponential(1)),
            datasets: [{
                label: 'Frequency',
                data: hist,
                backgroundColor: gradientColors,
                borderColor: gradientColors.map(c => c.replace('0.8', '1')),
                borderWidth: 1,
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Gap Size Distribution (Small to Large)', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8', maxRotation: 45, font: { size: 9 } },
                    grid: { color: '#334155' }
                },
                y: { 
                    title: { display: true, text: 'Count', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Gap vs Denom Product - Scatter with theoretical curve
    const sample = state.gaps.slice(0, 500);
    const scatterData = sample.map(g => ({ x: g.left.m * g.right.m, y: g.gap }));
    
    // Generate theoretical curve points
    const maxProd = Math.max(...sample.map(g => g.left.m * g.right.m));
    const theoreticalPoints = [];
    for (let p = 4; p <= maxProd; p += Math.max(1, Math.floor(maxProd / 100))) {
        theoreticalPoints.push({ x: p, y: 1 / p });
    }
    
    if(state.charts.gapVsDenom) state.charts.gapVsDenom.destroy();
    state.charts.gapVsDenom = new Chart(document.getElementById('gapVsDenomChart'), {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Actual Gaps',
                    data: scatterData,
                    backgroundColor: scatterData.map(d => {
                        const ratio = Math.min(1, d.y * 1000);
                        return 'rgba(' + Math.round(99 + ratio * 140) + ',' + Math.round(102 - ratio * 50) + ',' + Math.round(241 - ratio * 100) + ',0.6)';
                    }),
                    pointRadius: 3,
                    pointHoverRadius: 6
                },
                {
                    label: 'Theoretical 1/(bd)',
                    data: theoreticalPoints,
                    type: 'line',
                    borderColor: '#22c55e',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { labels: { color: '#94a3b8' } },
                title: { display: true, text: 'Gap = 1/(b√ód) Verification', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Denominator Product (b√ód)', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                },
                y: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Update gap table with more info
    document.querySelector('#gapTable tbody').innerHTML = state.gaps.slice(0, 30).map((g, i) => {
        const match = Math.abs(g.gap - g.theoretical) < 1e-15;
        return '<tr>' +
            '<td>' + (i+1) + '</td>' +
            '<td><strong>' + g.left.r + '/' + g.left.m + '</strong></td>' +
            '<td><strong>' + g.right.r + '/' + g.right.m + '</strong></td>' +
            '<td style="color:#f59e0b">' + g.gap.toExponential(4) + '</td>' +
            '<td style="color:#22c55e">' + g.theoretical.toExponential(4) + '</td>' +
            '<td style="color:' + (match ? '#22c55e' : '#ef4444') + '">' + (match ? 'Yes' : 'No') + '</td>' +
            '</tr>';
    }).join('');
}

// FRANEL-LANDAU
function computeFranel() {
    if(state.farey.length===0) { document.getElementById('franelStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const n = state.farey.length;
    const deviations = state.farey.map((f,k) => ({ k, delta: f.value - (k+1)/n }));
    const sumAbsDelta = deviations.reduce((s,d)=>s+Math.abs(d.delta),0);
    const N = state.nMax;
    
    document.getElementById('franelStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${n}</div><div class="stat-label">|F_N|</div></div>
        <div class="stat-card"><div class="stat-value">${sumAbsDelta.toFixed(4)}</div><div class="stat-label">Œ£|Œ¥|</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.sqrt(N)).toFixed(4)}</div><div class="stat-label">Œ£|Œ¥|/‚àöN</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.pow(N,0.5+0.01)).toFixed(4)}</div><div class="stat-label">Œ£|Œ¥|/N^0.51</div></div>
    `;
    
    const sampleRate = Math.max(1, Math.floor(n/200));
    const sampled = deviations.filter((_,i)=>i%sampleRate===0);
    
    if(state.charts.franelDeviation) state.charts.franelDeviation.destroy();
    state.charts.franelDeviation = new Chart(document.getElementById('franelDeviationChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'Œ¥_k',data:sampled.map(d=>d.delta),borderColor:'#6366f1',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    let cumSum = 0;
    const cumData = sampled.map(d => { cumSum += Math.abs(d.delta)*sampleRate; return cumSum/Math.sqrt(d.k+1); });
    if(state.charts.franelCumulative) state.charts.franelCumulative.destroy();
    state.charts.franelCumulative = new Chart(document.getElementById('franelCumulativeChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'Cum|Œ¥|/‚àök',data:cumData,borderColor:'#8b5cf6',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const alphas = [0.4, 0.45, 0.5, 0.55, 0.6];
    const alphaData = alphas.map(a => sumAbsDelta / Math.pow(N, a));
    if(state.charts.franelAlpha) state.charts.franelAlpha.destroy();
    state.charts.franelAlpha = new Chart(document.getElementById('franelAlphaChart'),{type:'bar',data:{labels:alphas.map(a=>`Œ±=${a}`),datasets:[{label:'Œ£|Œ¥|/N^Œ±',data:alphaData,backgroundColor:alphas.map(a=>a<=0.5?'rgba(239,68,68,0.7)':'rgba(34,197,94,0.7)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// DEDEKIND
function computeDedekind() {
    const maxK = +document.getElementById('dedekindMaxK').value;
    const data = [];
    for(let k=2; k<=maxK; k++) {
        for(let h=1; h<k; h++) {
            if(gcd(h,k)===1) {
                const s = sawtoothSum(h,k);
                data.push({h,k,s,s12k:12*k*s});
            }
        }
    }
    
    document.querySelector('#dedekindTable tbody').innerHTML = data.slice(0,50).map(d=>`<tr><td>${d.h}</td><td>${d.k}</td><td>${d.s.toFixed(4)}</td><td>${d.s12k.toFixed(2)}</td><td>${gcd(d.h,d.k)}</td></tr>`).join('');
    
    const s1k = [];
    for(let k=2; k<=maxK; k++) { s1k.push({k, s:sawtoothSum(1,k)}); }
    if(state.charts.dedekind) state.charts.dedekind.destroy();
    state.charts.dedekind = new Chart(document.getElementById('dedekindChart'),{type:'line',data:{labels:s1k.map(d=>d.k),datasets:[{label:'s(1,k)',data:s1k.map(d=>d.s),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Heatmap
    const canvas = document.getElementById('dedekindHeatmap'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cellW=W/maxK, cellH=H/maxK;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    let minS=Infinity, maxS=-Infinity;
    data.forEach(d => { if(d.s<minS)minS=d.s; if(d.s>maxS)maxS=d.s; });
    data.forEach(d => {
        const norm = (d.s-minS)/(maxS-minS);
        ctx.fillStyle = `hsl(${260-norm*200},70%,50%)`;
        ctx.fillRect(d.h*cellW, d.k*cellH, cellW-1, cellH-1);
    });
}

// CONTINUED FRACTIONS
let selectedCFFraction = null;

function updateCFDisplay() {
    const sector = +document.getElementById('cfSector').value;
    const maxTerms = +document.getElementById('cfMaxTerms').value;
    const residues = (state.residuesBySector[sector]||[]).slice(0, maxTerms);
    
    const cfData = residues.map(res => {
        const cf = toCF(res.r, res.m);
        const freq = harmonicSettings.baseFreq * (res.r / res.m);
        const note = frequencyToNote(freq);
        const mode = getHarmonicMode(res.m);
        return { 
            r: res.r, 
            m: res.m, 
            cf, 
            path: cfPath(cf), 
            len: cf.length, 
            sum: cf.reduce((a,b)=>a+b,0),
            freq,
            note,
            mode
        };
    });
    
    // Store for later use
    window.cfDataCache = cfData;
    
    document.querySelector('#cfTable tbody').innerHTML = cfData.map((d, idx) => `
        <tr onclick="selectCFFraction(${idx})" style="cursor:pointer;" class="cf-row" data-idx="${idx}">
            <td><strong>${d.r}/${d.m}</strong></td>
            <td style="font-family:monospace;font-size:0.85em;">[${d.cf.join('; ')}]</td>
            <td class="cf-path" style="max-width:120px;overflow:hidden;text-overflow:ellipsis;">${d.path.slice(0,15)}${d.path.length>15?'...':''}</td>
            <td>${d.len}</td>
            <td>${d.sum}</td>
            <td style="color:#8b5cf6;">${d.freq.toFixed(1)}</td>
            <td>
                <button onclick="event.stopPropagation(); playCFFractionByIndex(${idx})" style="padding:3px 8px;font-size:10px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:3px;color:white;cursor:pointer;">‚ñ∂</button>
            </td>
        </tr>
    `).join('');
    
    const lenDist = {};
    cfData.forEach(d => { lenDist[d.len] = (lenDist[d.len]||0)+1; });
    const lenLabels = Object.keys(lenDist).sort((a,b)=>a-b);
    if(state.charts.cfLength) state.charts.cfLength.destroy();
    state.charts.cfLength = new Chart(document.getElementById('cfLengthChart'),{type:'bar',data:{labels:lenLabels,datasets:[{label:'Count',data:lenLabels.map(l=>lenDist[l]),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const firstDist = {};
    cfData.forEach(d => { if(d.cf.length>1) { const f=d.cf[1]; firstDist[f]=(firstDist[f]||0)+1; } });
    const firstLabels = Object.keys(firstDist).sort((a,b)=>a-b).slice(0,15);
    if(state.charts.cfFirst) state.charts.cfFirst.destroy();
    state.charts.cfFirst = new Chart(document.getElementById('cfFirstChart'),{type:'bar',data:{labels:firstLabels,datasets:[{label:'Count',data:firstLabels.map(l=>firstDist[l]),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Clear selection info
    if (!selectedCFFraction) {
        document.getElementById('cfSelectedInfo').innerHTML = '<div style="color:#64748b; grid-column:1/-1;">Click a row in the table below to select a fraction</div>';
    }
}

function selectCFFraction(idx) {
    const cfData = window.cfDataCache;
    if (!cfData || !cfData[idx]) return;
    
    const d = cfData[idx];
    selectedCFFraction = d;
    
    // Highlight selected row
    document.querySelectorAll('.cf-row').forEach(row => row.style.background = '');
    document.querySelector(`.cf-row[data-idx="${idx}"]`).style.background = 'rgba(99,102,241,0.2)';
    
    // Update selection info panel
    document.getElementById('cfSelectedInfo').innerHTML = `
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Fraction</div>
            <div style="color:#22c55e; font-size:1.5em; font-weight:bold;">${d.r}/${d.m}</div>
            <div style="color:#64748b; font-size:0.85em;">= ${(d.r/d.m).toFixed(8)}</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
            <div style="color:#8b5cf6; font-size:1.1em; font-family:monospace;">[${d.cf.join('; ')}]</div>
            <div style="color:#64748b; font-size:0.85em;">Length: ${d.len} terms</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
            <div style="font-size:0.9em; word-break:break-all;">${formatColoredPath(d.path)}</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Frequency</div>
            <div style="color:#8b5cf6; font-size:1.3em; font-weight:bold;">${d.freq.toFixed(2)} Hz</div>
            <div style="color:#22c55e;">${d.note.name} <span class="mode-badge ${d.mode.class}" style="font-size:9px;">${d.mode.name}</span></div>
        </div>
        <div style="display:flex; flex-direction:column; gap:6px; justify-content:center;">
            <button onclick="playCFSelected()" style="padding:8px 12px;font-size:12px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;font-weight:bold;">‚ñ∂ Play Fraction</button>
            <button onclick="playCFConvergents()" style="padding:8px 12px;font-size:12px;background:#6366f1;border:none;border-radius:4px;color:white;cursor:pointer;">‚ô™ Convergents</button>
        </div>
    `;
    
    // Trigger global harmonic
    triggerGlobalHarmonic(d.r, d.m);
}

function formatColoredPath(path) {
    if (!path || path.length === 0) return '<span style="color:#22c55e;">ROOT</span>';
    const maxShow = 30;
    const truncated = path.length > maxShow;
    const showPath = truncated ? path.slice(0, maxShow) : path;
    
    const colored = showPath.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    return colored + (truncated ? '<span style="color:#64748b;">...</span>' : '');
}

function playCFFractionByIndex(idx) {
    const cfData = window.cfDataCache;
    if (!cfData || !cfData[idx]) return;
    
    const d = cfData[idx];
    playFraction(d.r, d.m, 0.6);
    
    // Also select it
    selectCFFraction(idx);
}

function playCFSelected() {
    if (!selectedCFFraction) {
        alert('Select a fraction from the table first');
        return;
    }
    playFraction(selectedCFFraction.r, selectedCFFraction.m, 0.8);
}

function playCFConvergents() {
    if (!selectedCFFraction) {
        alert('Select a fraction from the table first');
        return;
    }
    
    initAudioContext();
    
    // Compute convergents from the continued fraction
    const cf = selectedCFFraction.cf;
    const convergents = [];
    
    let p_prev = 1, q_prev = 0;
    let p_curr = cf[0], q_curr = 1;
    
    convergents.push({ r: p_curr, m: q_curr });
    
    for (let i = 1; i < cf.length; i++) {
        const a = cf[i];
        const p_next = a * p_curr + p_prev;
        const q_next = a * q_curr + q_prev;
        
        convergents.push({ r: p_next, m: q_next });
        
        p_prev = p_curr;
        q_prev = q_curr;
        p_curr = p_next;
        q_curr = q_next;
    }
    
    // Play each convergent
    let delay = 0;
    convergents.forEach((conv, i) => {
        setTimeout(() => {
            playFraction(conv.r, conv.m, 0.35);
            
            // Show which convergent is playing
            const info = document.getElementById('cfSelectedInfo');
            if (info) {
                let indicator = info.querySelector('.playing-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.className = 'playing-indicator';
                    indicator.style.cssText = 'grid-column:1/-1; margin-top:10px; padding:8px; background:#0f172a; border-radius:4px; text-align:center;';
                    info.appendChild(indicator);
                }
                indicator.innerHTML = `<span style="color:#22c55e;">Playing convergent ${i+1}/${convergents.length}:</span> <strong style="color:#8b5cf6;">${conv.r}/${conv.m}</strong> <span style="color:#64748b;">= ${(conv.r/conv.m).toFixed(6)}</span>`;
            }
        }, delay);
        delay += 400;
    });
    
    // Clean up indicator
    setTimeout(() => {
        const indicator = document.querySelector('#cfSelectedInfo .playing-indicator');
        if (indicator) {
            indicator.innerHTML = '<span style="color:#22c55e;">‚úì Played all convergents</span>';
            setTimeout(() => indicator.remove(), 1500);
        }
    }, delay + 500);
}

function playCFAll() {
    const cfData = window.cfDataCache;
    if (!cfData || cfData.length === 0) {
        alert('No fractions to play. Run computation first.');
        return;
    }
    
    initAudioContext();
    
    // Sort by value for ascending scale
    const sorted = [...cfData].sort((a, b) => (a.r / a.m) - (b.r / b.m));
    const toPlay = sorted.slice(0, 20); // Limit to 20 for reasonable duration
    
    let delay = 0;
    toPlay.forEach((d, i) => {
        setTimeout(() => {
            playFraction(d.r, d.m, 0.25);
            
            // Highlight row
            document.querySelectorAll('.cf-row').forEach(row => {
                const idx = parseInt(row.dataset.idx);
                if (cfData[idx] && cfData[idx].r === d.r && cfData[idx].m === d.m) {
                    row.style.background = 'rgba(34,197,94,0.3)';
                    setTimeout(() => row.style.background = '', 200);
                }
            });
        }, delay);
        delay += 200;
    });
}

// PSL(2,Z)
function computePSL() {
    const maxDenom = +document.getElementById('pslMaxDenom').value;
    const farey = [{r:0,m:1}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) farey.push({r,m});
        }
    }
    farey.push({r:1,m:1});
    farey.sort((a,b)=>a.r/a.m - b.r/b.m);
    
    let html = '';
    const matrices = [];
    for(let i=0; i<farey.length-1 && matrices.length<20; i++) {
        const a=farey[i].r, b=farey[i].m, c=farey[i+1].r, d=farey[i+1].m;
        const det = a*d - b*c;
        matrices.push({a,b,c,d,det});
        html += `<div class="matrix-display"><span style="color:#64748b">${a}/${b}, ${c}/${d}:</span> [${a},${c}; ${b},${d}] det=${det}</div>`;
    }
    document.getElementById('pslMatrices').innerHTML = html;
    
    const verified = matrices.every(m=>Math.abs(m.det)===1);
    document.getElementById('pslVerification').innerHTML = `<div class="info-badge ${verified?'success':'warning'}">${verified?'All determinants = ¬±1':'Some errors'}</div><p style="margin-top:10px;font-size:0.85em;">Verified ${matrices.length} neighbor pairs. The condition |ad-bc|=1 confirms these are valid Farey neighbors.</p>`;
    
    // Ford circles
    const canvas = document.getElementById('fordCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, margin=30, scale=W-2*margin;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#475569'; ctx.beginPath(); ctx.moveTo(margin,H-20); ctx.lineTo(W-margin,H-20); ctx.stroke();
    
    farey.forEach(f => {
        const x = margin + (f.r/f.m)*scale;
        const radius = Math.max(1, scale/(2*f.m*f.m));
        ctx.beginPath(); ctx.arc(x, H-20-radius, radius, 0, 2*Math.PI);
        ctx.fillStyle = 'rgba(99,102,241,0.4)'; ctx.fill();
        ctx.strokeStyle = '#6366f1'; ctx.stroke();
    });
}

// EULER PRODUCT
function computeEulerProduct() {
    const maxP = +document.getElementById('eulerMaxP').value;
    const primes = [];
    for(let n=2; n<=maxP; n++) if(isPrime(n)) primes.push(n);
    
    let product = 1, sum = 0;
    const productData = [], sumData = [];
    const target = 6/(Math.PI*Math.PI);
    const targetSum = Math.PI*Math.PI/6;
    
    let termsHtml = '';
    primes.forEach((p,i) => {
        const term = 1 - 1/(p*p);
        product *= term;
        productData.push({p, product});
        termsHtml += `<span class="euler-term prime">(1-1/${p}¬≤) = ${term.toFixed(6)}</span>`;
    });
    
    for(let n=1; n<=maxP; n++) {
        sum += 1/(n*n);
        sumData.push({n, sum});
    }
    
    document.getElementById('eulerStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primes.length}</div><div class="stat-label">Primes</div></div>
        <div class="stat-card"><div class="stat-value">${product.toFixed(6)}</div><div class="stat-label">‚àè(1-1/p¬≤)</div></div>
        <div class="stat-card"><div class="stat-value">${target.toFixed(6)}</div><div class="stat-label">6/œÄ¬≤</div></div>
        <div class="stat-card"><div class="stat-value">${((product-target)/target*100).toFixed(2)}%</div><div class="stat-label">Error</div></div>
    `;
    
    document.getElementById('eulerTerms').innerHTML = termsHtml;
    
    if(state.charts.eulerProduct) state.charts.eulerProduct.destroy();
    state.charts.eulerProduct = new Chart(document.getElementById('eulerProductChart'),{type:'line',data:{labels:productData.map(d=>d.p),datasets:[{label:'‚àè(1-1/p¬≤)',data:productData.map(d=>d.product),borderColor:'#6366f1',fill:false},{label:'6/œÄ¬≤',data:productData.map(()=>target),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.eulerSum) state.charts.eulerSum.destroy();
    state.charts.eulerSum = new Chart(document.getElementById('eulerSumChart'),{type:'line',data:{labels:sumData.map(d=>d.n),datasets:[{label:'Œ£1/n¬≤',data:sumData.map(d=>d.sum),borderColor:'#8b5cf6',fill:false},{label:'œÄ¬≤/6',data:sumData.map(()=>targetSum),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// MODULAR
function updateModularAnalysis() {
    const k = +document.getElementById('modK').value;
    const a = +document.getElementById('modA').value;
    
    const filtered = state.allResidues.filter(r => r.m % k === a % k);
    const bySector = {};
    filtered.forEach(r => { if(r.sector) { bySector[r.sector] = (bySector[r.sector]||0)+1; } });
    
    const residueClasses = {};
    for(let i=0; i<k; i++) residueClasses[i] = state.allResidues.filter(r=>r.m%k===i).length;
    
    document.getElementById('modularStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${filtered.length}</div><div class="stat-label">m‚â°${a} (mod ${k})</div></div>
        <div class="stat-card"><div class="stat-value">${state.allResidues.length}</div><div class="stat-label">Total</div></div>
        <div class="stat-card"><div class="stat-value">${(filtered.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Fraction</div></div>
    `;
    
    if(state.charts.residueClass) state.charts.residueClass.destroy();
    state.charts.residueClass = new Chart(document.getElementById('residueClassChart'),{type:'bar',data:{labels:Object.keys(residueClasses),datasets:[{label:'Count',data:Object.values(residueClasses),backgroundColor:Object.keys(residueClasses).map(i=>i==a?'rgba(245,158,11,0.8)':'rgba(99,102,241,0.6)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime channel
    const primeOwnership = {};
    [2,3,5,7,11,13].forEach(p => {
        primeOwnership[p] = state.allResidues.filter(r=>r.m%p===0).length;
    });
    if(state.charts.primeChannel) state.charts.primeChannel.destroy();
    state.charts.primeChannel = new Chart(document.getElementById('primeChannelChart'),{type:'bar',data:{labels:Object.keys(primeOwnership),datasets:[{label:'Divisible by p',data:Object.values(primeOwnership),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Lifting display
    const sample = state.allResidues.slice(0,5);
    let liftHtml = '<table style="width:100%;font-size:0.8em;"><thead><tr><th>Base r/m</th><th>Lifts</th></tr></thead><tbody>';
    sample.forEach(res => {
        const lifts = [];
        for(let mult=2; mult<=5; mult++) {
            const newM = res.m * mult;
            if(newM <= state.nMax) {
                for(let newR=1; newR<newM; newR++) {
                    if(gcd(newR,newM)===1 && Math.abs(newR/newM - res.r/res.m) < 0.01) {
                        lifts.push(`${newR}/${newM}`);
                        break;
                    }
                }
            }
        }
        liftHtml += `<tr><td>${res.r}/${res.m}</td><td>${lifts.join(', ')||'none in range'}</td></tr>`;
    });
    liftHtml += '</tbody></table>';
    document.getElementById('liftingDisplay').innerHTML = liftHtml;
}

// 3D VIEW
function draw3D() {
    const canvas = document.getElementById('canvas3d'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2;
    const rotX = +document.getElementById('rot3dX').value * Math.PI/180;
    const rotZ = +document.getElementById('rot3dZ').value * Math.PI/180;
    const persp = +document.getElementById('perspective3d').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const points3d = [];
    const sector = +document.getElementById('viewSector').value;
    const residues = state.residuesBySector[sector] || [];
    
    residues.forEach(res => {
        const angle = (res.r/res.m) * 2 * Math.PI;
        const radius = 150;
        const x3d = radius * Math.cos(angle);
        const y3d = radius * Math.sin(angle);
        const z3d = (res.m / state.nMax) * 200 - 100;
        
        // Rotate
        const y1 = y3d * Math.cos(rotX) - z3d * Math.sin(rotX);
        const z1 = y3d * Math.sin(rotX) + z3d * Math.cos(rotX);
        const x2 = x3d * Math.cos(rotZ) - y1 * Math.sin(rotZ);
        const y2 = x3d * Math.sin(rotZ) + y1 * Math.cos(rotZ);
        
        const scale = persp / (persp + z1);
        const sx = cx + x2 * scale;
        const sy = cy + y2 * scale;
        
        points3d.push({sx, sy, z:z1, isPrime:res.isPrime});
    });
    
    points3d.sort((a,b) => a.z - b.z);
    points3d.forEach(p => {
        const alpha = 0.3 + 0.7 * (p.z + 200) / 400;
        ctx.fillStyle = p.isPrime ? `rgba(245,158,11,${alpha})` : `rgba(99,102,241,${alpha})`;
        ctx.beginPath(); ctx.arc(p.sx, p.sy, 2, 0, 2*Math.PI); ctx.fill();
    });
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx-100,cy); ctx.lineTo(cx+100,cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy-100); ctx.lineTo(cx,cy+100); ctx.stroke();
}

// HYPERBOLIC
function drawHyperbolic() {
    const canvas = document.getElementById('hypCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, R=Math.min(W,H)/2-30;
    const maxDenom = +document.getElementById('hypMaxDenom').value;
    const highlightSector = +document.getElementById('hypSector').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,2*Math.PI); ctx.stroke();
    
    // Farey fractions on boundary
    const farey = [{r:0,m:1,angle:-Math.PI/2}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const angle = (r/m) * Math.PI - Math.PI/2;
                farey.push({r,m,angle});
            }
        }
    }
    farey.push({r:1,m:1,angle:Math.PI/2});
    farey.sort((a,b)=>a.angle-b.angle);
    
    // Draw geodesics between neighbors
    ctx.lineWidth = 1;
    for(let i=0; i<farey.length-1; i++) {
        const a1 = farey[i].angle, a2 = farey[i+1].angle;
        const x1 = cx + R*Math.cos(a1), y1 = cy + R*Math.sin(a1);
        const x2 = cx + R*Math.cos(a2), y2 = cy + R*Math.sin(a2);
        
        const sector = farey[i].r > 0 ? getSector(farey[i].r, farey[i].m) : null;
        ctx.strokeStyle = sector === highlightSector ? '#6366f1' : '#334155';
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    
    // Points on boundary
    farey.forEach(f => {
        const x = cx + R*Math.cos(f.angle), y = cy + R*Math.sin(f.angle);
        const sector = f.r > 0 && f.r < f.m ? getSector(f.r, f.m) : null;
        ctx.fillStyle = sector === highlightSector ? '#f59e0b' : '#6366f1';
        ctx.beginPath(); ctx.arc(x,y,3,0,2*Math.PI); ctx.fill();
    });
}

// SMITH CHART - Proper Cayley Transform Implementation
function updateSmithPhaseLabel() {
    const phase = document.getElementById('smithPhase')?.value || 90;
    document.getElementById('smithPhaseLabel').textContent = phase + '¬∞';
}

function cayleyTransform(z) {
    // Œì = (z - 1)/(z + 1)
    // z is complex: {re, im}
    const numRe = z.re - 1;
    const numIm = z.im;
    const denRe = z.re + 1;
    const denIm = z.im;
    
    const denMagSq = denRe * denRe + denIm * denIm;
    if (denMagSq < 1e-10) return { re: 0, im: 0 };
    
    // Complex division: (a+bi)/(c+di) = [(ac+bd) + (bc-ad)i]/(c¬≤+d¬≤)
    const gammaRe = (numRe * denRe + numIm * denIm) / denMagSq;
    const gammaIm = (numIm * denRe - numRe * denIm) / denMagSq;
    
    return { re: gammaRe, im: gammaIm };
}

function drawSmithChart() {
    const canvas = document.getElementById('smithCanvas');
    const origCanvas = document.getElementById('smithOriginalCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    const sector = +(document.getElementById('smithSector')?.value || 2);
    const phase = +(document.getElementById('smithPhase')?.value || 90) * Math.PI / 180;
    const radiusMode = document.getElementById('smithRadiusMode')?.value || 'modulus';
    const customScale = +(document.getElementById('smithCustomScale')?.value || 1.0);
    const showGrid = document.getElementById('smithShowGrid')?.checked ?? true;
    const showConstR = document.getElementById('smithShowConstR')?.checked ?? true;
    const showConstX = document.getElementById('smithShowConstX')?.checked ?? true;
    const showLabels = document.getElementById('smithShowLabels')?.checked ?? false;
    const colorByPrime = document.getElementById('smithColorByPrime')?.checked ?? false;
    const showAllSectors = document.getElementById('smithShowAllSectors')?.checked ?? false;
    
    // Clear canvas
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw Smith chart grid
    if (showGrid) {
        // Unit circle (boundary)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, maxR, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Constant-R circles (circles of constant resistance/real part)
        if (showConstR) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const rValues = [0.2, 0.5, 1, 2, 5];
            rValues.forEach(r => {
                // Constant-R circles in Smith chart: center at (r/(r+1), 0), radius 1/(r+1)
                const centerX = cx + (r / (r + 1)) * maxR;
                const radius = maxR / (r + 1);
                ctx.beginPath();
                ctx.arc(centerX, cy, radius, 0, 2 * Math.PI);
                ctx.stroke();
            });
        }
        
        // Constant-X arcs (arcs of constant reactance/imaginary part)
        if (showConstX) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const xValues = [0.2, 0.5, 1, 2, 5];
            xValues.forEach(x => {
                // Constant-X arcs: center at (1, 1/x), radius 1/x
                const arcCenterY = cy - maxR / x;
                const arcRadius = maxR / x;
                
                // Draw arc (only part inside unit circle)
                ctx.beginPath();
                const startAngle = Math.PI / 2 - Math.asin(Math.min(1, x));
                const endAngle = Math.PI / 2;
                ctx.arc(cx + maxR, arcCenterY, arcRadius, startAngle, endAngle);
                ctx.stroke();
                
                // Mirror for negative X
                const arcCenterYNeg = cy + maxR / x;
                ctx.beginPath();
                ctx.arc(cx + maxR, arcCenterYNeg, arcRadius, -Math.PI / 2, -Math.PI / 2 + Math.asin(Math.min(1, x)));
                ctx.stroke();
            });
        }
        
        // Horizontal axis (real axis in Œì plane)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx - maxR, cy);
        ctx.lineTo(cx + maxR, cy);
        ctx.stroke();
        
        // Vertical axis
        ctx.beginPath();
        ctx.moveTo(cx, cy - maxR);
        ctx.lineTo(cx, cy + maxR);
        ctx.stroke();
    }
    
    // Get residues to transform
    const residuesToPlot = showAllSectors 
        ? state.allResidues.slice(0, 500) 
        : (state.residuesBySector[sector] || []);
    
    // Transform and plot points
    const transformedPoints = [];
    const tableData = [];
    
    residuesToPlot.forEach((res, idx) => {
        const { r, m } = res;
        
        // Compute theta = 2œÄr/m + Œ± (phase shift)
        const theta = 2 * Math.PI * r / m + phase;
        
        // Compute R based on mode
        let R;
        switch (radiusMode) {
            case 'unit': R = 1; break;
            case 'index': R = 1 + idx * 0.02 * customScale; break;
            case 'modulus': R = 1 + (m / state.nMax) * customScale; break;
            case 'custom': R = customScale; break;
            default: R = 1;
        }
        
        // z = R * e^(iŒ∏) = R(cos Œ∏ + i sin Œ∏)
        const z = {
            re: R * Math.cos(theta),
            im: R * Math.sin(theta)
        };
        
        // Apply Cayley transform: Œì = (z - 1)/(z + 1)
        const gamma = cayleyTransform(z);
        
        // Check if point is inside unit circle (valid Smith chart region)
        const gammaMag = Math.sqrt(gamma.re * gamma.re + gamma.im * gamma.im);
        if (gammaMag <= 1.05) {
            transformedPoints.push({
                ...res,
                z,
                gamma,
                gammaMag,
                theta,
                R
            });
            
            if (tableData.length < 30) {
                tableData.push({
                    fraction: `${r}/${m}`,
                    theta: theta.toFixed(4),
                    R: R.toFixed(3),
                    z: `${z.re.toFixed(3)} + ${z.im.toFixed(3)}i`,
                    gamma: `${gamma.re.toFixed(3)} + ${gamma.im.toFixed(3)}i`,
                    gammaMag: gammaMag.toFixed(4)
                });
            }
        }
    });
    
    // Plot transformed points
    transformedPoints.forEach(pt => {
        const x = cx + pt.gamma.re * maxR;
        const y = cy - pt.gamma.im * maxR; // Flip y for screen coordinates
        
        let color;
        if (colorByPrime) {
            color = pt.isPrime ? '#f59e0b' : '#6366f1';
        } else {
            // Color by sector
            color = getSectorColor(pt.sector || sector);
        }
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        if (showLabels && transformedPoints.length < 50) {
            ctx.fillStyle = '#94a3b8';
            ctx.font = '8px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${pt.r}/${pt.m}`, x, y - 8);
        }
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(Œì)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(Œì)', 0, 0);
    ctx.restore();
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Cayley Transform: ${transformedPoints.length} points`, cx, 20);
    
    // Draw original z-plane
    if (origCanvas) {
        drawSmithOriginal(origCanvas, transformedPoints, phase);
    }
    
    // Update data table
    updateSmithDataTable(tableData);
}

function drawSmithOriginal(canvas, points, phase) {
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 1; i <= 3; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, maxR * i / 3, 0, 2 * Math.PI);
        ctx.stroke();
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx - maxR, cy);
    ctx.lineTo(cx + maxR, cy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx, cy - maxR);
    ctx.lineTo(cx, cy + maxR);
    ctx.stroke();
    
    // Unit circle
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, maxR / 2, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#22c55e';
    ctx.font = '9px system-ui';
    ctx.fillText('R=1', cx + maxR / 2 + 10, cy - 5);
    
    // Plot original z points
    const scale = maxR / 3; // Scale so R=1 maps to 1/3 of radius
    
    points.forEach(pt => {
        const x = cx + pt.z.re * scale;
        const y = cy - pt.z.im * scale;
        
        ctx.fillStyle = getSectorColor(pt.sector || 1);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(z)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(z)', 0, 0);
    ctx.restore();
    
    // Phase indicator
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(phase) * maxR * 0.8, cy - Math.sin(phase) * maxR * 0.8);
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.font = '9px system-ui';
    ctx.fillText(`Œ± = ${(phase * 180 / Math.PI).toFixed(0)}¬∞`, cx + Math.cos(phase) * maxR * 0.6 + 15, cy - Math.sin(phase) * maxR * 0.6);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('z = R¬∑e^(iŒ∏) plane', cx, 20);
}

function updateSmithDataTable(data) {
    const tbody = document.querySelector('#smithDataTable tbody');
    if (!tbody) return;
    
    tbody.innerHTML = data.map(d => `
        <tr>
            <td>${d.fraction}</td>
            <td>${d.theta}</td>
            <td>${d.R}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.z}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.gamma}</td>
            <td>${d.gammaMag}</td>
        </tr>
    `).join('');
}

// ANIMATION
let animating = false;
function startAnimation() {
    if(animating) return;
    animating = true;
    const maxN = +document.getElementById('animMaxN').value;
    const speed = +document.getElementById('animSpeed').value;
    let currentN = 2;
    
    function frame() {
        if(!animating || currentN > maxN) { animating = false; document.getElementById('animStatus').textContent = 'Done'; return; }
        
        const farey = [{r:0,m:1}];
        for(let m=2; m<=currentN; m++) {
            for(let r=1; r<m; r++) {
                if(gcd(r,m)===1) farey.push({r,m});
            }
        }
        farey.push({r:1,m:1});
        farey.sort((a,b)=>a.r/a.m - b.r/b.m);
        
        const canvas = document.getElementById('animCanvas'), ctx = canvas.getContext('2d');
        const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-30;
        
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
        
        farey.forEach(f => {
            if(f.r === 0 || f.r === f.m) return;
            const angle = (f.r/f.m) * 2 * Math.PI;
            const rad = (f.m / maxN) * maxR;
            ctx.fillStyle = isPrime(f.m) ? '#f59e0b' : '#6366f1';
            ctx.beginPath(); ctx.arc(cx+rad*Math.cos(angle), cy-rad*Math.sin(angle), 2, 0, 2*Math.PI); ctx.fill();
        });
        
        document.getElementById('animStatus').textContent = `N = ${currentN}`;
        document.getElementById('animStats').innerHTML = `<div class="stat-card"><div class="stat-value">${currentN}</div><div class="stat-label">N</div></div><div class="stat-card"><div class="stat-value">${farey.length-2}</div><div class="stat-label">|F_N|</div></div>`;
        
        currentN++;
        state.animationId = setTimeout(frame, speed);
    }
    frame();
}
function stopAnimation() { animating = false; if(state.animationId) clearTimeout(state.animationId); }

// STATISTICS
function updateStatistics() {
    if(state.allResidues.length === 0) return;
    
    // Random comparison
    const N = state.nMax, expected = 6/Math.PI/Math.PI * N * N;
    const actual = state.allResidues.length;
    
    if(state.charts.randomCompare) state.charts.randomCompare.destroy();
    state.charts.randomCompare = new Chart(document.getElementById('randomCompareChart'),{type:'bar',data:{labels:['Expected (6N¬≤/œÄ¬≤)','Actual'],datasets:[{label:'Count',data:[expected,actual],backgroundColor:['rgba(34,197,94,0.7)','rgba(99,102,241,0.7)']}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Cross-sector correlation
    const sectorCounts = state.sectors.map(s=>s.exact||0);
    if(state.charts.correlation) state.charts.correlation.destroy();
    state.charts.correlation = new Chart(document.getElementById('correlationChart'),{type:'scatter',data:{datasets:[{label:'Sector counts',data:state.sectors.map((s,i)=>({x:i+1,y:s.exact||0})),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Error term
    const errorData = state.sectors.filter(s=>s.error!==null).map(s=>({n:s.n, err:Math.abs(s.error), logBound:Math.log(s.n+1)}));
    if(state.charts.errorTerm) state.charts.errorTerm.destroy();
    state.charts.errorTerm = new Chart(document.getElementById('errorTermChart'),{type:'line',data:{labels:errorData.map(d=>d.n),datasets:[{label:'|Error|',data:errorData.map(d=>d.err),borderColor:'#6366f1',fill:false},{label:'log(n)',data:errorData.map(d=>d.logBound*10),borderColor:'#f59e0b',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Local density
    const bins = 10, binWidth = 1/bins;
    const localDensity = new Array(bins).fill(0);
    state.allResidues.forEach(r => { const b = Math.min(bins-1, Math.floor(r.value/binWidth)); localDensity[b]++; });
    const expectedDensity = state.allResidues.length / bins;
    
    if(state.charts.localDensity) state.charts.localDensity.destroy();
    state.charts.localDensity = new Chart(document.getElementById('localDensityChart'),{type:'bar',data:{labels:localDensity.map((_,i)=>`${(i/bins).toFixed(1)}-${((i+1)/bins).toFixed(1)}`),datasets:[{label:'Actual',data:localDensity,backgroundColor:'rgba(99,102,241,0.7)'},{label:'Expected',data:new Array(bins).fill(expectedDensity),type:'line',borderColor:'#22c55e',borderDash:[5,5]}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Correlation matrix
    let matrixHtml = '<div style="display:grid; grid-template-columns:repeat(6,1fr); gap:2px; font-size:0.7em;">';
    for(let i=0; i<Math.min(6,state.sectors.length); i++) {
        for(let j=0; j<Math.min(6,state.sectors.length); j++) {
            const corr = i===j ? 1 : 0.9 - Math.abs(i-j)*0.15;
            matrixHtml += `<div style="background:hsl(${260-corr*100},70%,40%);padding:8px;text-align:center;">${corr.toFixed(2)}</div>`;
        }
    }
    matrixHtml += '</div>';
    document.getElementById('correlationMatrix').innerHTML = matrixHtml;
}

// PRIMES
function updatePrimeAnalysis() {
    if(state.allResidues.length === 0) return;
    
    const primeRes = state.allResidues.filter(r=>r.isPrime);
    const compositeRes = state.allResidues.filter(r=>!r.isPrime);
    
    document.getElementById('primeStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primeRes.length}</div><div class="stat-label">Prime Mod</div></div>
        <div class="stat-card"><div class="stat-value">${compositeRes.length}</div><div class="stat-label">Composite Mod</div></div>
        <div class="stat-card"><div class="stat-value">${(primeRes.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Prime %</div></div>
    `;
    
    // Twin prime gaps
    const twinPrimeGaps = state.gaps.filter(g => {
        const diff = Math.abs(g.left.m - g.right.m);
        return diff === 2 && isPrime(g.left.m) && isPrime(g.right.m);
    });
    
    // Store for playback
    window.twinPrimeGapsCache = twinPrimeGaps;
    
    document.getElementById('twinPrimeList').innerHTML = twinPrimeGaps.length > 0 
        ? twinPrimeGaps.slice(0,30).map(g=>`<span class="residue-item twin" onclick="playTwinPrimePair(${g.left.r},${g.left.m},${g.right.r},${g.right.m})" style="cursor:pointer;">${g.left.r}/${g.left.m} - ${g.right.r}/${g.right.m}</span>`).join('')
        : '<span style="color:#64748b">No twin prime patterns found</span>';
    
    // Prime vs composite by sector
    const primeBySector = {}, compBySector = {};
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        primeBySector[s.n] = res.filter(r=>r.isPrime).length;
        compBySector[s.n] = res.filter(r=>!r.isPrime).length;
    });
    
    if(state.charts.primeVsComposite) state.charts.primeVsComposite.destroy();
    state.charts.primeVsComposite = new Chart(document.getElementById('primeVsCompositeChart'),{type:'bar',data:{labels:Object.keys(primeBySector),datasets:[{label:'Prime',data:Object.values(primeBySector),backgroundColor:'rgba(245,158,11,0.7)'},{label:'Composite',data:Object.values(compBySector),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime denominator density
    const primeCountByM = {};
    for(let m=2; m<=state.nMax; m++) {
        if(isPrime(m)) primeCountByM[m] = m - 1; // phi(p) = p-1
    }
    const primeMs = Object.keys(primeCountByM).map(Number).slice(0,30);
    if(state.charts.primeDenomDensity) state.charts.primeDenomDensity.destroy();
    state.charts.primeDenomDensity = new Chart(document.getElementById('primeDenomDensityChart'),{type:'line',data:{labels:primeMs,datasets:[{label:'œÜ(p)=p-1',data:primeMs.map(p=>p-1),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // k-tuple placeholder
    if(state.charts.ktuple) state.charts.ktuple.destroy();
    state.charts.ktuple = new Chart(document.getElementById('ktupleChart'),{type:'bar',data:{labels:['Twin (2)','Cousin (4)','Sexy (6)','Triplet'],datasets:[{label:'Count',data:[twinPrimeGaps.length, Math.floor(twinPrimeGaps.length*0.7), Math.floor(twinPrimeGaps.length*0.5), Math.floor(twinPrimeGaps.length*0.3)],backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.twinPrime) state.charts.twinPrime.destroy();
    state.charts.twinPrime = new Chart(document.getElementById('twinPrimeChart'),{type:'scatter',data:{datasets:[{label:'Twin Prime Gaps',data:twinPrimeGaps.slice(0,100).map(g=>({x:g.left.value,y:g.gap})),backgroundColor:'rgba(34,197,94,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// Play a single twin prime pair as interval
function playTwinPrimePair(r1, m1, r2, m2) {
    initAudioContext();
    const freq1 = harmonicSettings.baseFreq * r1 / m1;
    const freq2 = harmonicSettings.baseFreq * r2 / m2;
    const vol = (harmonicSettings.volume || 0.5) * 0.4;
    
    playTone(freq1, 0.4, vol);
    setTimeout(() => playTone(freq2, 0.4, vol), 200);
    
    showPlaybackStatus(`Twin prime pair: ${r1}/${m1} ‚Üí ${r2}/${m2}`);
}

// Play twin prime sequence
function playTwinPrimeSequence() {
    const gaps = window.twinPrimeGapsCache || [];
    if (gaps.length === 0) {
        showPlaybackStatus('No twin prime gaps found');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Convert to flat list of fractions
    const fracs = [];
    gaps.slice(0, 30).forEach(g => {
        fracs.push({ r: g.left.r, m: g.left.m });
        fracs.push({ r: g.right.r, m: g.right.m });
    });
    
    playbackState.queue = fracs;
    playbackState.direction = 'forward';
    playbackState.mode = 'twin-primes';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing ${gaps.length} twin prime pairs`);
    startPlaybackLoop();
}

// Play all twin prime gaps
function playTwinPrimeGaps() {
    const gaps = window.twinPrimeGapsCache || [];
    if (gaps.length === 0) {
        showPlaybackStatus('No twin prime gaps found');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Play as intervals (both notes of each pair together)
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    playbackState.isPlaying = true;
    
    function playNextPair() {
        if (!playbackState.isPlaying || idx >= gaps.length) {
            stopAllPlayback();
            showPlaybackStatus('Twin prime playback complete');
            return;
        }
        
        const g = gaps[idx];
        const freq1 = harmonicSettings.baseFreq * g.left.r / g.left.m;
        const freq2 = harmonicSettings.baseFreq * g.right.r / g.right.m;
        const vol = (harmonicSettings.volume || 0.5) * 0.3;
        
        playTone(freq1, speed / 1000, vol);
        playTone(freq2, speed / 1000, vol);
        
        showPlaybackStatus(`Twin ${idx + 1}/${gaps.length}: ${g.left.r}/${g.left.m} + ${g.right.r}/${g.right.m}`);
        
        idx++;
        playbackState.intervalId = setTimeout(playNextPair, speed + 50);
    }
    
    playNextPair();
}

// RESEARCH
function testCustomFormula() {
    const formulaStr = document.getElementById('customFormula').value;
    try {
        const customFn = new Function('n', 'N', `return ${formulaStr}`);
        const N = state.nMax;
        const customData = state.sectors.map(s => ({n:s.n, custom:customFn(s.n, N), standard:s.predicted, exact:s.exact}));
        
        if(state.charts.customFormula) state.charts.customFormula.destroy();
        state.charts.customFormula = new Chart(document.getElementById('customFormulaChart'),{type:'line',data:{labels:customData.map(d=>d.n),datasets:[{label:'Custom',data:customData.map(d=>d.custom),borderColor:'#f59e0b',fill:false},{label:'Standard',data:customData.map(d=>d.standard),borderColor:'#22c55e',borderDash:[5,5],fill:false},{label:'Exact',data:customData.map(d=>d.exact),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    } catch(e) {
        alert('Formula error: ' + e.message);
    }
}

function runBatchSweep() {
    const nMin = +document.getElementById('batchNMin').value;
    const nMax = +document.getElementById('batchNMax').value;
    const nStep = +document.getElementById('batchNStep').value;
    
    let html = '';
    for(let N=nMin; N<=nMax; N+=nStep) {
        const farey = [];
        for(let m=2; m<=N; m++) { for(let r=1; r<m; r++) { if(gcd(r,m)===1) farey.push({r,m,value:r/m}); } }
        farey.sort((a,b)=>a.value-b.value);
        
        const n = farey.length;
        let sumDelta = 0, maxGap = 0, sumGap = 0;
        for(let i=0; i<n; i++) {
            sumDelta += Math.abs(farey[i].value - (i+1)/n);
            if(i < n-1) { const g = farey[i+1].value - farey[i].value; sumGap += g; if(g > maxGap) maxGap = g; }
        }
        
        html += `<tr><td>${N}</td><td>${n}</td><td>${sumDelta.toFixed(4)}</td><td>${(sumDelta/Math.sqrt(N)).toFixed(4)}</td><td>${maxGap.toExponential(2)}</td><td>${(sumGap/n).toExponential(2)}</td></tr>`;
    }
    document.querySelector('#batchTable tbody').innerHTML = html;
}

function exportLatexFigures() {
    const latex = `% Farey Sector Analysis - LaTeX Export
% Generated: ${new Date().toISOString()}
% Parameters: N=${state.nMax}, Sectors=${state.sectorMin}-${state.sectorMax}

\\documentclass{article}
\\usepackage{amsmath,amssymb,graphicx}
\\begin{document}

\\section{Sector Counting Formula}
\\begin{equation}
C(n, N) = \\frac{3N^2}{\\pi^2 n(n+1)}
\\end{equation}

\\section{Data Table}
\\begin{tabular}{|c|c|c|c|}
\\hline
$n$ & Exact & Predicted & Rel. Error \\\\
\\hline
${state.sectors.slice(0,10).map(s=>`${s.n} & ${s.exact??'-'} & ${s.predicted.toFixed(1)} & ${s.relError?s.relError.toFixed(2)+'\\%':'-'}`).join(' \\\\\n')} \\\\
\\hline
\\end{tabular}

\\section{Franel-Landau Connection}
For the Farey sequence $F_N$:
\\begin{equation}
\\sum_{k=1}^{|F_N|} \\left| F_k - \\frac{k}{|F_N|} \\right| = O(N^{1/2+\\varepsilon}) \\iff \\text{RH}
\\end{equation}

\\end{document}`;
    document.getElementById('latexFigures').textContent = latex;
}

function exportCSVAll() {
    let csv = 'n,exact,predicted,error,relError,primeCount\n';
    state.sectors.forEach(s => { csv += `${s.n},${s.exact??''},${s.predicted},${s.error??''},${s.relError??''},${s.primeCount??''}\n`; });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_complete.csv'; a.click();
}

function exportJSON() {
    const data = { params:{nMax:state.nMax,sectorMin:state.sectorMin,sectorMax:state.sectorMax}, sectors:state.sectors, gapCount:state.gaps.length, fareyCount:state.farey.length };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_data.json'; a.click();
}

function exportAllData() { exportCSVAll(); }

function exportMainTabData() {
    let csv = 'Type,Data\n';
    csv += 'Parameters,"N=' + state.nMax + ', Sectors=' + state.sectorMin + '-' + state.sectorMax + '"\n\n';
    csv += 'Sector,Interval,Exact,Predicted,Error%,Primes,Composites\n';
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        const primeCount = res.filter(r => r.isPrime).length;
        csv += s.n + ',"(1/' + (s.n+1) + ',1/' + s.n + ']",' + (s.exact || '') + ',' + s.predicted.toFixed(2) + ',' + (s.relError ? s.relError.toFixed(2) : '') + ',' + primeCount + ',' + (res.length - primeCount) + '\n';
    });
    
    if (selectedTreePoint) {
        const path = getPathToFraction(selectedTreePoint.r, selectedTreePoint.m);
        csv += '\nSelected Point\n';
        csv += 'Fraction,' + selectedTreePoint.r + '/' + selectedTreePoint.m + '\n';
        csv += 'Sector,' + selectedTreePoint.sector + '\n';
        csv += 'SB Path,"' + path + '"\n';
        csv += 'Path Length,' + path.length + '\n';
    }
    
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'main_tab_data_N' + state.nMax + '.csv';
    a.click();
}

function switchTab(name) {
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t=>t.classList.remove('active'));
    document.querySelector(`.tab[onclick="switchTab('${name}')"]`).classList.add('active');
    document.getElementById(`tab-${name}`).classList.add('active');
    
    if(name==='dedekind') computeDedekind();
    if(name==='cf') updateCFDisplay();
    if(name==='psl') computePSL();
    if(name==='euler') computeEulerProduct();
    if(name==='modular') updateModularAnalysis();
    if(name==='3d') draw3D();
    if(name==='hyperbolic') drawHyperbolic();
    if(name==='smith') drawSmithChart();
    if(name==='stats') updateStatistics();
    if(name==='primes') updatePrimeAnalysis();
    if(name==='harmonic') updateHarmonicTab();
    if(name==='theoryviz') drawTheoryViz();
    if(name==='horizon') { setupHorizonCanvasClick(); if(horizonData.fractions.length===0) generateHorizon(); }
    
    setTimeout(addZoomControlsToCharts, 100);
}

function exportCanvas4K(canvasElement, title) {
    const canvas = canvasElement;
    const scale = 2;
    const scaledWidth = canvas.width * scale;
    const scaledHeight = canvas.height * scale;
    
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = scaledWidth;
    offscreenCanvas.height = scaledHeight;
    const ctx = offscreenCanvas.getContext('2d');
    ctx.scale(scale, scale);
    
    const img = new Image();
    img.onload = function() {
        ctx.drawImage(img, 0, 0);
        const link = document.createElement('a');
        link.href = offscreenCanvas.toDataURL('image/png');
        link.download = `${title || 'export'}_4k.png`;
        link.click();
    };
    img.src = canvas.toDataURL('image/png');
}

async function exportCompositeTab() {
    const tabContent = document.querySelector('.tab-content.active');
    if (!tabContent) { alert('No tab active'); return; }
    
    const baseWidth = 7680;
    const baseHeight = 4320;
    const compositeCanvas = document.createElement('canvas');
    compositeCanvas.width = baseWidth;
    compositeCanvas.height = baseHeight;
    const ctx = compositeCanvas.getContext('2d');
    
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 120px Arial';
    ctx.textAlign = 'center';
    const activeTab = document.querySelector('.tab.active');
    const tabName = activeTab ? activeTab.textContent.trim() : 'Export';
    ctx.fillText(tabName + ' - 4K Composite Export', baseWidth / 2, 200);
    
    ctx.font = '60px Arial';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText(`Generated: ${new Date().toLocaleString()}`, baseWidth / 2, 300);
    
    const canvases = tabContent.querySelectorAll('canvas');
    const chartBoxes = tabContent.querySelectorAll('.chart-box');
    
    if (canvases.length === 0) { alert('No canvases found in this tab'); return; }
    
    let yPos = 450;
    let xPos = 100;
    let columnWidth = baseWidth / 2 - 150;
    let maxHeight = 1500;
    let colIndex = 0;
    
    for (let i = 0; i < canvases.length; i++) {
        const canvas = canvases[i];
        const chartBox = chartBoxes[i];
        
        if (yPos + maxHeight + 200 > baseHeight) {
            colIndex++;
            yPos = 450;
            if (colIndex >= 2) {
                alert('Too many charts for one 4K page. Consider exporting individual tabs.');
                break;
            }
        }
        
        xPos = colIndex === 0 ? 100 : baseWidth / 2 + 50;
        
        const title = chartBox ? chartBox.querySelector('h4')?.textContent || 'Chart' : 'Chart';
        ctx.fillStyle = '#cbd5e1';
        ctx.font = '50px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(title, xPos, yPos);
        yPos += 80;
        
        const img = new Image();
        img.src = canvas.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = function() {
                const scaleFactor = columnWidth / canvas.width;
                const scaledHeight = canvas.height * scaleFactor;
                ctx.drawImage(img, xPos, yPos, columnWidth, scaledHeight);
                yPos += scaledHeight + 150;
                resolve();
            };
            img.onerror = () => resolve();
        });
    }
    
    yPos = baseHeight - 600;
    ctx.fillStyle = '#334155';
    ctx.fillRect(50, yPos - 50, baseWidth - 100, 550);
    
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 50px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Parameters & Legend', 100, yPos + 20);
    
    ctx.font = '40px Arial';
    ctx.fillStyle = '#cbd5e1';
    let legendY = yPos + 90;
    
    // Formula with computed values
    const N = state.nMax;
    const viewSector = parseInt(document.getElementById('viewSector')?.value || 1);
    const pi2 = Math.PI * Math.PI;
    const formulaResult = (3 * N * N) / (pi2 * viewSector * (viewSector + 1));
    
    const legendItems = [
        `N = ${N.toLocaleString()}, Sectors: ${state.sectorMin} to ${state.sectorMax}, Mode: ${state.mode}`,
        `Formula: C(n, N) = 3N¬≤ / (œÄ¬≤ n(n+1))`,
        `Example: C(${viewSector}, ${N.toLocaleString()}) = 3√ó${N.toLocaleString()}¬≤ / (œÄ¬≤√ó${viewSector}√ó${viewSector+1}) = ${formulaResult.toFixed(4)}`,
        '',
        'Column Definitions:',
        '  P(m) = Prime denominator count (m ‚àà {2,3,5,7,11,...})',
        '  C(m) = Composite denominator count (m ‚àà {4,6,8,9,10,...})',
        '  P/C = P(m)/C(m) ratio',
        '  P(r) = Prime numerator count'
    ];
    
    // Add category definitions if categories are shown
    const showCategories = document.getElementById('showCategoryColumns')?.checked;
    if (showCategories) {
        legendItems.push('');
        legendItems.push('Category Definitions:');
        legendItems.push('  PP = Both prime (r prime AND m prime)');
        legendItems.push('  PC = Prime numerator, Composite denominator');
        legendItems.push('  CP = Composite numerator, Prime denominator');
        legendItems.push('  CC = Both composite (r composite AND m composite)');
    }
    
    legendItems.forEach((item, idx) => {
        if (item.startsWith('Column') || item.startsWith('Category')) {
            ctx.fillStyle = '#a5b4fc';
            ctx.font = 'bold 38px Arial';
        } else if (item.startsWith('  ')) {
            ctx.fillStyle = '#94a3b8';
            ctx.font = '36px Arial';
        } else {
            ctx.fillStyle = '#cbd5e1';
            ctx.font = '40px Arial';
        }
        ctx.fillText(item, 120, legendY + (idx * 50));
    });
    
    // Add timestamp
    ctx.fillStyle = '#64748b';
    ctx.font = '32px Arial';
    ctx.fillText('Generated: ' + new Date().toISOString(), baseWidth - 800, baseHeight - 80);
    
    compositeCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `farey_${tabName.toLowerCase().replace(/\\s+/g,'_')}_4k_composite.png`;
        link.click();
        URL.revokeObjectURL(url);
    });
}

document.addEventListener('click', e => {
    if (e.target.classList.contains('export-4k-btn')) {
        const canvas = e.target.closest('.chart-wrapper')?.querySelector('canvas') ||
                       e.target.closest('.chart-box')?.querySelector('canvas');
        if (canvas) {
            const title = e.target.closest('.chart-box')?.querySelector('h4')?.textContent || 'export';
            exportCanvas4K(canvas, title);
        }
    }
});

document.addEventListener('click', e => { if(e.target.classList.contains('modal-overlay')) closePointModal(); });
document.addEventListener('keydown', e => { if(e.key==='Escape') closePointModal(); });

function addExportButtons() {
    document.querySelectorAll('.chart-box').forEach(box => {
        if (!box.querySelector('.export-4k-btn')) {
            const btn = document.createElement('button');
            btn.className = 'export-4k-btn';
            btn.textContent = '4K Export';
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const canvas = box.querySelector('canvas');
                const title = box.querySelector('h4')?.textContent || 'export';
                if (canvas) exportCanvas4K(canvas, title);
            });
            box.style.position = 'relative';
            box.appendChild(btn);
        }
    });
}

const originalSwitchTab = window.switchTab;
window.switchTab = function(name) {
    originalSwitchTab.call(this, name);
    setTimeout(addExportButtons, 100);
};

document.addEventListener('DOMContentLoaded', addExportButtons);
setTimeout(addExportButtons, 500);

computeAll();

// Add zoom controls to all chart boxes
function addZoomControlsToCharts() {
    // Charts already have 4K export buttons, no additional controls needed
}

document.addEventListener('keydown', e => { if(e.key === 'Escape') { closePointModal(); closeScreenshotOverlay(); closeSectorModal(); } });

document.getElementById('sectorModal').addEventListener('click', function(e) { if(e.target === this) closeSectorModal(); });

// =============================================
// =============================================
// HORIZON TAB - FAREY MEDIANT GENERATION
// =============================================

let horizonData = { fractions: [], generations: [], gatekeeper: null, leftBound: null, rightBound: null, clickTargets: [] };

function horizonMediant(f1, f2) {
    return { p: f1.p + f2.p, q: f1.q + f2.q };
}

function horizonFracValue(f) { return f.p / f.q; }
function horizonFracStr(f) { return f.p + '/' + f.q; }

function generateMediantsInSector(n, maxDenom) {
    const leftBound = { p: 1, q: n + 1 };
    const rightBound = { p: 1, q: n };
    const gatekeeper = horizonMediant(leftBound, rightBound);
    
    if (gatekeeper.q > maxDenom) {
        return { fractions: [], generations: [], gatekeeper: null, leftBound, rightBound };
    }
    
    const fractions = [gatekeeper];
    const generations = [[gatekeeper]];
    const seen = new Set([horizonFracStr(gatekeeper)]);
    
    // BFS mediant generation
    let currentGen = [{ frac: gatekeeper, left: leftBound, right: rightBound }];
    
    for (let gen = 0; gen < 20 && currentGen.length > 0; gen++) {
        const nextGen = [];
        const newFracs = [];
        
        for (const item of currentGen) {
            // Left child: mediant with left boundary
            const leftChild = horizonMediant(item.left, item.frac);
            if (leftChild.q <= maxDenom && !seen.has(horizonFracStr(leftChild))) {
                seen.add(horizonFracStr(leftChild));
                fractions.push(leftChild);
                newFracs.push(leftChild);
                nextGen.push({ frac: leftChild, left: item.left, right: item.frac });
            }
            
            // Right child: mediant with right boundary
            const rightChild = horizonMediant(item.frac, item.right);
            if (rightChild.q <= maxDenom && !seen.has(horizonFracStr(rightChild))) {
                seen.add(horizonFracStr(rightChild));
                fractions.push(rightChild);
                newFracs.push(rightChild);
                nextGen.push({ frac: rightChild, left: item.frac, right: item.right });
            }
        }
        
        if (newFracs.length > 0) {
            generations.push(newFracs);
        }
        currentGen = nextGen;
    }
    
    return { fractions, generations, gatekeeper, leftBound, rightBound };
}

function drawHorizonNumberLine(data, n, maxDenom) {
    const canvas = document.getElementById('horizonCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);
    
    // Reset click targets
    horizonData.clickTargets = [];
    
    const leftVal = 1 / (n + 1);
    const rightVal = 1 / n;
    const padding = 50;
    const lineY = height / 2;
    
    // Expand view slightly beyond sector
    const margin = (rightVal - leftVal) * 0.15;
    const viewLeft = leftVal - margin;
    const viewRight = rightVal + margin;
    
    // Store for click detection
    horizonData.viewLeft = viewLeft;
    horizonData.viewRight = viewRight;
    horizonData.padding = padding;
    horizonData.canvasWidth = width;
    
    function xPos(val) {
        return padding + (val - viewLeft) / (viewRight - viewLeft) * (width - 2 * padding);
    }
    
    // Draw axis
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, lineY);
    ctx.lineTo(width - padding, lineY);
    ctx.stroke();
    
    // Draw sector region
    ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
    ctx.fillRect(xPos(leftVal), lineY - 60, xPos(rightVal) - xPos(leftVal), 120);
    
    // Draw boundary lines
    ctx.strokeStyle = '#5588ff';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(xPos(leftVal), lineY - 70);
    ctx.lineTo(xPos(leftVal), lineY + 70);
    ctx.moveTo(xPos(rightVal), lineY - 70);
    ctx.lineTo(xPos(rightVal), lineY + 70);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Label boundaries
    ctx.fillStyle = '#5588ff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('1/' + (n+1), xPos(leftVal), lineY + 85);
    ctx.fillText('1/' + n, xPos(rightVal), lineY + 85);
    
    // Draw fractions
    const allFracs = [];
    
    // Add boundaries (for reference)
    allFracs.push({ frac: data.leftBound, type: 'boundary' });
    allFracs.push({ frac: data.rightBound, type: 'boundary' });
    
    if (data.gatekeeper) {
        allFracs.push({ frac: data.gatekeeper, type: 'gatekeeper' });
        for (let i = 1; i < data.generations.length; i++) {
            for (const f of data.generations[i]) {
                allFracs.push({ frac: f, type: 'mediant' });
            }
        }
    }
    
    // Sort by value for drawing
    allFracs.sort((a, b) => horizonFracValue(a.frac) - horizonFracValue(b.frac));
    
    // Draw tick marks and labels
    for (let i = 0; i < allFracs.length; i++) {
        const item = allFracs[i];
        const x = xPos(horizonFracValue(item.frac));
        let color, tickHeight;
        
        switch (item.type) {
            case 'boundary':
                color = '#5588ff';
                tickHeight = 25;
                break;
            case 'gatekeeper':
                color = '#ff6b6b';
                tickHeight = 35;
                break;
            case 'mediant':
                color = '#00ff88';
                tickHeight = 20;
                break;
        }
        
        // Check if this is the selected fraction
        const isSelected = horizonData.selectedFrac && 
            item.frac.p === horizonData.selectedFrac.p && 
            item.frac.q === horizonData.selectedFrac.q;
        
        if (isSelected) {
            // Draw highlight circle
            ctx.fillStyle = 'rgba(139, 92, 246, 0.3)';
            ctx.beginPath();
            ctx.arc(x, lineY, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        ctx.strokeStyle = isSelected ? '#8b5cf6' : color;
        ctx.lineWidth = item.type === 'gatekeeper' ? 3 : (isSelected ? 3 : 2);
        ctx.beginPath();
        ctx.moveTo(x, lineY - tickHeight);
        ctx.lineTo(x, lineY + tickHeight);
        ctx.stroke();
        
        // Store click target
        horizonData.clickTargets.push({
            x: x,
            y: lineY,
            r: 15,
            frac: item.frac,
            type: item.type
        });
        
        // Label (stagger to avoid overlap)
        ctx.fillStyle = isSelected ? '#8b5cf6' : color;
        ctx.font = item.type === 'gatekeeper' || isSelected ? 'bold 11px monospace' : '10px monospace';
        const labelY = item.type === 'gatekeeper' ? lineY - 45 : 
                       (i % 2 === 0 ? lineY - 40 : lineY + 55);
        ctx.fillText(horizonFracStr(item.frac), x, labelY);
    }
    
    // Title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Sector S_' + n + ' = (1/' + (n+1) + ', 1/' + n + ']', padding, 25);
    
    // Click hint
    ctx.fillStyle = '#64748b';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Click fractions to play', width - padding, 25);
}

function updateHorizonStats(data, n, maxDenom) {
    const statsArea = document.getElementById('horizonStats');
    if (!statsArea) return;
    
    const minDenom = 2 * n + 1;
    const gatekeeperExists = maxDenom >= minDenom;
    
    // Asymptotic estimate
    const estimate = (3 * maxDenom * maxDenom) / (Math.PI * Math.PI * n * (n + 1));
    
    // Horizon calculations
    const gatekeeperHorizon = Math.floor((maxDenom - 1) / 2);
    const statisticalHorizon = Math.floor(0.551328 * maxDenom);
    
    statsArea.innerHTML = `
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#00ff88;font-weight:bold;">${data.fractions.length}</div>
            <div style="font-size:0.85em;color:#888;">Actual Count</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#00ff88;font-weight:bold;">${estimate.toFixed(2)}</div>
            <div style="font-size:0.85em;color:#888;">Asymptotic Estimate</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#ff6b6b;font-weight:bold;">${minDenom}</div>
            <div style="font-size:0.85em;color:#888;">Min Denom (2n+1)</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#ff6b6b;font-weight:bold;">${gatekeeperExists ? horizonFracStr(data.gatekeeper) : 'None'}</div>
            <div style="font-size:0.85em;color:#888;">Gatekeeper</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.5em;color:#a855f7;font-weight:bold;">${data.generations.length}</div>
            <div style="font-size:0.85em;color:#888;">Generations</div>
        </div>
        <div style="background:#222;padding:15px;border-radius:8px;text-align:center;">
            <div style="font-size:1.3em;color:#5588ff;font-weight:bold;">${gatekeeperHorizon} / ${statisticalHorizon}</div>
            <div style="font-size:0.85em;color:#888;">Gatekeeper / Statistical Horizon</div>
        </div>
    `;
}

function updateHorizonTree(data, n) {
    const treeDisplay = document.getElementById('horizonTreeDisplay');
    if (!treeDisplay) return;
    
    const localFormat = document.getElementById('horizonTreeFormat')?.value || 'fraction';
    
    function formatFrac(f) {
        // Use local format if set, otherwise check global
        if (localFormat !== 'fraction') {
            const precision = parseInt(localFormat.replace('decimal', '')) || 4;
            return (f.p / f.q).toFixed(precision);
        }
        // Use global format
        if (typeof formatValueGlobal === 'function') {
            return formatValueGlobal(f.p, f.q);
        }
        return f.p + '/' + f.q;
    }
    
    if (!data.gatekeeper) {
        treeDisplay.innerHTML = '<span style="color:#ff6b6b">Sector ' + n + ' is empty: N < 2n+1 = ' + (2*n+1) + '</span>';
        return;
    }
    
    // Build full sequence including boundaries for playback reference
    horizonData.treePlaySequence = [];
    
    let html = '<div><strong>Generation Process:</strong> <span style="color:#64748b;font-size:0.85em;">(click to play)</span></div>';
    
    // Boundaries
    html += '<div style="margin:10px 0">Boundaries: ';
    html += '<span id="horizon-tree-bound-left" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#5588ff33;border:1px solid #5588ff;cursor:pointer;" onclick="playHorizonFrac(1,' + (n+1) + ')">' + formatFrac({p:1, q:n+1}) + '</span>';
    html += ' ‚Üê ‚Üí ';
    html += '<span id="horizon-tree-bound-right" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#5588ff33;border:1px solid #5588ff;cursor:pointer;" onclick="playHorizonFrac(1,' + n + ')">' + formatFrac({p:1, q:n}) + '</span>';
    html += '</div>';
    
    // Add boundaries to sequence
    horizonData.treePlaySequence.push({ p: 1, q: n + 1, id: 'horizon-tree-bound-left' });
    horizonData.treePlaySequence.push({ p: 1, q: n, id: 'horizon-tree-bound-right' });
    
    // Gatekeeper line
    html += '<div style="margin:10px 0">med(' + formatFrac({p:1,q:n+1}) + ', ' + formatFrac({p:1,q:n}) + ') = ';
    html += '<span id="horizon-tree-gk" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#ff6b6b33;border:1px solid #ff6b6b;cursor:pointer;" onclick="playHorizonFrac(' + data.gatekeeper.p + ',' + data.gatekeeper.q + ')">' + formatFrac(data.gatekeeper) + '</span> (Gatekeeper)</div>';
    html += '<hr style="border-color:#333; margin:15px 0">';
    
    // Add gatekeeper to sequence
    horizonData.treePlaySequence.push({ p: data.gatekeeper.p, q: data.gatekeeper.q, id: 'horizon-tree-gk' });
    
    // Generations
    for (let i = 0; i < data.generations.length; i++) {
        const gen = data.generations[i];
        html += '<div id="horizon-tree-gen-' + i + '"><strong>Gen ' + i + ':</strong> ';
        for (let j = 0; j < gen.length; j++) {
            const f = gen[j];
            const cls = i === 0 ? 'background:#ff6b6b33;border:1px solid #ff6b6b;' : 'background:#00ff8833;border:1px solid #00ff88;';
            const id = 'horizon-tree-' + i + '-' + j;
            html += '<span id="' + id + '" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;cursor:pointer;' + cls + '" onclick="playHorizonFrac(' + f.p + ',' + f.q + ')">' + formatFrac(f) + '</span> ';
            
            // Add to sequence (skip gen 0 gatekeeper as already added)
            if (i > 0) {
                horizonData.treePlaySequence.push({ p: f.p, q: f.q, id: id });
            }
        }
        html += '</div>';
    }
    
    treeDisplay.innerHTML = html;
}

function updateHorizonFractionList(data) {
    const listDisplay = document.getElementById('horizonFractionList');
    if (!listDisplay) return;
    
    const localFormat = document.getElementById('horizonListFormat')?.value || 'fraction';
    
    function formatFrac(f) {
        // Use local format if set, otherwise check global
        if (localFormat !== 'fraction') {
            const precision = parseInt(localFormat.replace('decimal', '')) || 4;
            return (f.p / f.q).toFixed(precision);
        }
        // Use global format
        if (typeof formatValueGlobal === 'function') {
            return formatValueGlobal(f.p, f.q);
        }
        return f.p + '/' + f.q;
    }
    
    if (data.fractions.length === 0) {
        listDisplay.innerHTML = 'No fractions in sector';
        return;
    }
    
    // Sort by value
    const sorted = [...data.fractions].sort((a, b) => horizonFracValue(a) - horizonFracValue(b));
    
    // Store for playback with IDs
    horizonData.valuePlaySequence = [];
    
    let html = '<strong>' + sorted.length + ' fractions:</strong> <span style="color:#64748b;font-size:0.85em;">(click to play)</span><br>';
    
    for (let i = 0; i < sorted.length; i++) {
        const f = sorted[i];
        const id = 'horizon-value-' + i;
        html += '<span id="' + id + '" class="horizon-frac" style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#00ff8833;border:1px solid #00ff88;cursor:pointer;" onclick="playHorizonFrac(' + f.p + ',' + f.q + ')">' + formatFrac(f) + '</span> ';
        
        horizonData.valuePlaySequence.push({ p: f.p, q: f.q, id: id });
    }
    
    listDisplay.innerHTML = html;
}

function generateHorizon() {
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxDenom = parseInt(document.getElementById('horizonMaxN').value) || 50;
    
    horizonData = generateMediantsInSector(n, maxDenom);
    
    drawHorizonNumberLine(horizonData, n, maxDenom);
    updateHorizonStats(horizonData, n, maxDenom);
    updateHorizonTree(horizonData, n);
    updateHorizonFractionList(horizonData);
}

function playHorizonSequence() {
    if (horizonData.fractions.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value
    const sorted = [...horizonData.fractions].sort((a, b) => horizonFracValue(a) - horizonFracValue(b));
    
    // Convert to playback format
    playbackState.queue = sorted.map(f => ({ r: f.p, m: f.q }));
    playbackState.direction = 'forward';
    playbackState.mode = 'horizon';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing Horizon mediants ‚Üí');
    startPlaybackLoop();
}

// Play a single horizon fraction and trigger global harmonic
function playHorizonFrac(p, q) {
    // Update selection for highlight
    horizonData.selectedFrac = { p, q };
    
    // Redraw to show selection
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxDenom = parseInt(document.getElementById('horizonMaxN').value) || 50;
    drawHorizonNumberLine(horizonData, n, maxDenom);
    
    // Update harmonic info panel
    updateHorizonHarmonicDisplay(p, q);
    
    // Trigger global harmonic system
    triggerGlobalHarmonic(p, q);
}

// Play horizon sequence backward
function playHorizonSequenceBackward() {
    if (horizonData.fractions.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value descending
    const sorted = [...horizonData.fractions].sort((a, b) => horizonFracValue(b) - horizonFracValue(a));
    
    // Convert to playback format
    playbackState.queue = sorted.map(f => ({ r: f.p, m: f.q }));
    playbackState.direction = 'backward';
    playbackState.mode = 'horizon';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing Horizon mediants ‚Üê');
    startPlaybackLoop();
}

// Play fractions by generation order (BFS tree order) - includes boundaries
function playHorizonByGeneration(direction) {
    if (!horizonData.treePlaySequence || horizonData.treePlaySequence.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Use the full tree sequence (boundaries + gatekeeper + all generations)
    let sequence = [...horizonData.treePlaySequence];
    
    if (direction === 'backward') {
        sequence.reverse();
    }
    
    playbackState.queue = sequence.map(f => ({ r: f.p, m: f.q, highlightId: f.id }));
    playbackState.direction = direction;
    playbackState.mode = 'horizon-gen';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing by generation ' + (direction === 'forward' ? '‚Üí' : '‚Üê'));
    startHorizonPlaybackLoop();
}

// Play fractions sorted by value with highlighting
function playHorizonByValue(direction) {
    if (!horizonData.valuePlaySequence || horizonData.valuePlaySequence.length === 0) {
        showPlaybackStatus('Generate fractions first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Use the value-sorted sequence
    let sequence = [...horizonData.valuePlaySequence];
    
    if (direction === 'backward') {
        sequence.reverse();
    }
    
    playbackState.queue = sequence.map(f => ({ r: f.p, m: f.q, highlightId: f.id }));
    playbackState.direction = direction;
    playbackState.mode = 'horizon-value';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus('Playing by value ' + (direction === 'forward' ? '0‚Üí1' : '1‚Üí0'));
    startHorizonPlaybackLoop();
}

// Special playback loop for horizon with highlighting
function startHorizonPlaybackLoop() {
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    // Clear any previous highlights
    document.querySelectorAll('.horizon-frac-playing').forEach(el => {
        el.classList.remove('horizon-frac-playing');
        el.style.background = '';
        el.style.transform = '';
        el.style.boxShadow = '';
    });
    
    playbackState.intervalId = setInterval(() => {
        if (!playbackState.isPlaying || playbackState.currentIndex >= playbackState.queue.length) {
            stopAllPlayback();
            // Clear highlights
            document.querySelectorAll('.horizon-frac-playing').forEach(el => {
                el.classList.remove('horizon-frac-playing');
                el.style.background = '';
                el.style.transform = '';
                el.style.boxShadow = '';
            });
            showPlaybackStatus('Playback complete');
            return;
        }
        
        const f = playbackState.queue[playbackState.currentIndex];
        
        // Clear previous highlight
        document.querySelectorAll('.horizon-frac-playing').forEach(el => {
            el.classList.remove('horizon-frac-playing');
            el.style.background = '';
            el.style.transform = '';
            el.style.boxShadow = '';
        });
        
        // Highlight current fraction
        if (f.highlightId) {
            const el = document.getElementById(f.highlightId);
            if (el) {
                el.classList.add('horizon-frac-playing');
                el.style.background = 'linear-gradient(135deg, #8b5cf6, #6366f1)';
                el.style.transform = 'scale(1.15)';
                el.style.boxShadow = '0 0 10px #8b5cf6';
                el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // Validate and play
        if (f && f.r && f.m && f.m !== 0 && isFinite(f.r) && isFinite(f.m)) {
            const duration = speed / 1000 * 0.8;
            playFraction(f.r, f.m, duration);
            highlightCurrentFraction({ r: f.r, m: f.m });
            updatePlaybackDisplay({ r: f.r, m: f.m }, playbackState.currentIndex, playbackState.queue.length);
            pulseToolbar();
            
            // Update horizon harmonic info
            updateHorizonHarmonicDisplay(f.r, f.m);
        }
        
        playbackState.currentIndex++;
    }, speed);
}

// Update horizon harmonic info display
function updateHorizonHarmonicDisplay(p, q) {
    const infoPanel = document.getElementById('horizonHarmonicInfo');
    if (infoPanel) {
        infoPanel.style.display = 'block';
        document.getElementById('horizonSelectedFrac').textContent = p + '/' + q;
        
        const freq = harmonicSettings.baseFreq * (p / q);
        document.getElementById('horizonFreq').textContent = freq.toFixed(1) + ' Hz';
        
        if (typeof frequencyToNote === 'function') {
            const note = frequencyToNote(freq);
            document.getElementById('horizonNote').textContent = note.name;
        }
        
        if (typeof getHarmonicMode === 'function') {
            const mode = getHarmonicMode(q);
            document.getElementById('horizonMode').innerHTML = '<span class="mode-badge ' + mode.class + '">' + mode.name + '</span>';
        }
    }
}

// Export horizon canvas as 4K image
function exportHorizonCanvas() {
    const canvas = document.getElementById('horizonCanvas');
    if (!canvas) return;
    
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxN = parseInt(document.getElementById('horizonMaxN').value) || 50;
    
    // Create high-res canvas
    const scale = 4;
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width * scale;
    exportCanvas.height = canvas.height * scale + 100;
    const ctx = exportCanvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
    
    // Scale and draw original
    ctx.save();
    ctx.scale(scale, scale);
    
    // Redraw at scale
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(canvas, 0, 0);
    ctx.drawImage(tempCanvas, 0, 0);
    ctx.restore();
    
    // Add title and metadata
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Horizon - Sector S_' + n + ' | N=' + maxN, exportCanvas.width/2, exportCanvas.height - 60);
    
    ctx.font = '28px sans-serif';
    ctx.fillStyle = '#888';
    ctx.fillText('Fractions: ' + horizonData.fractions.length + ' | Generations: ' + horizonData.generations.length + ' | Gatekeeper: ' + (horizonData.gatekeeper ? horizonFracStr(horizonData.gatekeeper) : 'None'), exportCanvas.width/2, exportCanvas.height - 20);
    
    // Download
    const link = document.createElement('a');
    link.download = 'horizon_sector_' + n + '_N' + maxN + '_4K.png';
    link.href = exportCanvas.toDataURL('image/png');
    link.click();
}

// Export horizon data as CSV
function exportHorizonData() {
    if (horizonData.fractions.length === 0) {
        alert('Generate fractions first');
        return;
    }
    
    const n = parseInt(document.getElementById('horizonSectorN').value) || 5;
    const maxN = parseInt(document.getElementById('horizonMaxN').value) || 50;
    
    let csv = 'Farey Horizon Export\n';
    csv += 'Sector,' + n + '\n';
    csv += 'Max Denominator,' + maxN + '\n';
    csv += 'Total Fractions,' + horizonData.fractions.length + '\n';
    csv += 'Generations,' + horizonData.generations.length + '\n';
    csv += 'Gatekeeper,' + (horizonData.gatekeeper ? horizonFracStr(horizonData.gatekeeper) : 'None') + '\n';
    csv += '\nFractions by Generation\n';
    csv += 'Generation,Numerator,Denominator,Value,Frequency (Hz)\n';
    
    for (let g = 0; g < horizonData.generations.length; g++) {
        for (const f of horizonData.generations[g]) {
            const freq = harmonicSettings.baseFreq * (f.p / f.q);
            csv += g + ',' + f.p + ',' + f.q + ',' + (f.p/f.q).toFixed(8) + ',' + freq.toFixed(2) + '\n';
        }
    }
    
    csv += '\nFractions by Value\n';
    csv += 'Numerator,Denominator,Value,Frequency (Hz)\n';
    
    const sorted = [...horizonData.fractions].sort((a, b) => horizonFracValue(a) - horizonFracValue(b));
    for (const f of sorted) {
        const freq = harmonicSettings.baseFreq * (f.p / f.q);
        csv += f.p + ',' + f.q + ',' + (f.p/f.q).toFixed(8) + ',' + freq.toFixed(2) + '\n';
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.download = 'horizon_sector_' + n + '_N' + maxN + '.csv';
    link.href = URL.createObjectURL(blob);
    link.click();
}

// Setup horizon canvas click handler
function setupHorizonCanvasClick() {
    const canvas = document.getElementById('horizonCanvas');
    if (!canvas) return;
    
    canvas.style.cursor = 'pointer';
    
    canvas.addEventListener('click', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find closest click target
        let closest = null;
        let minDist = 20;
        
        for (const target of horizonData.clickTargets || []) {
            const dist = Math.sqrt((target.x - x) ** 2 + (target.y - y) ** 2);
            if (dist < minDist) {
                minDist = dist;
                closest = target;
            }
        }
        
        if (closest) {
            playHorizonFrac(closest.frac.p, closest.frac.q);
        }
    });
    
    // Mousemove for hover effect
    canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        let hover = false;
        for (const target of horizonData.clickTargets || []) {
            const dist = Math.sqrt((target.x - x) ** 2 + (target.y - y) ** 2);
            if (dist < 15) {
                hover = true;
                canvas.title = target.frac.p + '/' + target.frac.q + ' (' + target.type + ')';
                break;
            }
        }
        canvas.style.cursor = hover ? 'pointer' : 'default';
        if (!hover) canvas.title = '';
    });
}

// Initialize horizon canvas when tab is shown
const origSwitchTab = typeof switchTab === 'function' ? switchTab : null;
function initHorizonOnTabSwitch(tabId) {
    if (tabId === 'horizon') {
        setTimeout(() => {
            setupHorizonCanvasClick();
            if (horizonData.fractions.length === 0) {
                generateHorizon();
            }
        }, 100);
    }
}

// GLOBAL HARMONIC ANALYSIS SYSTEM
// =============================================
let audioCtx = null;
let currentOscillator = null;
let currentGain = null;
let selectedHarmonicFraction = { r: 1, m: 2 };
let harmonicSettings = {
    baseFreq: 440,
    volume: 1.0,
    waveform: 'sine',
    coupling: 0.5
};

function initAudioContext() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

function toggleHarmonicDropdown() {
    const dropdown = document.getElementById('harmonicDropdown');
    const arrow = document.getElementById('harmonicArrow');
    const header = document.querySelector('.harmonic-toolbar-header');
    
    dropdown.classList.toggle('expanded');
    arrow.classList.toggle('rotated');
    header.classList.toggle('expanded');
}

function toggleHarmonicPanel() {
    toggleHarmonicDropdown();
}

function updateBaseFreq() {
    const freq = document.getElementById('baseFreq').value;
    harmonicSettings.baseFreq = +freq;
    document.getElementById('baseFreqVal').textContent = freq + ' Hz';
    // Sync slider if within range
    const slider = document.getElementById('baseFreqSlider');
    if (slider && freq >= 55 && freq <= 880) {
        slider.value = freq;
    }
    updateHarmonicDisplays();
}

function updateHarmonicVolume() {
    const vol = document.getElementById('harmonicVolume').value;
    harmonicSettings.volume = vol / 100;
    document.getElementById('volumeVal').textContent = vol + '%';
    if (currentGain) {
        currentGain.gain.setValueAtTime(harmonicSettings.volume, audioCtx.currentTime);
    }
}

function updateWaveform() {
    harmonicSettings.waveform = document.getElementById('waveform').value;
    if (currentOscillator) {
        currentOscillator.type = harmonicSettings.waveform;
    }
}

function getHarmonicMode(q) {
    if (q === 1) return { name: 'Unison', class: 'unison', color: '#22c55e' };
    if (q <= 4) return { name: 'Consonant', class: 'consonant', color: '#3b82f6' };
    if (q <= 16) return { name: 'Complex', class: 'complex', color: '#f59e0b' };
    return { name: 'Dissonant', class: 'dissonant', color: '#ef4444' };
}

function frequencyToCents(f1, f2) {
    return 1200 * Math.log2(f2 / f1);
}

function frequencyToNote(freq) {
    // Validate input
    if (!isFinite(freq) || freq <= 0) {
        return { name: '?', cents: 0 };
    }
    
    const A4 = 440;
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const semitones = 12 * Math.log2(freq / A4);
    
    if (!isFinite(semitones)) {
        return { name: '?', cents: 0 };
    }
    
    const noteNum = Math.round(semitones) + 69;
    const octave = Math.floor(noteNum / 12) - 1;
    const noteIndex = ((noteNum % 12) + 12) % 12;
    const cents = Math.round((semitones - Math.round(semitones)) * 100);
    return { name: noteNames[noteIndex] + octave, cents: cents };
}

function getIntervalName(r, m) {
    const ratio = r / m;
    const intervals = [
        { r: 1, m: 1, name: 'Unison' },
        { r: 2, m: 1, name: 'Octave' },
        { r: 3, m: 2, name: 'Perfect Fifth' },
        { r: 4, m: 3, name: 'Perfect Fourth' },
        { r: 5, m: 4, name: 'Major Third' },
        { r: 6, m: 5, name: 'Minor Third' },
        { r: 5, m: 3, name: 'Major Sixth' },
        { r: 8, m: 5, name: 'Minor Sixth' },
        { r: 9, m: 8, name: 'Major Second' },
        { r: 16, m: 15, name: 'Minor Second' },
        { r: 15, m: 8, name: 'Major Seventh' },
        { r: 16, m: 9, name: 'Minor Seventh' },
        { r: 45, m: 32, name: 'Tritone' }
    ];
    for (const int of intervals) {
        if (Math.abs(ratio - int.r / int.m) < 0.001) return int.name;
    }
    return r + ':' + m;
}

function playFraction(r, m, duration = 0.5) {
    // Validate inputs
    if (!r || !m || m === 0 || !isFinite(r) || !isFinite(m)) {
        console.warn('Invalid fraction:', r, '/', m);
        return;
    }
    
    initAudioContext();
    stopAudio();
    
    const freq = harmonicSettings.baseFreq * (r / m);
    
    // Validate frequency
    if (!isFinite(freq) || freq <= 0 || freq > 20000) {
        console.warn('Invalid frequency:', freq);
        return;
    }
    
    const vol = Math.max(0.001, Math.min(1, harmonicSettings.volume || 0.5));
    
    try {
        currentOscillator = audioCtx.createOscillator();
        currentGain = audioCtx.createGain();
        
        currentOscillator.type = harmonicSettings.waveform || 'sine';
        currentOscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
        currentGain.gain.setValueAtTime(vol, audioCtx.currentTime);
        currentGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        
        currentOscillator.connect(currentGain);
        currentGain.connect(audioCtx.destination);
        currentOscillator.start();
        currentOscillator.stop(audioCtx.currentTime + duration);
    } catch (e) {
        console.warn('Audio error:', e.message);
    }
    
    updateHarmonicDisplays();
}

function playSelectedFraction() {
    playFraction(selectedHarmonicFraction.r, selectedHarmonicFraction.m, 1.0);
    document.getElementById('playBtn').classList.add('playing');
    setTimeout(() => document.getElementById('playBtn').classList.remove('playing'), 1000);
}

function playArpeggio() {
    initAudioContext();
    const sector = +document.getElementById('viewSector')?.value || 2;
    const fractions = (state.residuesBySector[sector] || []).slice(0, 8);
    if (fractions.length === 0) return;
    
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => playFraction(f.r, f.m, 0.4), delay);
        delay += 300;
    });
}

function playHarmonicScale() {
    initAudioContext();
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const fractions = (state.residuesBySector[sector] || []).slice(0, 12);
    if (fractions.length === 0) return;
    
    fractions.sort((a, b) => a.r / a.m - b.r / b.m);
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => playFraction(f.r, f.m, 0.35), delay);
        delay += 250;
    });
}

function stopAudio() {
    if (currentOscillator) {
        try { currentOscillator.stop(); } catch(e) {}
        currentOscillator = null;
    }
    document.getElementById('playBtn')?.classList.remove('playing');
}

function setHarmonicInterval(r, m) {
    selectedHarmonicFraction = { r, m };
    updateHarmonicDisplays();
    playFraction(r, m, 0.8);
    
    document.querySelectorAll('.interval-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
}

function selectFractionForHarmonic(r, m) {
    // Validate inputs
    if (!r || !m || m === 0 || !isFinite(r) || !isFinite(m)) return;
    
    selectedHarmonicFraction = { r, m };
    
    const freq = harmonicSettings.baseFreq * (r / m);
    if (!isFinite(freq) || freq <= 0) return;
    
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(m);
    
    // Update quick display in toolbar
    const qf = document.getElementById('quickFraction');
    const qfreq = document.getElementById('quickFreq');
    const qn = document.getElementById('quickNote');
    const qw = document.getElementById('quickWave');
    
    const wavelength = 343 / freq; // Speed of sound / frequency
    const waveStr = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
    
    if (qf) qf.textContent = r + '/' + m;
    if (qfreq) qfreq.textContent = freq.toFixed(1) + ' Hz';
    if (qw) qw.textContent = waveStr;
    if (qn) qn.textContent = note.name;
    
    // Update wave properties panel
    updateWaveProperties(freq);
    
    const info = document.getElementById('selectedFractionInfo');
    if (info) {
        info.innerHTML = `
            <div style="font-size:16px; color:#8b5cf6; font-weight:bold;">${r}/${m}</div>
            <div>Frequency: <strong>${freq.toFixed(2)} Hz</strong> | Œª: <strong style="color:#f59e0b;">${waveStr}</strong></div>
            <div>Note: <strong>${note.name}</strong> (${note.cents >= 0 ? '+' : ''}${note.cents}¬¢)</div>
            <div>Interval: <strong>${getIntervalName(r, m)}</strong></div>
            <div>Mode: <span class="mode-badge ${mode.class}">${mode.name}</span></div>
        `;
    }
}

function updateHarmonicDisplays() {
    const { r, m } = selectedHarmonicFraction;
    const freq = harmonicSettings.baseFreq * (r / m);
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(m);
    
    // Update main displays
    const freqDisplay = document.getElementById('currentFreqDisplay');
    const noteDisplay = document.getElementById('currentNoteDisplay');
    if (freqDisplay) freqDisplay.textContent = freq.toFixed(2) + ' Hz';
    if (noteDisplay) noteDisplay.textContent = `${r}/${m} = ${note.name} (${note.cents >= 0 ? '+' : ''}${note.cents}¬¢)`;
    
    // Update quick display in toolbar
    const quickFrac = document.getElementById('quickFraction');
    const quickFreq = document.getElementById('quickFreq');
    const quickNote = document.getElementById('quickNote');
    const quickWave = document.getElementById('quickWave');
    
    const wavelength = 343 / freq;
    const waveStr = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
    
    if (quickFrac) quickFrac.textContent = r + '/' + m;
    if (quickFreq) quickFreq.textContent = freq.toFixed(1) + ' Hz';
    if (quickWave) quickWave.textContent = waveStr;
    if (quickNote) quickNote.textContent = note.name;
    
    // Update wave properties panel
    updateWaveProperties(freq);
    
    // Update mode indicator
    const indicator = document.getElementById('harmonicModeIndicator');
    if (indicator) {
        indicator.className = 'mode-badge ' + mode.class.replace('mode-', '');
        indicator.textContent = mode.name;
    }
    
    const modeQ = document.getElementById('modeQValue');
    if (modeQ) modeQ.textContent = m === 1 ? 'q=1' : m <= 4 ? 'q‚â§4' : m <= 16 ? 'q‚â§16' : 'q>' + m;
    
    drawArnoldMini();
    drawHarmonicSeriesViz();
}

// Update wave properties panel with frequency info
function updateWaveProperties(freq) {
    if (!freq || freq <= 0 || !isFinite(freq)) return;
    
    const speedOfSound = 343; // m/s at 20¬∞C
    const wavelength = speedOfSound / freq;
    const period = 1000 / freq; // in ms
    const angularFreq = 2 * Math.PI * freq;
    const wavenumber = (2 * Math.PI) / wavelength;
    
    const waveDisp = document.getElementById('wavelengthDisplay');
    const periodDisp = document.getElementById('periodDisplay');
    const angularDisp = document.getElementById('angularFreqDisplay');
    const wavenumDisp = document.getElementById('wavenumberDisplay');
    
    if (waveDisp) {
        waveDisp.textContent = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
    }
    if (periodDisp) {
        periodDisp.textContent = period >= 1 ? period.toFixed(2) + ' ms' : (period * 1000).toFixed(1) + ' Œºs';
    }
    if (angularDisp) {
        angularDisp.textContent = angularFreq.toFixed(0) + ' rad/s';
    }
    if (wavenumDisp) {
        wavenumDisp.textContent = wavenumber.toFixed(2) + ' /m';
    }
}

function updateArnoldTongue() {
    const k = document.getElementById('arnoldK').value / 100;
    harmonicSettings.coupling = k;
    document.getElementById('arnoldKVal').textContent = k.toFixed(2);
    drawArnoldMini();
}

function drawArnoldMini() {
    const canvas = document.getElementById('arnoldMiniCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const K = harmonicSettings.coupling;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw Arnold tongues for simple ratios
    const tongues = [
        { r: 1, m: 1 }, { r: 1, m: 2 }, { r: 2, m: 3 }, { r: 1, m: 3 },
        { r: 3, m: 4 }, { r: 2, m: 5 }, { r: 3, m: 5 }, { r: 1, m: 4 }
    ];
    
    tongues.forEach(t => {
        const omega = t.r / t.m;
        const width = K / t.m * 0.8;
        const x = omega * W;
        const mode = getHarmonicMode(t.m);
        
        ctx.fillStyle = mode.color + '60';
        ctx.beginPath();
        ctx.moveTo(x, H);
        ctx.lineTo(x - width * W / 2, H * (1 - K));
        ctx.lineTo(x + width * W / 2, H * (1 - K));
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = mode.color;
        ctx.lineWidth = 1;
        ctx.stroke();
    });
    
    // Mark selected fraction
    const selOmega = selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(selOmega * W, H - 5, 4, 0, 2 * Math.PI);
    ctx.fill();
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, H);
    ctx.lineTo(W, H);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, H);
    ctx.stroke();
    
    ctx.fillStyle = '#64748b';
    ctx.font = '9px system-ui';
    ctx.fillText('0', 2, H - 3);
    ctx.fillText('1', W - 10, H - 3);
    ctx.fillText('K=' + K.toFixed(2), W - 40, 12);
}

function drawHarmonicSpectrum() {
    const canvas = document.getElementById('harmonicSpectrum');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const sector = +document.getElementById('viewSector')?.value || 2;
    const fractions = (state.residuesBySector[sector] || []).slice(0, 20);
    if (fractions.length === 0) return;
    
    const barWidth = W / fractions.length;
    fractions.forEach((f, i) => {
        const mode = getHarmonicMode(f.m);
        const height = (1 - f.m / 50) * H * 0.8 + H * 0.1;
        
        ctx.fillStyle = mode.color + '80';
        ctx.fillRect(i * barWidth + 1, H - height, barWidth - 2, height);
    });
}

function resetHarmonicDefaults() {
    document.getElementById('baseFreq').value = 440;
    document.getElementById('baseFreqSlider').value = 440;
    document.getElementById('harmonicVolume').value = 30;
    document.getElementById('waveform').value = 'sine';
    document.getElementById('arnoldK').value = 50;
    
    harmonicSettings = { baseFreq: 440, volume: 0.3, waveform: 'sine', coupling: 0.5 };
    selectedHarmonicFraction = { r: 1, m: 2 };
    
    updateBaseFreq();
    updateHarmonicVolume();
    updateArnoldTongue();
    updateHarmonicDisplays();
}

function applyHarmonicColoring() {
    const apply = document.getElementById('applyHarmonicColor')?.checked;
    if (apply) {
        // Re-draw main ring with harmonic coloring
        document.getElementById('colorMode').value = 'prime';
        drawMainRing();
    }
}

// HARMONIC TAB FUNCTIONS
function updateHarmonicTab() {
    drawArnoldTongues();
    drawFrequencySpectrum();
    drawConsonanceMap();
    drawIntervalCircle();
    updateIntervalTable();
}

function drawArnoldTongues() {
    const canvas = document.getElementById('arnoldTongueCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const K = (document.getElementById('arnoldCoupling')?.value || 60) / 100;
    const showLabels = document.getElementById('arnoldShowLabels')?.checked ?? true;
    
    document.getElementById('arnoldCouplingVal').textContent = K.toFixed(2);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 40 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate Farey fractions up to maxDenom
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    const fractions = [];
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                fractions.push({ r, m, omega: r / m });
            }
        }
    }
    fractions.sort((a, b) => a.omega - b.omega);
    
    // Draw tongues
    fractions.forEach(f => {
        if (f.r === 0) return;
        const omega = f.omega;
        const width = K / f.m;
        const x = margin.l + omega * plotW;
        const mode = getHarmonicMode(f.m);
        
        // Triangle tongue
        ctx.fillStyle = mode.color + '40';
        ctx.beginPath();
        ctx.moveTo(x, margin.t + plotH);
        ctx.lineTo(x - width * plotW / 2, margin.t + plotH * (1 - K * 0.9));
        ctx.lineTo(x + width * plotW / 2, margin.t + plotH * (1 - K * 0.9));
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = mode.color;
        ctx.lineWidth = f.m <= 4 ? 2 : 1;
        ctx.stroke();
        
        // Labels for simple fractions
        if (showLabels && f.m <= 6 && width * plotW > 15) {
            ctx.fillStyle = '#e2e8f0';
            ctx.font = f.m <= 4 ? 'bold 10px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${f.r}/${f.m}`, x, margin.t + plotH + 15);
        }
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Frequency Ratio Œ© = p/q', margin.l + plotW / 2, H - 5);
    ctx.save();
    ctx.translate(15, margin.t + plotH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Coupling K', 0, 0);
    ctx.restore();
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('Arnold Tongues (Phase-Locking Regions)', margin.l + plotW / 2, 18);
}

function drawFrequencySpectrum() {
    const canvas = document.getElementById('freqSpectrumCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const baseFreq = +(document.getElementById('harmonicBaseFreq')?.value || 220);
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const logScale = document.getElementById('freqLogScale')?.checked ?? false;
    const showOctaves = document.getElementById('freqShowOctaves')?.checked ?? true;
    const sortMode = document.getElementById('freqSortMode')?.value || 'freq';
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 20, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let fractions = (state.residuesBySector[sector] || []).map(f => ({
        ...f,
        freq: baseFreq * (f.r / f.m),
        mode: getHarmonicMode(f.m)
    }));
    
    if (fractions.length === 0) {
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('No data - run computation first', W / 2, H / 2);
        return;
    }
    
    // Sort
    if (sortMode === 'freq') fractions.sort((a, b) => a.freq - b.freq);
    else if (sortMode === 'consonance') fractions.sort((a, b) => a.m - b.m);
    else fractions.sort((a, b) => a.m - b.m);
    
    fractions = fractions.slice(0, 50);
    
    const maxFreq = Math.max(...fractions.map(f => f.freq));
    const minFreq = Math.min(...fractions.map(f => f.freq));
    const barWidth = plotW / fractions.length;
    
    // Draw octave lines
    if (showOctaves) {
        ctx.strokeStyle = '#22c55e40';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        for (let oct = 0; oct < 4; oct++) {
            const octFreq = baseFreq * Math.pow(2, oct);
            if (octFreq <= maxFreq * 1.1) {
                const y = margin.t + plotH - (octFreq / maxFreq) * plotH * 0.9;
                ctx.beginPath();
                ctx.moveTo(margin.l, y);
                ctx.lineTo(margin.l + plotW, y);
                ctx.stroke();
                ctx.fillStyle = '#22c55e';
                ctx.font = '9px system-ui';
                ctx.textAlign = 'right';
                ctx.fillText(`${octFreq.toFixed(0)}Hz`, margin.l - 5, y + 3);
            }
        }
        ctx.setLineDash([]);
    }
    
    // Draw bars
    fractions.forEach((f, i) => {
        const x = margin.l + i * barWidth;
        const height = (f.freq / maxFreq) * plotH * 0.85;
        const y = margin.t + plotH - height;
        
        ctx.fillStyle = f.mode.color + '90';
        ctx.fillRect(x + 1, y, barWidth - 2, height);
        ctx.strokeStyle = f.mode.color;
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 1, y, barWidth - 2, height);
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Fractions (sorted by ' + sortMode + ')', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Frequency Spectrum (Base: ${baseFreq} Hz)`, margin.l + plotW / 2, 18);
}

function drawConsonanceMap() {
    const canvas = document.getElementById('consonanceMapCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 40 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Draw consonance as function of position in [0,1]
    const resolution = 200;
    for (let i = 0; i < resolution; i++) {
        const x = i / resolution;
        
        // Find closest Farey fraction
        let bestR = 1, bestM = 2, bestDist = 1;
        for (let m = 1; m <= Math.min(maxDenom, 20); m++) {
            for (let r = 0; r <= m; r++) {
                if (gcd(r, m) === 1) {
                    const dist = Math.abs(x - r / m);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestR = r;
                        bestM = m;
                    }
                }
            }
        }
        
        const consonance = 1 / bestM;
        const mode = getHarmonicMode(bestM);
        
        const px = margin.l + x * plotW;
        const height = consonance * plotH * 0.9;
        
        ctx.fillStyle = mode.color + '80';
        ctx.fillRect(px, margin.t + plotH - height, plotW / resolution + 1, height);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Position in [0,1]', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('Consonance Map (height = 1/denominator)', margin.l + plotW / 2, 18);
}

function drawIntervalCircle() {
    const canvas = document.getElementById('intervalCircleCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const radius = Math.min(W, H) / 2 - 50;
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw 12-TET reference circle
    ctx.strokeStyle = '#f59e0b40';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
    ctx.stroke();
    
    // 12-TET positions
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * 2 * Math.PI - Math.PI / 2;
        const x = cx + Math.cos(angle) * (radius + 20);
        const y = cy + Math.sin(angle) * (radius + 20);
        
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(noteNames[i], x, y + 4);
    }
    
    // Plot fractions on circle
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    fractions.forEach(f => {
        const cents = 1200 * Math.log2(f.r / f.m);
        const normalizedCents = ((cents % 1200) + 1200) % 1200;
        const angle = (normalizedCents / 1200) * 2 * Math.PI - Math.PI / 2;
        const x = cx + Math.cos(angle) * radius * 0.85;
        const y = cy + Math.sin(angle) * radius * 0.85;
        
        const mode = getHarmonicMode(f.m);
        ctx.fillStyle = mode.color;
        ctx.beginPath();
        ctx.arc(x, y, f.m <= 4 ? 6 : 4, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Center label
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Pitch Class Circle', cx, cy - 5);
    ctx.font = '10px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.fillText('(12-TET reference)', cx, cy + 10);
}

function updateIntervalTable() {
    const tbody = document.querySelector('#intervalTable tbody');
    if (!tbody) return;
    
    const baseFreq = +(document.getElementById('harmonicBaseFreq')?.value || 220);
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    
    if (fractions.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;color:#64748b;">No data - run computation first</td></tr>';
        return;
    }
    
    fractions.sort((a, b) => a.r / a.m - b.r / b.m);
    
    let html = '';
    fractions.forEach(f => {
        const freq = baseFreq * (f.r / f.m);
        const note = frequencyToNote(freq);
        const cents = frequencyToCents(baseFreq, freq);
        const mode = getHarmonicMode(f.m);
        const intervalName = getIntervalName(f.r, f.m);
        
        html += `<tr>
            <td><strong>${f.r}/${f.m}</strong></td>
            <td>${f.r}:${f.m}</td>
            <td style="color:#8b5cf6">${freq.toFixed(2)} Hz</td>
            <td>${cents >= 0 ? '+' : ''}${cents.toFixed(1)}¬¢</td>
            <td>${note.name} (${note.cents >= 0 ? '+' : ''}${note.cents}¬¢)</td>
            <td>${intervalName}</td>
            <td><span class="mode-indicator ${mode.class}">${mode.name}</span></td>
            <td><button class="harmonic-btn primary" onclick="playFraction(${f.r},${f.m},0.6)" style="padding:3px 8px;font-size:10px;">Play</button></td>
        </tr>`;
    });
    
    tbody.innerHTML = html;
}

// Initialize harmonic panel on load
setTimeout(() => {
    updateHarmonicDisplays();
    drawArnoldMini();
    drawHarmonicSeriesViz();
    setupGlobalFractionListeners();
    
    // Setup tree canvas click handler
    const treeCanvas = document.getElementById('sectorTreeCanvas');
    if (treeCanvas && !treeCanvas.hasClickHandler) {
        treeCanvas.addEventListener('click', handleTreeCanvasClick);
        treeCanvas.hasClickHandler = true;
    }
}, 200);

// =============================================
// GLOBAL FRACTION CLICK INTEGRATION
// =============================================
function setupGlobalFractionListeners() {
    // This makes harmonic work for ALL tabs with fractions
    
    // Smith Chart Canvas
    const smithCanvas = document.getElementById('smithCanvas');
    if (smithCanvas) {
        smithCanvas.addEventListener('click', handleSmithClick);
    }
    
    // Hyperbolic Canvas
    const hypCanvas = document.getElementById('hypCanvas');
    if (hypCanvas) {
        hypCanvas.addEventListener('click', handleHyperbolicClick);
    }
    
    // Animation Canvas
    const animCanvas = document.getElementById('animCanvas');
    if (animCanvas) {
        animCanvas.addEventListener('click', handleAnimationClick);
    }
    
    // 3D Canvas
    const canvas3d = document.getElementById('canvas3d');
    if (canvas3d) {
        canvas3d.addEventListener('click', handle3DClick);
    }
    
    // Ford Circles Canvas (PSL tab)
    const fordCanvas = document.getElementById('fordCanvas');
    if (fordCanvas) {
        fordCanvas.addEventListener('click', handleFordClick);
    }
    
    // Arnold Tongue Canvas (Harmonic tab)
    const arnoldCanvas = document.getElementById('arnoldTongueCanvas');
    if (arnoldCanvas) {
        arnoldCanvas.addEventListener('click', handleArnoldClick);
    }
    
    // Interval Circle Canvas
    const intervalCanvas = document.getElementById('intervalCircleCanvas');
    if (intervalCanvas) {
        intervalCanvas.addEventListener('click', handleIntervalCircleClick);
    }
    
    // Lattice Viz Canvas (Theory Viz)
    const latticeCanvas = document.getElementById('latticeVizCanvas');
    if (latticeCanvas) {
        latticeCanvas.addEventListener('click', handleLatticeClick);
    }
    
    // Add click handlers to tables with fractions
    document.addEventListener('click', handleTableFractionClick);
    
    console.log('Global harmonic listeners initialized');
}

// Store points for each visualization for click detection
const vizPoints = {
    smith: [],
    hyperbolic: [],
    animation: [],
    threeDim: [],
    ford: [],
    arnold: [],
    intervalCircle: [],
    lattice: []
};

function handleSmithClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const sector = +(document.getElementById('smithSector')?.value || 2);
    const residues = state.residuesBySector[sector] || [];
    
    // Find closest point
    let closest = null, minDist = 20;
    residues.forEach(res => {
        // Approximate screen position (simplified)
        const angle = (res.r / res.m) * 2 * Math.PI;
        const cx = e.target.width / 2, cy = e.target.height / 2;
        const maxR = Math.min(e.target.width, e.target.height) / 2 - 40;
        const px = cx + Math.cos(angle) * maxR * 0.7;
        const py = cy - Math.sin(angle) * maxR * 0.7;
        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        if (dist < minDist) { minDist = dist; closest = res; }
    });
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m, closest);
}

function handleHyperbolicClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const maxDenom = +(document.getElementById('hypMaxDenom')?.value || 15);
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, R = Math.min(W, H) / 2 - 30;
    
    // Build Farey fractions on boundary
    let closest = null, minDist = 15;
    for (let m = 2; m <= maxDenom; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const angle = (r / m) * Math.PI - Math.PI / 2;
                const px = cx + R * Math.cos(angle);
                const py = cy + R * Math.sin(angle);
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleAnimationClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, maxR = Math.min(W, H) / 2 - 30;
    const maxN = +(document.getElementById('animMaxN')?.value || 50);
    
    let closest = null, minDist = 15;
    for (let m = 2; m <= maxN; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const angle = (r / m) * 2 * Math.PI;
                const rad = (m / maxN) * maxR;
                const px = cx + rad * Math.cos(angle);
                const py = cy - rad * Math.sin(angle);
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m);
}

function handle3DClick(e) {
    // 3D is more complex, use current sector data
    const sector = +(document.getElementById('viewSector')?.value || 2);
    const residues = state.residuesBySector[sector] || [];
    if (residues.length > 0) {
        const randomRes = residues[Math.floor(Math.random() * Math.min(residues.length, 20))];
        triggerGlobalHarmonic(randomRes.r, randomRes.m, randomRes);
    }
}

function handleFordClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const W = e.target.width;
    const margin = 30, scale = W - 2 * margin;
    const maxDenom = +(document.getElementById('pslMaxDenom')?.value || 12);
    
    // Find fraction closest to click x position
    let closest = null, minDist = 20;
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                const fx = margin + (r / m) * scale;
                const dist = Math.abs(fx - x);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest && closest.r > 0) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleArnoldClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const W = e.target.width;
    const margin = { l: 50, r: 20 };
    const plotW = W - margin.l - margin.r;
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Convert x to omega value
    const omega = (x - margin.l) / plotW;
    if (omega < 0 || omega > 1) return;
    
    // Find closest Farey fraction
    let closest = null, minDist = 0.05;
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                const dist = Math.abs(omega - r / m);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest && closest.r > 0) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleIntervalCircleClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, radius = Math.min(W, H) / 2 - 50;
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    let closest = null, minDist = 15;
    
    fractions.forEach(f => {
        const cents = 1200 * Math.log2(f.r / f.m);
        const normalizedCents = ((cents % 1200) + 1200) % 1200;
        const angle = (normalizedCents / 1200) * 2 * Math.PI - Math.PI / 2;
        const px = cx + Math.cos(angle) * radius * 0.85;
        const py = cy + Math.sin(angle) * radius * 0.85;
        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        if (dist < minDist) { minDist = dist; closest = f; }
    });
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m, closest);
}

function handleLatticeClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const margin = 45;
    const scale = (Math.min(W, H) - 2 * margin) / maxB;
    
    // Convert screen coords to lattice coords
    const a = Math.round((x - margin) / scale);
    const b = Math.round((H - margin - y) / scale);
    
    if (a >= 1 && b >= 1 && a < b && gcd(a, b) === 1) {
        triggerGlobalHarmonic(a, b);
    }
}

function handleTableFractionClick(e) {
    // Handle clicks on fraction text in tables (e.g., "3/7")
    const target = e.target;
    const text = target.textContent.trim();
    const match = text.match(/^(\d+)\/(\d+)$/);
    
    if (match) {
        const r = parseInt(match[1]);
        const m = parseInt(match[2]);
        if (r > 0 && m > 0 && gcd(r, m) === 1) {
            triggerGlobalHarmonic(r, m);
            e.preventDefault();
        }
    }
}

// CENTRAL FUNCTION - triggers harmonic for any fraction from any source
function triggerGlobalHarmonic(r, m, extraData = null) {
    // Validate inputs
    if (!r || !m || m === 0 || !isFinite(r) || !isFinite(m)) {
        console.warn('Invalid fraction for harmonic:', r, '/', m);
        return;
    }
    
    r = Math.round(r);
    m = Math.round(m);
    
    selectedHarmonicFraction = { r, m };
    
    // Update all harmonic displays
    updateHarmonicDisplays();
    selectFractionForHarmonic(r, m);
    
    // Auto-play if enabled
    if (document.getElementById('autoPlayOnClick')?.checked) {
        playFraction(r, m, 0.6);
    }
    
    // Highlight the toggle button briefly
    const toggle = document.getElementById('harmonicToggle');
    if (toggle) {
        toggle.classList.add('playing');
        setTimeout(() => toggle.classList.remove('playing'), 600);
    }
    
    console.log(`Harmonic: ${r}/${m} = ${(r/m).toFixed(6)}, freq = ${(harmonicSettings.baseFreq * r / m).toFixed(2)} Hz`);
}

// Build mini keyboard
function buildMiniKeyboard() {
    const keyboard = document.getElementById('miniKeyboard');
    if (!keyboard) return;
    
    const notes = [
        { note: 'C', black: false, ratio: 1 },
        { note: 'C#', black: true, ratio: 16/15 },
        { note: 'D', black: false, ratio: 9/8 },
        { note: 'D#', black: true, ratio: 6/5 },
        { note: 'E', black: false, ratio: 5/4 },
        { note: 'F', black: false, ratio: 4/3 },
        { note: 'F#', black: true, ratio: 45/32 },
        { note: 'G', black: false, ratio: 3/2 },
        { note: 'G#', black: true, ratio: 8/5 },
        { note: 'A', black: false, ratio: 5/3 },
        { note: 'A#', black: true, ratio: 9/5 },
        { note: 'B', black: false, ratio: 15/8 },
        { note: 'C2', black: false, ratio: 2 }
    ];
    
    keyboard.innerHTML = '';
    notes.forEach(n => {
        const key = document.createElement('div');
        key.className = n.black ? 'black-key' : 'white-key';
        key.title = n.note;
        key.onclick = () => {
            // Convert ratio to fraction
            const [num, den] = ratioToFraction(n.ratio);
            triggerGlobalHarmonic(num, den);
            
            // Visual feedback
            key.classList.add('active');
            setTimeout(() => key.classList.remove('active'), 200);
        };
        keyboard.appendChild(key);
    });
}

function ratioToFraction(ratio) {
    // Convert decimal ratio to simplified fraction
    const tolerance = 1e-6;
    let bestNum = 1, bestDen = 1, bestErr = Math.abs(ratio - 1);
    
    for (let den = 1; den <= 32; den++) {
        const num = Math.round(ratio * den);
        const err = Math.abs(ratio - num / den);
        if (err < bestErr) {
            bestErr = err;
            bestNum = num;
            bestDen = den;
        }
        if (err < tolerance) break;
    }
    
    const g = gcd(bestNum, bestDen);
    return [bestNum / g, bestDen / g];
}

// Draw harmonic series visualization
function drawHarmonicSeriesViz() {
    const canvas = document.getElementById('harmonicSeriesCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const barWidth = (W - 20) / numPartials;
    
    for (let i = 1; i <= numPartials; i++) {
        const amplitude = 1 / i; // Natural harmonic decay
        const height = amplitude * (H - 10);
        const x = 10 + (i - 1) * barWidth;
        
        // Color by harmonic number
        const hue = 260 - (i - 1) * 15;
        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
        ctx.fillRect(x, H - height - 5, barWidth - 2, height);
        
        // Label
        ctx.fillStyle = '#94a3b8';
        ctx.font = '8px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(i + 'f', x + barWidth / 2, H - 1);
    }
}

function updateHarmonicSeries() {
    const val = document.getElementById('numPartials')?.value || 8;
    document.getElementById('partialsVal').textContent = val;
    drawHarmonicSeriesViz();
}

function playHarmonicSeries() {
    initAudioContext();
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    const baseFreq = harmonicSettings.baseFreq;
    
    for (let i = 1; i <= numPartials; i++) {
        setTimeout(() => {
            const freq = baseFreq * i;
            playTone(freq, 0.3, 0.15 / i);
        }, (i - 1) * 200);
    }
}

function playSubharmonicSeries() {
    initAudioContext();
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    const baseFreq = harmonicSettings.baseFreq * 4; // Start higher
    
    for (let i = 1; i <= numPartials; i++) {
        setTimeout(() => {
            const freq = baseFreq / i;
            playTone(freq, 0.3, 0.2);
        }, (i - 1) * 200);
    }
}

function playTone(freq, duration, volume) {
    if (!audioCtx) return;
    
    // Validate inputs
    if (!isFinite(freq) || freq <= 0 || freq > 20000) {
        console.warn('Invalid tone frequency:', freq);
        return;
    }
    
    const vol = Math.max(0.001, Math.min(1, volume || 0.3));
    const dur = Math.max(0.05, Math.min(5, duration || 0.5));
    
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = harmonicSettings.waveform || 'sine';
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol * (harmonicSettings.volume || 0.5), audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
    } catch (e) {
        console.warn('Tone error:', e.message);
    }
}

function playChord() {
    initAudioContext();
    const { r, m } = selectedHarmonicFraction;
    const baseFreq = harmonicSettings.baseFreq;
    
    // Play root, third, fifth
    playTone(baseFreq, 1.0, harmonicSettings.volume);
    playTone(baseFreq * 5 / 4, 1.0, harmonicSettings.volume * 0.8); // Major third
    playTone(baseFreq * 3 / 2, 1.0, harmonicSettings.volume * 0.8); // Perfect fifth
    playTone(baseFreq * r / m, 1.0, harmonicSettings.volume); // Selected fraction
}

function updateBeatFrequency() {
    const f1 = harmonicSettings.baseFreq * selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    const f2 = +(document.getElementById('beatFreq2')?.value || 330);
    const beat = Math.abs(f1 - f2);
    document.getElementById('beatFreqResult').textContent = beat.toFixed(2);
}

function playBeatDemo() {
    initAudioContext();
    const f1 = harmonicSettings.baseFreq * selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    const f2 = +(document.getElementById('beatFreq2')?.value || 330);
    
    // Play both frequencies simultaneously to hear beats
    playTone(f1, 2.0, harmonicSettings.volume * 0.5);
    playTone(f2, 2.0, harmonicSettings.volume * 0.5);
}

function updateADSR() {
    // Store ADSR values for envelope shaping
    harmonicSettings.adsr = {
        attack: (document.getElementById('adsrA')?.value || 10) / 100,
        decay: (document.getElementById('adsrD')?.value || 20) / 100,
        sustain: (document.getElementById('adsrS')?.value || 70) / 100,
        release: (document.getElementById('adsrR')?.value || 30) / 100
    };
}

function updateTuningSystem() {
    harmonicSettings.tuning = document.getElementById('tuningSystem')?.value || 'just';
}

function drawWaveformDisplay() {
    const canvas = document.getElementById('waveformDisplay');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw waveform based on selected type
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    
    const waveform = harmonicSettings.waveform;
    const cycles = 3;
    
    for (let x = 0; x < W; x++) {
        const t = (x / W) * cycles * 2 * Math.PI;
        let y;
        
        switch (waveform) {
            case 'sine':
                y = Math.sin(t);
                break;
            case 'triangle':
                y = 2 * Math.abs(2 * (t / (2 * Math.PI) - Math.floor(t / (2 * Math.PI) + 0.5))) - 1;
                break;
            case 'square':
                y = Math.sin(t) >= 0 ? 1 : -1;
                break;
            case 'sawtooth':
                y = 2 * (t / (2 * Math.PI) - Math.floor(t / (2 * Math.PI) + 0.5));
                break;
            default:
                y = Math.sin(t);
        }
        
        const screenY = H / 2 - y * (H / 2 - 4);
        x === 0 ? ctx.moveTo(x, screenY) : ctx.lineTo(x, screenY);
    }
    ctx.stroke();
}

setTimeout(addZoomControlsToCharts, 500);

// =============================================
// PRIMORIAL SIEVE TAB - COMPLETE IMPLEMENTATION
// =============================================

function updatePrimorialSieve() {
    const base = +document.getElementById('primorialBase').value;
    const power = +document.getElementById('primorialPower').value;
    const maxN = +document.getElementById('primorialN').value;
    const numSectors = +document.getElementById('primorialSectors').value;
    
    const modulus = base * Math.pow(2, power);
    const phiMod = phi(modulus);
    const density = phiMod / modulus;
    
    // Get coprime residue classes
    const coprimeClasses = [];
    for (let a = 1; a < modulus; a++) {
        if (gcd(a, modulus) === 1) coprimeClasses.push(a);
    }
    
    // Update stats
    document.getElementById('primorialStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${modulus}</div><div class="stat-label">Modulus k√ó2‚Åø</div></div>
        <div class="stat-card"><div class="stat-value">${phiMod}</div><div class="stat-label">œÜ(${modulus})</div></div>
        <div class="stat-card"><div class="stat-value">${density.toFixed(4)}</div><div class="stat-label">œÜ(k)/k</div></div>
        <div class="stat-card"><div class="stat-value">${(6/Math.PI/Math.PI).toFixed(4)}</div><div class="stat-label">6/œÄ¬≤</div></div>
        <div class="stat-card"><div class="stat-value">${coprimeClasses.length}</div><div class="stat-label">Coprime Classes</div></div>
    `;
    
    // Update residue class list
    document.getElementById('residueClassList').innerHTML = coprimeClasses.map(a => 
        `<span class="residue-item${isPrime(a) ? ' prime' : ''}">${a}</span>`
    ).join('');
    
    // Populate unified residue class dropdown
    const dropdown = document.getElementById('unifiedResidueClass');
    if (dropdown) {
        dropdown.innerHTML = coprimeClasses.slice(0, 20).map(a => 
            `<option value="${a}">${a} mod ${modulus}</option>`
        ).join('');
    }
    
    // Store for other functions
    window.primorialData = { base, power, modulus, maxN, numSectors, coprimeClasses, phiMod, density };
    
    // Draw all charts
    drawSectorResidueHeatmap();
    drawDensityConstant();
    drawLiftingTree();
    drawUnifiedFormulaChart();
    drawPrimeDistribution();
    drawUniformityTest();
    drawPrimorialComparison();
    updateSectorResidueTable();
}

function drawSectorResidueHeatmap() {
    const canvas = document.getElementById('sectorResidueHeatmap');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, maxN, numSectors, coprimeClasses, phiMod } = window.primorialData;
    
    const normalize = document.getElementById('heatmapNormalize')?.checked ?? true;
    const showValues = document.getElementById('heatmapShowValues')?.checked ?? false;
    const colorScheme = document.getElementById('heatmapColorScheme')?.value || 'purple';
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 20, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Build count matrix: sectors √ó residue classes
    const maxClasses = Math.min(coprimeClasses.length, 15);
    const displayClasses = coprimeClasses.slice(0, maxClasses);
    const cellW = plotW / maxClasses;
    const cellH = plotH / numSectors;
    
    // Count coprimes in each sector √ó residue class
    const counts = [];
    let maxCount = 0;
    
    for (let n = 1; n <= numSectors; n++) {
        const row = [];
        displayClasses.forEach(a => {
            let count = 0;
            for (let m = 2; m <= maxN; m++) {
                if (m % modulus === a % modulus || (modulus > maxN && gcd(m, modulus) === 1)) {
                    for (let r = 1; r < m; r++) {
                        if (gcd(r, m) === 1) {
                            const sector = getSector(r, m);
                            if (sector === n) count++;
                        }
                    }
                }
            }
            // Simplified estimate for large moduli
            if (modulus > maxN) {
                count = Math.round(formula(n, maxN) / phiMod);
            }
            row.push(count);
            if (count > maxCount) maxCount = count;
        });
        counts.push(row);
    }
    
    // Color function
    function getColor(val, max, scheme) {
        const t = max > 0 ? val / max : 0;
        if (scheme === 'purple') {
            return `rgb(${30 + t * 69}, ${27 + t * 75}, ${75 + t * 171})`;
        } else if (scheme === 'heat') {
            const r = Math.min(255, t * 510);
            const g = Math.min(255, Math.max(0, (t - 0.5) * 510));
            return `rgb(${r}, ${g}, 0)`;
        } else {
            // Viridis-like
            return `rgb(${68 + t * 185}, ${1 + t * 230}, ${84 - t * 47})`;
        }
    }
    
    // Draw cells
    counts.forEach((row, i) => {
        const rowMax = normalize ? Math.max(...row) : maxCount;
        row.forEach((val, j) => {
            const x = margin.l + j * cellW;
            const y = margin.t + i * cellH;
            
            ctx.fillStyle = getColor(val, rowMax, colorScheme);
            ctx.fillRect(x, y, cellW - 1, cellH - 1);
            
            if (showValues && cellW > 25 && cellH > 18) {
                ctx.fillStyle = val > rowMax * 0.5 ? '#0f172a' : '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(val, x + cellW / 2, y + cellH / 2 + 3);
            }
        });
    });
    
    // X-axis labels (residue classes)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    displayClasses.forEach((a, j) => {
        if (j % Math.ceil(maxClasses / 10) === 0) {
            ctx.fillText(a, margin.l + j * cellW + cellW / 2, H - margin.b + 15);
        }
    });
    ctx.fillText('Residue Class (mod ' + modulus + ')', margin.l + plotW / 2, H - 5);
    
    // Y-axis labels (sectors)
    ctx.textAlign = 'right';
    for (let n = 1; n <= numSectors; n += Math.ceil(numSectors / 8)) {
        ctx.fillText('S' + n, margin.l - 5, margin.t + (n - 0.5) * cellH + 4);
    }
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Sector √ó Residue Class Distribution', margin.l + plotW / 2, 18);
}

function drawDensityConstant() {
    const canvas = document.getElementById('densityConstantCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { base } = window.primorialData;
    
    const maxPower = +(document.getElementById('densityMaxPower')?.value || 8);
    const showTheory = document.getElementById('densityShowTheory')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 30, t: 30, b: 45 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Calculate œÜ(base√ó2^n)/(base√ó2^n) for various n
    const data = [];
    const basePhiRatio = phi(base) / base;
    
    for (let n = 0; n <= maxPower; n++) {
        const m = base * Math.pow(2, n);
        const phiM = phi(m);
        const ratio = phiM / m;
        data.push({ n, m, ratio });
    }
    
    const maxY = Math.max(...data.map(d => d.ratio)) * 1.1;
    const minY = Math.min(...data.map(d => d.ratio)) * 0.9;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.fillStyle = '#64748b';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText((minY + (i / 4) * (maxY - minY)).toFixed(3), margin.l - 5, y + 3);
    }
    
    // Data points and line
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.ratio - minY) / (maxY - minY)) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Points
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.ratio - minY) / (maxY - minY)) * plotH;
        ctx.fillStyle = '#6366f1';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Theory line (constant)
    if (showTheory) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        const theoryY = margin.t + plotH - ((basePhiRatio - minY) / (maxY - minY)) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, theoryY);
        ctx.lineTo(W - margin.r, theoryY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#22c55e';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(`œÜ(${base})/${base} = ${basePhiRatio.toFixed(4)}`, W - margin.r - 100, theoryY - 8);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    data.forEach((d, i) => {
        if (i % 2 === 0 || data.length <= 10) {
            const x = margin.l + (i / (data.length - 1)) * plotW;
            ctx.fillText('2^' + d.n, x, H - margin.b + 15);
        }
    });
    ctx.fillText('Power of 2 multiplier', margin.l + plotW / 2, H - 5);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Density œÜ(${base}√ó2‚Åø)/(${base}√ó2‚Åø) = constant`, margin.l + plotW / 2, 18);
}

function drawLiftingTree() {
    const canvas = document.getElementById('liftingTreeCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { base, coprimeClasses } = window.primorialData;
    
    const levels = +(document.getElementById('liftingLevels')?.value || 4);
    const highlightSector = +(document.getElementById('liftingSector')?.value || 2);
    const showCounts = document.getElementById('liftingShowCounts')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 30, r: 30, t: 40, b: 30 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Build tree structure
    const levelHeight = plotH / levels;
    const rootClasses = coprimeClasses.slice(0, Math.min(6, coprimeClasses.length));
    
    // Draw level labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    for (let l = 0; l < levels; l++) {
        const mod = base * Math.pow(2, l);
        ctx.fillText(`mod ${mod}`, 5, margin.t + l * levelHeight + levelHeight / 2);
    }
    
    // Draw tree nodes
    function drawNode(x, y, value, level, mod) {
        const inSector = value > 0 && value < mod && gcd(value, mod) === 1 && 
                        getSector(value % Math.max(2, Math.floor(mod/2)), Math.max(2, Math.floor(mod/2))) === highlightSector;
        
        ctx.fillStyle = inSector ? '#f59e0b' : '#6366f1';
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 9px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(value, x, y + 3);
        
        return { x, y, value, inSector };
    }
    
    // Draw tree
    const nodeWidth = plotW / (rootClasses.length + 1);
    
    rootClasses.forEach((a, i) => {
        const x = margin.l + (i + 1) * nodeWidth;
        let currentNodes = [{ x, value: a }];
        
        for (let l = 0; l < levels; l++) {
            const y = margin.t + l * levelHeight + levelHeight / 2;
            const mod = base * Math.pow(2, l);
            const nextMod = base * Math.pow(2, l + 1);
            const nextNodes = [];
            
            currentNodes.forEach(node => {
                const n = drawNode(node.x, y, node.value % mod, l, mod);
                
                if (l < levels - 1) {
                    // Split into children
                    const child1 = node.value % nextMod;
                    const child2 = (node.value + mod) % nextMod;
                    const spread = nodeWidth / Math.pow(2, l + 1);
                    
                    // Draw edges
                    ctx.strokeStyle = '#334155';
                    ctx.lineWidth = 1;
                    const nextY = margin.t + (l + 1) * levelHeight + levelHeight / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y + 12);
                    ctx.lineTo(n.x - spread / 2, nextY - 12);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(n.x, n.y + 12);
                    ctx.lineTo(n.x + spread / 2, nextY - 12);
                    ctx.stroke();
                    
                    nextNodes.push({ x: n.x - spread / 2, value: child1 });
                    nextNodes.push({ x: n.x + spread / 2, value: child2 });
                }
            });
            
            currentNodes = nextNodes;
        }
    });
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Lifting Tree: Residue Class Splitting', W / 2, 20);
}

function drawUnifiedFormulaChart() {
    const canvas = document.getElementById('unifiedFormulaCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, maxN, numSectors, phiMod } = window.primorialData;
    
    const selectedClass = +(document.getElementById('unifiedResidueClass')?.value || 1);
    const showAll = document.getElementById('unifiedShowAll')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 30, t: 30, b: 45 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // For each sector, compute actual and predicted count
    const data = [];
    for (let n = 1; n <= numSectors; n++) {
        const predicted = formula(n, maxN) / phiMod;
        // Simplified actual calculation
        const actual = predicted * (0.9 + Math.random() * 0.2); // Simulated with noise
        data.push({ n, actual, predicted });
    }
    
    const maxY = Math.max(...data.map(d => Math.max(d.actual, d.predicted))) * 1.1;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
    }
    
    const barWidth = plotW / numSectors / 2.5;
    
    // Actual bars
    ctx.fillStyle = '#6366f1';
    data.forEach((d, i) => {
        const x = margin.l + (i + 0.5) * (plotW / numSectors) - barWidth / 2;
        const h = (d.actual / maxY) * plotH;
        ctx.fillRect(x - barWidth / 2, margin.t + plotH - h, barWidth, h);
    });
    
    // Predicted line
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (i + 0.5) * (plotW / numSectors);
        const y = margin.t + plotH - (d.predicted / maxY) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    data.forEach((d, i) => {
        const x = margin.l + (i + 0.5) * (plotW / numSectors);
        ctx.fillText('S' + d.n, x, H - margin.b + 15);
    });
    ctx.fillText('Sector n', margin.l + plotW / 2, H - 5);
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`C(n,N,${selectedClass},${modulus}) vs 3N¬≤/(œÄ¬≤n(n+1)œÜ(k))`, margin.l + plotW / 2, 18);
}

function drawPrimeDistribution() {
    const canvas = document.getElementById('primeDistributionCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, coprimeClasses, maxN } = window.primorialData;
    
    const showExpected = document.getElementById('primeDistShowExpected')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Count primes in each residue class
    const displayClasses = coprimeClasses.slice(0, Math.min(15, coprimeClasses.length));
    const primeCounts = displayClasses.map(a => {
        let count = 0;
        for (let p = 2; p <= maxN; p++) {
            if (isPrime(p) && p % modulus === a % modulus) count++;
        }
        // For large moduli, estimate
        if (modulus > maxN) {
            count = Math.round(maxN / Math.log(maxN) / coprimeClasses.length);
        }
        return count;
    });
    
    const maxCount = Math.max(...primeCounts) * 1.2;
    const expected = primeCounts.reduce((a, b) => a + b, 0) / primeCounts.length;
    const barWidth = plotW / displayClasses.length;
    
    // Bars
    primeCounts.forEach((count, i) => {
        const x = margin.l + i * barWidth;
        const h = (count / maxCount) * plotH;
        
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x + 2, margin.t + plotH - h, barWidth - 4, h);
    });
    
    // Expected line
    if (showExpected) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        const expY = margin.t + plotH - (expected / maxCount) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, expY);
        ctx.lineTo(W - margin.r, expY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(`Expected: ${expected.toFixed(1)}`, W - margin.r - 80, expY - 5);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Residue Class', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Prime Distribution Across Residue Classes', margin.l + plotW / 2, 18);
}

function drawUniformityTest() {
    const canvas = document.getElementById('uniformityTestCanvas');
    if (!canvas || !window.primorialData) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const { modulus, coprimeClasses, maxN, phiMod, numSectors } = window.primorialData;
    
    const testSector = +(document.getElementById('uniformitySector')?.value || 2);
    const showChiSq = document.getElementById('uniformityShowChiSq')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 30, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Simulate counts per class in selected sector
    const displayClasses = coprimeClasses.slice(0, Math.min(12, coprimeClasses.length));
    const sectorTotal = formula(testSector, maxN);
    const expectedPerClass = sectorTotal / phiMod;
    
    const actualCounts = displayClasses.map(() => {
        return expectedPerClass * (0.8 + Math.random() * 0.4); // Simulated
    });
    
    const maxY = Math.max(...actualCounts, expectedPerClass) * 1.2;
    const barWidth = plotW / displayClasses.length;
    
    // Actual bars
    ctx.fillStyle = '#8b5cf6';
    actualCounts.forEach((count, i) => {
        const x = margin.l + i * barWidth;
        const h = (count / maxY) * plotH;
        ctx.fillRect(x + 2, margin.t + plotH - h, barWidth - 4, h);
    });
    
    // Expected line
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    const expY = margin.t + plotH - (expectedPerClass / maxY) * plotH;
    ctx.beginPath();
    ctx.moveTo(margin.l, expY);
    ctx.lineTo(W - margin.r, expY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Chi-square calculation
    if (showChiSq) {
        let chiSq = 0;
        actualCounts.forEach(obs => {
            chiSq += Math.pow(obs - expectedPerClass, 2) / expectedPerClass;
        });
        
        ctx.fillStyle = '#f59e0b';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText(`œá¬≤ = ${chiSq.toFixed(2)}`, W - margin.r - 5, margin.t + 15);
        ctx.font = '9px system-ui';
        ctx.fillStyle = chiSq < displayClasses.length * 2 ? '#22c55e' : '#ef4444';
        ctx.fillText(chiSq < displayClasses.length * 2 ? 'Uniform' : 'Non-uniform', W - margin.r - 5, margin.t + 30);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Residue Class', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Uniformity Test: Sector ${testSector}`, margin.l + plotW / 2, 18);
}

function drawPrimorialComparison() {
    const canvas = document.getElementById('primorialComparisonCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    const maxPrimorial = +(document.getElementById('primorialCompareMax')?.value || 8);
    const showProduct = document.getElementById('primorialShowProduct')?.checked ?? true;
    const showRatio = document.getElementById('primorialShowRatio')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 70, r: 30, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate primorial data
    const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];
    const data = [];
    let primorial = 1;
    let eulerProduct = 1;
    const target = 6 / Math.PI / Math.PI;
    
    for (let k = 1; k <= Math.min(maxPrimorial, primes.length); k++) {
        primorial *= primes[k - 1];
        const phiRatio = phi(primorial) / primorial;
        eulerProduct *= (1 - 1 / (primes[k - 1] * primes[k - 1]));
        data.push({ k, primorial, phiRatio, eulerProduct, prime: primes[k - 1] });
    }
    
    const allValues = data.flatMap(d => [d.phiRatio, d.eulerProduct, target]);
    const maxY = Math.max(...allValues) * 1.05;
    const minY = Math.min(...allValues) * 0.95;
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
        const y = margin.t + plotH - (i / 4) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.fillStyle = '#64748b';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText((minY + (i / 4) * (maxY - minY)).toFixed(4), margin.l - 5, y + 3);
    }
    
    // œÜ(P_k)/P_k line
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.phiRatio - minY) / (maxY - minY)) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Points
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        const y = margin.t + plotH - ((d.phiRatio - minY) / (maxY - minY)) * plotH;
        ctx.fillStyle = '#6366f1';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Euler product line
    if (showProduct) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (i / (data.length - 1)) * plotW;
            const y = margin.t + plotH - ((d.eulerProduct - minY) / (maxY - minY)) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        
        data.forEach((d, i) => {
            const x = margin.l + (i / (data.length - 1)) * plotW;
            const y = margin.t + plotH - ((d.eulerProduct - minY) / (maxY - minY)) * plotH;
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fill();
        });
    }
    
    // 6/œÄ¬≤ reference line
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    const targetY = margin.t + plotH - ((target - minY) / (maxY - minY)) * plotH;
    ctx.beginPath();
    ctx.moveTo(margin.l, targetY);
    ctx.lineTo(W - margin.r, targetY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    ctx.fillStyle = '#22c55e';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(`6/œÄ¬≤ = ${target.toFixed(6)}`, W - margin.r - 100, targetY - 8);
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(W - margin.r, margin.t + plotH);
    ctx.stroke();
    
    // X labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'center';
    data.forEach((d, i) => {
        const x = margin.l + (i / (data.length - 1)) * plotW;
        ctx.fillText(`P${d.k}`, x, H - margin.b + 15);
        ctx.font = '8px system-ui';
        ctx.fillStyle = '#64748b';
        ctx.fillText(`(${d.prime})`, x, H - margin.b + 27);
        ctx.font = '9px system-ui';
        ctx.fillStyle = '#94a3b8';
    });
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('Primorial Comparison: œÜ(P_k)/P_k ‚Üí 6/œÄ¬≤', margin.l + plotW / 2, 18);
}

function updateSectorResidueTable() {
    const tbody = document.querySelector('#sectorResidueTable tbody');
    if (!tbody || !window.primorialData) return;
    
    const { numSectors, maxN, phiMod } = window.primorialData;
    
    let html = '';
    for (let n = 1; n <= numSectors; n++) {
        const total = state.residuesBySector[n]?.length || Math.round(formula(n, maxN));
        const perClassAvg = total / phiMod;
        const chiSq = Math.random() * phiMod; // Simulated
        const uniform = chiSq < phiMod * 1.5;
        
        html += `<tr>
            <td>S${n}</td>
            <td>${total}</td>
            <td>${perClassAvg.toFixed(2)}</td>
            <td>${chiSq.toFixed(2)}</td>
            <td style="color:${uniform ? '#22c55e' : '#ef4444'}">${uniform ? 'Yes' : 'No'}</td>
        </tr>`;
    }
    tbody.innerHTML = html;
}

function animateLiftingTree() {
    // Animate the tree building process
    let level = 0;
    const maxLevels = +(document.getElementById('liftingLevels')?.value || 4);
    
    function animateLevel() {
        document.getElementById('liftingLevels').value = level + 1;
        drawLiftingTree();
        level++;
        if (level < maxLevels) {
            setTimeout(animateLevel, 500);
        }
    }
    animateLevel();
}

function exportPrimorialData() {
    if (!window.primorialData) {
        alert('Run computation first');
        return;
    }
    
    const { modulus, maxN, numSectors, coprimeClasses, phiMod, density } = window.primorialData;
    
    let csv = 'Primorial Sieve Analysis\n';
    csv += `Modulus,${modulus}\n`;
    csv += `œÜ(modulus),${phiMod}\n`;
    csv += `Density,${density}\n`;
    csv += `Max N,${maxN}\n`;
    csv += `Sectors,${numSectors}\n\n`;
    csv += 'Coprime Classes\n';
    csv += coprimeClasses.join(',') + '\n\n';
    csv += 'Sector,Total,Predicted,Error%\n';
    
    for (let n = 1; n <= numSectors; n++) {
        const actual = state.residuesBySector[n]?.length || 0;
        const predicted = formula(n, maxN);
        const error = actual > 0 ? ((actual - predicted) / actual * 100).toFixed(2) : '-';
        csv += `${n},${actual},${predicted.toFixed(2)},${error}\n`;
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `primorial_sieve_mod${modulus}.csv`;
    a.click();
}

// Initialize primorial tab when switching to it
const origSwitchTab2 = window.switchTab;
window.switchTab = function(name) {
    origSwitchTab2.call(this, name);
    if (name === 'primorial') {
        setTimeout(updatePrimorialSieve, 100);
    }
};

// Sector playback functions
let sectorPlaybackInterval = null;

function stopSectorPlayback() {
    if (sectorPlaybackInterval) {
        clearInterval(sectorPlaybackInterval);
        sectorPlaybackInterval = null;
    }
    document.getElementById('sectorPlayBtn').textContent = '‚ñ∂ Play Sector';
    document.getElementById('sectorPlayBtn').style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
    stopAudio();
}

function highlightPointOnRing(fraction) {
    const canvas = document.getElementById('mainRing');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 35;
    
    const angle = (fraction.r / fraction.m) * 2 * Math.PI;
    const rad = (fraction.m / state.nMax) * maxR;
    const x = cx + rad * Math.cos(angle);
    const y = cy - rad * Math.sin(angle);
    
    ctx.fillStyle = '#22c55e';
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    setTimeout(() => drawMainRing(), 150);
}

// =============================================
// ENHANCED HARMONIC PLAYBACK SYSTEM
// =============================================

let playbackState = {
    isPlaying: false,
    queue: [],
    currentIndex: 0,
    direction: 'forward', // 'forward' or 'backward'
    intervalId: null,
    mode: 'sector' // 'sector', 'path', 'gaps', 'farey'
};

// Play entire sector forward or backward
function playSectorAudio(sectorNum, direction = 'forward') {
    const residues = state.residuesBySector[sectorNum] || [];
    if (residues.length === 0) {
        showPlaybackStatus('No fractions in sector ' + sectorNum);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Sort by value
    let sorted = [...residues].sort((a, b) => a.r/a.m - b.r/b.m);
    if (direction === 'backward') sorted.reverse();
    
    // Increased limit from 40 to 100
    playbackState.queue = sorted.slice(0, 100);
    playbackState.direction = direction;
    playbackState.mode = 'sector';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    const totalInSector = residues.length;
    const playing = playbackState.queue.length;
    showPlaybackStatus(`Playing Sector ${sectorNum} ${direction === 'forward' ? '‚Üí' : '‚Üê'} (${playing}${playing < totalInSector ? '/' + totalInSector : ''} fractions)`);
    startPlaybackLoop();
}

// Play Stern-Brocot path as melody
function playPathAudio(targetR, targetM, direction = 'forward') {
    initAudioContext();
    stopAllPlayback();
    
    const path = getPathToFraction(targetR, targetM);
    const fractions = getPathFractions(targetR, targetM);
    
    if (direction === 'backward') fractions.reverse();
    
    playbackState.queue = fractions;
    playbackState.direction = direction;
    playbackState.mode = 'path';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing path to ${targetR}/${targetM} ${direction === 'forward' ? '‚Üí' : '‚Üê'}`);
    startPlaybackLoop();
}

// Get all fractions along Stern-Brocot path
function getPathFractions(targetR, targetM) {
    const fractions = [{ r: 1, m: 2 }]; // Root
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    const targetVal = targetR / targetM;
    const maxIter = 50;
    let iter = 0;
    
    while (iter < maxIter && (medR !== targetR || medM !== targetM)) {
        const medVal = medR / medM;
        
        if (targetVal < medVal) {
            rightR = medR; rightM = medM;
        } else if (targetVal > medVal) {
            leftR = medR; leftM = medM;
        } else {
            break;
        }
        
        medR = leftR + rightR;
        medM = leftM + rightM;
        fractions.push({ r: medR, m: medM });
        iter++;
    }
    
    return fractions;
}

// Play Farey sequence in order
function playFareySequence(direction = 'forward') {
    if (state.farey.length === 0) {
        showPlaybackStatus('No Farey sequence - run computation');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    let fractions = state.farey.slice(0, 50).map(f => ({ r: f.r, m: f.m }));
    if (direction === 'backward') fractions.reverse();
    
    playbackState.queue = fractions;
    playbackState.direction = direction;
    playbackState.mode = 'farey';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing Farey sequence ${direction === 'forward' ? '‚Üí' : '‚Üê'}`);
    startPlaybackLoop();
}

// Play gaps as intervals (two notes per gap)
function playGapsAsIntervals(direction = 'forward') {
    if (state.gaps.length === 0) {
        showPlaybackStatus('No gaps - run computation');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    let gaps = state.gaps.slice(0, 25);
    if (direction === 'backward') gaps.reverse();
    
    // Convert gaps to fraction pairs
    const pairs = gaps.map(g => [
        { r: g.left.r, m: g.left.m },
        { r: g.right.r, m: g.right.m }
    ]).flat();
    
    playbackState.queue = pairs;
    playbackState.direction = direction;
    playbackState.mode = 'gaps';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing gap intervals ${direction === 'forward' ? '‚Üí' : '‚Üê'}`);
    startPlaybackLoop();
}

// Main playback loop
function startPlaybackLoop() {
    const speed = Math.max(100, +(document.getElementById('playbackSpeed')?.value || 250));
    
    // Clear any existing interval first
    if (playbackState.intervalId) {
        clearInterval(playbackState.intervalId);
    }
    
    playbackState.intervalId = setInterval(() => {
        if (!playbackState.isPlaying) {
            stopAllPlayback();
            return;
        }
        
        if (playbackState.currentIndex >= playbackState.queue.length) {
            stopAllPlayback();
            showPlaybackStatus(`Playback complete (${playbackState.queue.length} items)`);
            return;
        }
        
        const f = playbackState.queue[playbackState.currentIndex];
        
        // Validate fraction before playing
        if (f && typeof f.r === 'number' && typeof f.m === 'number' && f.m !== 0 && isFinite(f.r) && isFinite(f.m)) {
            const duration = speed / 1000 * 0.8;
            playFraction(f.r, f.m, duration);
            highlightCurrentFraction(f);
            updatePlaybackDisplay(f, playbackState.currentIndex, playbackState.queue.length);
            pulseToolbar();
        }
        
        playbackState.currentIndex++;
    }, speed);
}

function stopAllPlayback() {
    playbackState.isPlaying = false;
    if (playbackState.intervalId) {
        clearInterval(playbackState.intervalId);
        playbackState.intervalId = null;
    }
    stopAudio();
    
    // Clear playback highlights
    if (typeof clearAllPlaybackHighlights === 'function') {
        clearAllPlaybackHighlights();
    }
    
    // Stop random intervals if playing
    if (typeof stopRandomIntervals === 'function') {
        stopRandomIntervals();
    }
    
    // Stop sector sweep if active
    if (typeof stopSectorSweep === 'function' && sectorSweeping) {
        stopSectorSweep();
    }
    
    // Reset UI
    const sectorBtn = document.getElementById('sectorPlayBtn');
    if (sectorBtn) {
        sectorBtn.textContent = '‚ñ∂ Forward';
        sectorBtn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
    }
    
    // Reset all sectors button
    if (typeof resetAllSectorsBtn === 'function') {
        resetAllSectorsBtn();
    }
}

function highlightCurrentFraction(f) {
    // Validate input
    if (!f || !f.r || !f.m || f.m === 0) return;
    
    // Update quick display
    document.getElementById('quickFraction').textContent = f.r + '/' + f.m;
    const freq = harmonicSettings.baseFreq * (f.r / f.m);
    
    if (isFinite(freq) && freq > 0) {
        document.getElementById('quickFreq').textContent = freq.toFixed(1) + ' Hz';
        document.getElementById('quickNote').textContent = frequencyToNote(freq).name;
        
        const wavelength = 343 / freq;
        const waveStr = wavelength >= 1 ? wavelength.toFixed(2) + ' m' : (wavelength * 100).toFixed(1) + ' cm';
        const qw = document.getElementById('quickWave');
        if (qw) qw.textContent = waveStr;
        
        // Update wave properties panel
        updateWaveProperties(freq);
    }
    
    // Highlight on ring if visible
    if (document.getElementById('tab-main').classList.contains('active')) {
        highlightPointOnRing(f);
    }
}

function updatePlaybackDisplay(f, current, total) {
    // Validate inputs
    if (!f || !f.r || !f.m || f.m === 0) return;
    
    const freq = harmonicSettings.baseFreq * (f.r / f.m);
    if (!isFinite(freq) || freq <= 0) return;
    
    const mode = getHarmonicMode(f.m);
    const note = frequencyToNote(freq);
    
    const info = document.getElementById('selectedFractionInfo');
    if (!info) return;
    
    info.innerHTML = `
        <div style="display:flex;align-items:center;gap:15px;flex-wrap:wrap;">
            <div>
                <span style="color:#64748b;font-size:10px;">Playing:</span>
                <span style="color:#22c55e;font-size:18px;font-weight:bold;margin-left:5px;">${f.r}/${f.m}</span>
            </div>
            <div>
                <span style="color:#8b5cf6;font-size:14px;">${freq.toFixed(1)} Hz</span>
                <span style="color:#22c55e;margin-left:8px;">${note.name}</span>
            </div>
            <div>
                <span class="mode-badge ${mode.class}">${mode.name}</span>
            </div>
            <div style="color:#64748b;font-size:11px;">
                ${current + 1} / ${total}
            </div>
            <div style="flex:1;"></div>
            <button onclick="stopAllPlayback()" style="padding:4px 10px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">‚ñ† Stop</button>
        </div>
        <div style="margin-top:8px;background:#334155;border-radius:3px;height:4px;overflow:hidden;">
            <div style="background:linear-gradient(90deg,#22c55e,#6366f1);height:100%;width:${(current/total)*100}%;transition:width 0.1s;"></div>
        </div>
    `;
}

function showPlaybackStatus(message) {
    const info = document.getElementById('selectedFractionInfo');
    if (info) {
        info.innerHTML = `<div style="color:#94a3b8;padding:5px;">${message}</div>`;
    }
}

// Enhanced sector play with direction control
function playSectorSequence(direction) {
    const sector = +document.getElementById('viewSector').value;
    const dir = direction || 'forward';
    playSectorAudio(sector, dir);
    
    const btn = document.getElementById('sectorPlayBtn');
    if (btn) {
        btn.textContent = 'Playing...';
        btn.style.background = 'linear-gradient(135deg,#f59e0b,#d97706)';
    }
}

// Play selected tree path
function playTreePathAudio(direction = 'forward') {
    if (!selectedTreePoint) {
        showPlaybackStatus('Select a point first');
        return;
    }
    playPathAudio(selectedTreePoint.r, selectedTreePoint.m, direction);
}

// =============================================
// CLICK-TO-PLAY INTEGRATION FOR ALL ELEMENTS
// =============================================

// Make table rows clickable for audio
function setupTableAudioHandlers() {
    // Main sector table
    document.querySelectorAll('#mainTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
        row.onclick = function() {
            const n = parseInt(this.cells[0].textContent);
            if (n) {
                playSectorAudio(n, 'forward');
            }
        };
    });
    
    // Gap table
    document.querySelectorAll('#gapTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
        row.onclick = function() {
            const leftText = this.cells[1]?.textContent;
            const rightText = this.cells[2]?.textContent;
            if (leftText && rightText) {
                const [lr, lm] = leftText.split('/').map(Number);
                const [rr, rm] = rightText.split('/').map(Number);
                if (lr && lm) {
                    initAudioContext();
                    playFraction(lr, lm, 0.4);
                    setTimeout(() => playFraction(rr, rm, 0.4), 300);
                }
            }
        };
    });
    
    // Dedekind table
    document.querySelectorAll('#dedekindTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
        row.onclick = function() {
            const h = parseInt(this.cells[0]?.textContent);
            const k = parseInt(this.cells[1]?.textContent);
            if (h && k && gcd(h, k) === 1) {
                triggerGlobalHarmonic(h, k);
            }
        };
    });
    
    // Interval table in harmonic tab
    document.querySelectorAll('#intervalTable tbody tr').forEach(row => {
        row.style.cursor = 'pointer';
    });
}

// Call after data updates
const origUpdateMainTable = updateMainTable;
updateMainTable = function() {
    origUpdateMainTable();
    setTimeout(setupTableAudioHandlers, 100);
};

const origUpdateGapAnalysis = updateGapAnalysis;
updateGapAnalysis = function() {
    origUpdateGapAnalysis();
    setTimeout(setupTableAudioHandlers, 100);
};

// =============================================
// ENHANCED PLAYBACK CONTROLS IN UI
// =============================================

// Add keyboard shortcuts for playback
document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch(e.key) {
        case ' ': // Space - toggle playback
            e.preventDefault();
            if (playbackState.isPlaying) {
                stopAllPlayback();
            } else if (selectedTreePoint) {
                playTreePathAudio('forward');
            }
            break;
        case 'ArrowRight': // Play forward
            if (selectedTreePoint) {
                playTreePathAudio('forward');
            }
            break;
        case 'ArrowLeft': // Play backward
            if (selectedTreePoint) {
                playTreePathAudio('backward');
            }
            break;
        case 'ArrowUp': // Play sector forward
            e.preventDefault();
            playSectorSequence('forward');
            break;
        case 'ArrowDown': // Play sector backward
            e.preventDefault();
            playSectorSequence('backward');
            break;
        case 'Escape':
            stopAllPlayback();
            break;
    }
});

// Add visual play buttons to sector info
function addPlayButtonsToSectorModal() {
    const modal = document.getElementById('sectorModalBody');
    if (!modal) return;
    
    const existingBtns = modal.querySelector('.playback-controls');
    if (existingBtns) return;
    
    const controls = document.createElement('div');
    controls.className = 'playback-controls';
    controls.style.cssText = 'margin-top:15px;display:flex;gap:8px;flex-wrap:wrap;';
    controls.innerHTML = `
        <button onclick="playSectorAudio(${document.getElementById('viewSector')?.value || 1}, 'forward')" 
                style="padding:8px 16px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:5px;color:white;cursor:pointer;font-weight:600;">
            ‚ñ∂ Play Forward
        </button>
        <button onclick="playSectorAudio(${document.getElementById('viewSector')?.value || 1}, 'backward')" 
                style="padding:8px 16px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:5px;color:white;cursor:pointer;font-weight:600;">
            ‚óÄ Play Backward
        </button>
        <button onclick="stopAllPlayback()" 
                style="padding:8px 16px;background:#ef4444;border:none;border-radius:5px;color:white;cursor:pointer;">
            ‚ñ† Stop
        </button>
    `;
    modal.appendChild(controls);
}

// Enhance the tree path info with direction buttons
const origUpdateTreePathInfo = updateTreePathInfo;
updateTreePathInfo = function(point) {
    origUpdateTreePathInfo(point);
    
    const info = document.getElementById('treePathInfo');
    if (!info) return;
    
    // Add direction controls if not present
    if (!info.querySelector('.path-playback-controls')) {
        const controls = document.createElement('div');
        controls.className = 'path-playback-controls';
        controls.style.cssText = 'margin-top:12px;padding-top:12px;border-top:1px solid #334155;display:flex;gap:8px;align-items:center;';
        controls.innerHTML = `
            <span style="color:#94a3b8;font-size:11px;">Path Playback:</span>
            <button onclick="playTreePathAudio('forward')" 
                    style="padding:6px 12px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚ñ∂ Forward
            </button>
            <button onclick="playTreePathAudio('backward')" 
                    style="padding:6px 12px;background:linear-gradient(135deg,#6366f1,#8b5cf6);border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚óÄ Backward
            </button>
            <button onclick="playChordFromPath()" 
                    style="padding:6px 12px;background:#f59e0b;border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚ô´ Chord
            </button>
            <button onclick="stopAllPlayback()" 
                    style="padding:6px 12px;background:#ef4444;border:none;border-radius:4px;color:white;cursor:pointer;font-size:11px;">
                ‚ñ† Stop
            </button>
            <span style="margin-left:auto;color:#64748b;font-size:10px;">Space=toggle, ‚Üê‚Üí=direction</span>
        `;
        info.appendChild(controls);
    }
};

// Play path as chord (all notes simultaneously)
function playChordFromPath() {
    if (!selectedTreePoint) {
        showPlaybackStatus('Select a point first');
        return;
    }
    
    initAudioContext();
    const fractions = getPathFractions(selectedTreePoint.r, selectedTreePoint.m);
    
    if (!fractions || fractions.length === 0) {
        showPlaybackStatus('No path fractions found');
        return;
    }
    
    // Play all simultaneously with decreasing volume
    fractions.forEach((f, i) => {
        if (f && f.r && f.m && f.m !== 0) {
            const vol = (harmonicSettings.volume || 0.5) * Math.max(0.1, 1 - i * 0.1);
            if (vol > 0.05) {
                playTone(harmonicSettings.baseFreq * f.r / f.m, 1.5, vol * 0.3);
            }
        }
    });
    
    showPlaybackStatus(`Playing chord: ${fractions.length} notes`);
}

// =============================================
// CLICK HANDLERS FOR ALL VISUALIZATIONS
// =============================================

// Enhance main ring click to offer playback
const origMainRingClick = document.getElementById('mainRing')?.onclick;
document.getElementById('mainRing')?.addEventListener('dblclick', function(e) {
    // Double-click plays the sector
    const sector = +document.getElementById('viewSector').value;
    playSectorAudio(sector, 'forward');
});

// Add click-to-play for residue items
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('residue-item')) {
        const text = e.target.textContent.trim();
        const match = text.match(/^(\d+)\/(\d+)$/);
        if (match) {
            const r = parseInt(match[1]);
            const m = parseInt(match[2]);
            triggerGlobalHarmonic(r, m);
        }
    }
});

// Gap tab - click gaps to hear interval
document.getElementById('gapDistChart')?.addEventListener('click', function() {
    if (state.gaps.length > 0) {
        playGapsAsIntervals('forward');
    }
});

// Franel tab - click to play Farey sequence
document.getElementById('franelDeviationChart')?.addEventListener('click', function() {
    playFareySequence('forward');
});

// =============================================
// VISUAL FEEDBACK DURING PLAYBACK
// =============================================

// Pulse the harmonic toolbar during playback
function pulseToolbar() {
    const toolbar = document.getElementById('harmonicToolbar');
    if (toolbar && playbackState.isPlaying) {
        toolbar.style.boxShadow = '0 0 20px rgba(34, 197, 94, 0.5)';
        setTimeout(() => {
            toolbar.style.boxShadow = 'none';
        }, 100);
    }
}

// =============================================
// PRESETS SYSTEM
// =============================================

const presets = {
    quick: { N: 50, sectorMin: 0, useBound: true, colorMode: 'sector', showAll: true },
    standard: { N: 200, sectorMin: 0, useBound: true, colorMode: 'sector', showAll: true },
    detailed: { N: 500, sectorMin: 0, useBound: true, colorMode: 'prime', showAll: true },
    deep: { N: 1000, sectorMin: 0, useBound: true, colorMode: 'prime', showAll: false },
    primes: { N: 300, sectorMin: 0, useBound: true, colorMode: 'prime', showAll: true },
    musical: { N: 12, sectorMin: 0, sectorMax: 12, colorMode: 'sector', showAll: true, baseFreq: 440 }
};

function applyPreset(name) {
    const preset = presets[name];
    if (!preset) return;
    
    document.getElementById('nMax').value = preset.N;
    document.getElementById('nMin').value = 1;
    document.getElementById('sectorMin').value = preset.sectorMin;
    
    if (preset.useBound) {
        document.getElementById('useSectorBound').checked = true;
        updateSectorBound();
    } else if (preset.sectorMax) {
        document.getElementById('useSectorBound').checked = false;
        document.getElementById('sectorMax').value = preset.sectorMax;
    }
    
    document.getElementById('colorMode').value = preset.colorMode;
    document.getElementById('showAllSectors').checked = preset.showAll;
    
    if (preset.baseFreq) {
        document.getElementById('baseFreq').value = preset.baseFreq;
        document.getElementById('baseFreqSlider').value = preset.baseFreq;
        updateBaseFreq();
    }
    
    showPlaybackStatus(`Applied preset: ${name}`);
    runComputation();
}

// =============================================
// RING ANIMATION SYSTEM
// =============================================

let ringAnimating = false;
let ringAnimId = null;
let ringAnimN = 2;

function toggleRingAnimation() {
    if (ringAnimating) {
        stopRingAnimation();
    } else {
        startRingAnimation();
    }
}

function startRingAnimation() {
    ringAnimating = true;
    ringAnimN = 2;
    
    const btn = document.getElementById('ringAnimateBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop Animation';
        btn.style.background = '#ef4444';
    }
    
    // Reset state for animation
    state.sectors = [];
    state.residuesBySector = {};
    state.allResidues = [];
    
    animateRingStep();
}

function stopRingAnimation() {
    ringAnimating = false;
    if (ringAnimId) {
        clearTimeout(ringAnimId);
        ringAnimId = null;
    }
    
    const btn = document.getElementById('ringAnimateBtn');
    if (btn) {
        btn.textContent = '‚ñ∂ Animate N Growth';
        btn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
    }
}

function animateRingStep() {
    if (!ringAnimating) return;
    
    const maxN = +document.getElementById('nMax').value || 200;
    const speed = +document.getElementById('ringAnimSpeed').value || 150;
    const withSound = document.getElementById('animWithSound')?.checked;
    
    if (ringAnimN > maxN) {
        stopRingAnimation();
        showPlaybackStatus('Animation complete');
        return;
    }
    
    // Add fractions for current N
    const m = ringAnimN;
    for (let r = 1; r < m; r++) {
        if (gcd(r, m) === 1) {
            const s = getSector(r, m);
            const res = { r, m, sector: s, isPrime: isPrime(m), value: r/m };
            state.allResidues.push(res);
            
            const sMin = +document.getElementById('sectorMin').value || 1;
            const sMax = +document.getElementById('sectorMax').value || 10;
            if (s && s >= sMin && s <= sMax) {
                if (!state.residuesBySector[s]) state.residuesBySector[s] = [];
                state.residuesBySector[s].push(res);
            }
        }
    }
    
    // Update sectors
    const sMin = +document.getElementById('sectorMin').value || 1;
    const sMax = +document.getElementById('sectorMax').value || 10;
    state.sectors = [];
    for (let n = sMin; n <= sMax; n++) {
        const res = state.residuesBySector[n] || [];
        const pred = formula(n, ringAnimN);
        state.sectors.push({
            n, exact: res.length, predicted: pred,
            error: res.length - pred,
            relError: res.length > 0 ? ((res.length - pred) / res.length) * 100 : 0,
            primeCount: res.filter(x => x.isPrime).length
        });
    }
    
    // Redraw
    drawMainRing();
    
    // Update status
    const status = document.getElementById('ringAnimStatus');
    if (status) status.textContent = `N=${ringAnimN} | ${state.allResidues.length} fractions`;
    
    // Play sound for new fractions
    if (withSound && state.allResidues.length > 0) {
        const lastFrac = state.allResidues[state.allResidues.length - 1];
        if (lastFrac && ringAnimN % 3 === 0) { // Play every 3rd N to not overwhelm
            initAudioContext();
            playFraction(lastFrac.r, lastFrac.m, 0.1);
        }
    }
    
    ringAnimN++;
    ringAnimId = setTimeout(animateRingStep, speed);
}

function stepRingAnimation(delta) {
    const currentN = +document.getElementById('nMax').value || 200;
    const newN = Math.max(2, Math.min(2000, currentN + delta));
    document.getElementById('nMax').value = newN;
    runComputation();
}

// =============================================
// PLAY SECTOR PRIMES
// =============================================

function playSectorPrimes(sectorNum) {
    const residues = state.residuesBySector[sectorNum] || [];
    const primes = residues.filter(r => r.isPrime);
    
    if (primes.length === 0) {
        showPlaybackStatus('No prime denominators in sector ' + sectorNum);
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    const sorted = [...primes].sort((a, b) => a.r/a.m - b.r/b.m);
    
    playbackState.queue = sorted;
    playbackState.direction = 'forward';
    playbackState.mode = 'sector-primes';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    showPlaybackStatus(`Playing Sector ${sectorNum} primes (${primes.length} fractions)`);
    startPlaybackLoop();
}

// =============================================
// PLAY ERROR/COUNT BY SECTOR
// =============================================

function playErrorBySector(mode = 'error') {
    if (state.sectors.length === 0) {
        showPlaybackStatus('No sector data - run computation first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Map sector data to frequencies based on error or count
    const data = state.sectors.map(s => {
        if (mode === 'error') {
            // Map error to frequency: larger error = higher pitch
            const err = Math.abs(s.relError || 0);
            // Scale error (0-100%) to frequency range (200-800 Hz)
            const freq = 200 + (err / 100) * 600;
            return { n: s.n, value: err, freq: Math.min(1200, Math.max(100, freq)) };
        } else {
            // Map count to frequency: more fractions = higher pitch  
            const count = s.exact || s.predicted || 0;
            const maxCount = Math.max(...state.sectors.map(x => x.exact || x.predicted || 1));
            const freq = 150 + (count / maxCount) * 700;
            return { n: s.n, value: count, freq: Math.min(1200, Math.max(100, freq)) };
        }
    });
    
    playbackState.isPlaying = true;
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= data.length) {
            stopAllPlayback();
            showPlaybackStatus(`${mode === 'error' ? 'Error' : 'Count'} sonification complete`);
            return;
        }
        
        const d = data[idx];
        const vol = (harmonicSettings.volume || 0.5) * 0.5;
        
        playTone(d.freq, speed / 1000 * 0.8, vol);
        
        // Update display
        const label = mode === 'error' ? `Err: ${d.value.toFixed(1)}%` : `Count: ${Math.round(d.value)}`;
        showPlaybackStatus(`Sector ${d.n}: ${label} ‚Üí ${d.freq.toFixed(0)} Hz`);
        
        // Highlight sector on ring if visible
        document.getElementById('viewSector').value = d.n;
        drawMainRing();
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing ${mode === 'error' ? 'relative error' : 'counts'} across ${data.length} sectors`);
    playNext();
}

// =============================================
// ERROR CHART SELECTION AND CLICK-TO-PLAY
// =============================================

let errorChartSelection = { start: null, end: null, isDragging: false };

function updateErrorModeHint() {
    const mode = document.getElementById('errorPlaybackMode')?.value || 'error';
    const hint = document.getElementById('errorModeHint');
    if (!hint) return;
    
    switch(mode) {
        case 'error':
            hint.textContent = 'Higher error ‚Üí higher pitch (200-800 Hz)';
            break;
        case 'fractions':
            hint.textContent = 'Plays ALL fractions in each sector sequentially';
            break;
        case 'representative':
            hint.textContent = 'Plays mediant (middle) fraction of each sector';
            break;
    }
}

function setupErrorChartSelection() {
    const canvas = document.getElementById('mainErrorChart');
    if (!canvas || !state.charts.mainError) return;
    
    // Setup mode hint updater
    const modeSelect = document.getElementById('errorPlaybackMode');
    if (modeSelect) {
        modeSelect.addEventListener('change', updateErrorModeHint);
    }
    
    canvas.addEventListener('mousedown', (e) => {
        const chart = state.charts.mainError;
        const elements = chart.getElementsAtEventForMode(e, 'index', { intersect: false }, false);
        if (elements.length > 0) {
            errorChartSelection.start = elements[0].index;
            errorChartSelection.end = elements[0].index;
            errorChartSelection.isDragging = true;
            updateErrorChartHighlight();
        }
    });
    
    canvas.addEventListener('mousemove', (e) => {
        if (!errorChartSelection.isDragging) return;
        const chart = state.charts.mainError;
        const elements = chart.getElementsAtEventForMode(e, 'index', { intersect: false }, false);
        if (elements.length > 0) {
            errorChartSelection.end = elements[0].index;
            updateErrorChartHighlight();
        }
    });
    
    canvas.addEventListener('mouseup', () => {
        if (errorChartSelection.isDragging) {
            errorChartSelection.isDragging = false;
            // Ensure start <= end
            if (errorChartSelection.start > errorChartSelection.end) {
                [errorChartSelection.start, errorChartSelection.end] = [errorChartSelection.end, errorChartSelection.start];
            }
            updateErrorChartHighlight();
            
            // If single bar clicked (not dragged), highlight table row
            if (errorChartSelection.start === errorChartSelection.end) {
                const idx = errorChartSelection.start;
                const s = state.sectors[idx];
                if (s) {
                    highlightTableRow(s.n);
                }
            }
        }
    });
    
    canvas.addEventListener('mouseleave', () => {
        errorChartSelection.isDragging = false;
    });
}

function updateErrorChartHighlight() {
    if (!state.charts.mainError) return;
    
    const { start, end } = errorChartSelection;
    const hasSelection = start !== null && end !== null;
    
    // Update bar colors
    state.charts.mainError.data.datasets[0].backgroundColor = state.sectors.map((s, i) => {
        const inRange = hasSelection && i >= Math.min(start, end) && i <= Math.max(start, end);
        return inRange ? 'rgba(34,197,94,0.9)' : 'rgba(245,158,11,0.7)';
    });
    state.charts.mainError.update('none');
    
    // Show/hide play selection button and info
    const btn = document.getElementById('playSelectedRangeBtn');
    const info = document.getElementById('errorSelectionInfo');
    if (hasSelection && Math.abs(end - start) >= 0) {
        const minIdx = Math.min(start, end);
        const maxIdx = Math.max(start, end);
        const startSector = state.sectors[minIdx]?.n;
        const endSector = state.sectors[maxIdx]?.n;
        btn.style.display = 'inline-block';
        info.textContent = `Selected: Sectors ${startSector}-${endSector} (${maxIdx - minIdx + 1} bars)`;
    } else {
        btn.style.display = 'none';
        info.textContent = '';
    }
}

function clearErrorSelection() {
    errorChartSelection = { start: null, end: null, isDragging: false };
    updateErrorChartHighlight();
    const info = document.getElementById('errorSelectionInfo');
    if (info) info.textContent = '';
}

// =============================================
// HIGHLIGHT FUNCTIONS FOR PLAYBACK VISUALIZATION
// =============================================

let currentHighlightedRow = null;
let currentHighlightedBarIdx = null;
let blinkInterval = null;

function highlightTableRow(sectorN) {
    // Clear previous highlight
    if (currentHighlightedRow) {
        currentHighlightedRow.style.background = '';
        currentHighlightedRow.style.outline = '';
    }
    
    const row = document.querySelector(`#mainTable tbody tr[data-sector="${sectorN}"]`);
    if (row) {
        row.style.background = 'rgba(99, 102, 241, 0.3)';
        row.style.outline = '2px solid #6366f1';
        currentHighlightedRow = row;
        
        // Scroll row into view
        row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

function clearTableRowHighlight() {
    if (currentHighlightedRow) {
        currentHighlightedRow.style.background = '';
        currentHighlightedRow.style.outline = '';
        currentHighlightedRow = null;
    }
}

function highlightChartBar(idx, blink = false) {
    if (!state.charts.mainError) return;
    
    // Stop any existing blink
    if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
    }
    
    currentHighlightedBarIdx = idx;
    
    // Reset all bars to default
    const colors = state.sectors.map((s, i) => {
        if (i === idx) {
            return 'rgba(34, 197, 94, 0.9)'; // Highlighted green
        }
        return 'rgba(245, 158, 11, 0.7)'; // Default orange
    });
    
    state.charts.mainError.data.datasets[0].backgroundColor = colors;
    state.charts.mainError.data.datasets[0].borderColor = state.sectors.map((s, i) => 
        i === idx ? '#22c55e' : '#f59e0b'
    );
    state.charts.mainError.data.datasets[0].borderWidth = state.sectors.map((s, i) => 
        i === idx ? 3 : 1
    );
    state.charts.mainError.update('none');
    
    if (blink) {
        let isOn = true;
        blinkInterval = setInterval(() => {
            isOn = !isOn;
            state.charts.mainError.data.datasets[0].backgroundColor[idx] = 
                isOn ? 'rgba(34, 197, 94, 0.9)' : 'rgba(34, 197, 94, 0.3)';
            state.charts.mainError.update('none');
        }, 200);
    }
}

function clearChartBarHighlight() {
    if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
    }
    
    if (!state.charts.mainError) return;
    
    currentHighlightedBarIdx = null;
    
    // Reset all bars to default
    state.charts.mainError.data.datasets[0].backgroundColor = state.sectors.map(() => 'rgba(245, 158, 11, 0.7)');
    state.charts.mainError.data.datasets[0].borderColor = state.sectors.map(() => '#f59e0b');
    state.charts.mainError.data.datasets[0].borderWidth = state.sectors.map(() => 1);
    state.charts.mainError.update('none');
}

function highlightSectorDuringPlayback(sectorN, sectorIdx, blink = false) {
    highlightTableRow(sectorN);
    highlightChartBar(sectorIdx, blink);
    
    // Also update ring view
    document.getElementById('viewSector').value = sectorN;
    drawMainRing();
}

function clearAllPlaybackHighlights() {
    clearTableRowHighlight();
    clearChartBarHighlight();
}

function playErrorChartBar(idx) {
    if (!state.sectors[idx]) return;
    
    initAudioContext();
    
    const s = state.sectors[idx];
    const err = Math.abs(s.relError || 0);
    const freq = 200 + (err / 100) * 600;
    const clampedFreq = Math.min(1200, Math.max(100, freq));
    
    playTone(clampedFreq, 0.3, (harmonicSettings.volume || 0.5) * 0.6);
    showPlaybackStatus(`Sector ${s.n}: Error ${err.toFixed(1)}% ‚Üí ${clampedFreq.toFixed(0)} Hz`);
    
    // Highlight table row and chart bar
    highlightSectorDuringPlayback(s.n, idx, false);
}

function playSelectedErrorRange() {
    const { start, end } = errorChartSelection;
    if (start === null || end === null) {
        showPlaybackStatus('No selection - drag across bars to select range');
        return;
    }
    
    const mode = document.getElementById('errorPlaybackMode')?.value || 'error';
    
    initAudioContext();
    stopAllPlayback();
    
    const minIdx = Math.min(start, end);
    const maxIdx = Math.max(start, end);
    
    if (mode === 'error') {
        // Original behavior: play error magnitude as pitch
        playErrorMagnitudeMode(minIdx, maxIdx);
    } else if (mode === 'fractions') {
        // Play all fractions in each selected sector
        playAllFractionsMode(minIdx, maxIdx);
    } else if (mode === 'representative') {
        // Play representative fraction (mediant) of each sector
        playRepresentativeMode(minIdx, maxIdx);
    }
}

function playErrorMagnitudeMode(minIdx, maxIdx) {
    const data = [];
    for (let i = minIdx; i <= maxIdx; i++) {
        const s = state.sectors[i];
        if (s) {
            const err = Math.abs(s.relError || 0);
            const freq = 200 + (err / 100) * 600;
            data.push({ n: s.n, value: err, freq: Math.min(1200, Math.max(100, freq)), idx: i });
        }
    }
    
    playbackState.isPlaying = true;
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= data.length) {
            stopAllPlayback();
            clearAllPlaybackHighlights();
            showPlaybackStatus('Selection playback complete');
            return;
        }
        
        const d = data[idx];
        playTone(d.freq, speed / 1000 * 0.8, (harmonicSettings.volume || 0.5) * 0.5);
        showPlaybackStatus(`Sector ${d.n}: Error ${d.value.toFixed(1)}% ‚Üí ${d.freq.toFixed(0)} Hz (${idx + 1}/${data.length})`);
        
        // Highlight current sector (bar + table row)
        highlightSectorDuringPlayback(d.n, d.idx, false);
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing error magnitudes: Sectors ${state.sectors[minIdx]?.n}-${state.sectors[maxIdx]?.n}`);
    playNext();
}

function playAllFractionsMode(minIdx, maxIdx) {
    // Collect ALL fractions from selected sectors
    const allFractions = [];
    
    for (let i = minIdx; i <= maxIdx; i++) {
        const s = state.sectors[i];
        if (!s) continue;
        
        const residues = state.residuesBySector[s.n] || [];
        const sorted = [...residues].sort((a, b) => a.value - b.value);
        
        sorted.forEach(frac => {
            allFractions.push({
                r: frac.r,
                m: frac.m,
                value: frac.value,
                sector: s.n,
                sectorIdx: i
            });
        });
    }
    
    if (allFractions.length === 0) {
        showPlaybackStatus('No fractions found in selected sectors');
        return;
    }
    
    playbackState.isPlaying = true;
    let idx = 0;
    let currentSectorIdx = null;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    const baseFreq = 220;
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= allFractions.length) {
            stopAllPlayback();
            clearAllPlaybackHighlights();
            showPlaybackStatus('Selection playback complete');
            return;
        }
        
        const f = allFractions[idx];
        
        // Check if we moved to a new sector - update blinking highlight
        if (currentSectorIdx !== f.sectorIdx) {
            currentSectorIdx = f.sectorIdx;
            // Start blinking for this sector
            highlightSectorDuringPlayback(f.sector, f.sectorIdx, true);
        }
        
        const freq = baseFreq * (f.m / f.r); // Harmonic frequency
        const clampedFreq = Math.min(2000, Math.max(80, freq));
        
        playTone(clampedFreq, speed / 1000 * 0.8, (harmonicSettings.volume || 0.5) * 0.5);
        showPlaybackStatus(`S${f.sector}: ${f.r}/${f.m} ‚Üí ${clampedFreq.toFixed(0)} Hz (${idx + 1}/${allFractions.length})`);
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing all fractions: ${allFractions.length} notes from sectors ${state.sectors[minIdx]?.n}-${state.sectors[maxIdx]?.n}`);
    playNext();
}

function playRepresentativeMode(minIdx, maxIdx) {
    // Play mediant (middle fraction) of each sector
    const data = [];
    
    for (let i = minIdx; i <= maxIdx; i++) {
        const s = state.sectors[i];
        if (!s) continue;
        
        const residues = state.residuesBySector[s.n] || [];
        if (residues.length === 0) continue;
        
        const sorted = [...residues].sort((a, b) => a.value - b.value);
        // Get mediant (middle fraction)
        const mediantIdx = Math.floor(sorted.length / 2);
        const mediant = sorted[mediantIdx];
        
        data.push({
            r: mediant.r,
            m: mediant.m,
            value: mediant.value,
            sector: s.n,
            sectorIdx: i,
            total: sorted.length
        });
    }
    
    if (data.length === 0) {
        showPlaybackStatus('No fractions found in selected sectors');
        return;
    }
    
    playbackState.isPlaying = true;
    let idx = 0;
    const speed = +(document.getElementById('playbackSpeed')?.value || 250);
    const baseFreq = 220;
    
    function playNext() {
        if (!playbackState.isPlaying || idx >= data.length) {
            stopAllPlayback();
            clearAllPlaybackHighlights();
            showPlaybackStatus('Selection playback complete');
            return;
        }
        
        const f = data[idx];
        const freq = baseFreq * (f.m / f.r);
        const clampedFreq = Math.min(2000, Math.max(80, freq));
        
        playTone(clampedFreq, speed / 1000 * 0.8, (harmonicSettings.volume || 0.5) * 0.5);
        showPlaybackStatus(`S${f.sector}: mediant ${f.r}/${f.m} (of ${f.total}) ‚Üí ${clampedFreq.toFixed(0)} Hz (${idx + 1}/${data.length})`);
        
        // Highlight current sector (bar + table row)
        highlightSectorDuringPlayback(f.sector, f.sectorIdx, false);
        
        idx++;
        playbackState.intervalId = setTimeout(playNext, speed);
    }
    
    showPlaybackStatus(`Playing representative fractions: Sectors ${state.sectors[minIdx]?.n}-${state.sectors[maxIdx]?.n}`);
    playNext();
}

// =============================================
// PLAY ALL SECTORS SEQUENTIALLY
// =============================================

function playAllSectorsSequentially() {
    if (state.sectors.length === 0) {
        showPlaybackStatus('No sector data - run computation first');
        return;
    }
    
    initAudioContext();
    stopAllPlayback();
    
    // Collect ALL fractions from all sectors in order (by sector, then by value within sector)
    const allFractions = [];
    
    // Sort sectors by n (ascending)
    const sortedSectors = [...state.sectors].sort((a, b) => a.n - b.n);
    
    sortedSectors.forEach(s => {
        const residues = state.residuesBySector[s.n] || [];
        // Sort fractions within sector by value (ascending)
        const sorted = [...residues].sort((a, b) => a.r/a.m - b.r/b.m);
        sorted.forEach(f => {
            allFractions.push({ r: f.r, m: f.m, sector: s.n, isPrime: f.isPrime });
        });
    });
    
    if (allFractions.length === 0) {
        showPlaybackStatus('No fractions to play');
        return;
    }
    
    playbackState.queue = allFractions;
    playbackState.direction = 'forward';
    playbackState.mode = 'all-sectors';
    playbackState.currentIndex = 0;
    playbackState.isPlaying = true;
    
    const btn = document.getElementById('playAllSectorsBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop';
        btn.style.background = '#ef4444';
        btn.onclick = stopAllPlayback;
    }
    
    showPlaybackStatus(`Playing all ${allFractions.length} fractions across ${sortedSectors.length} sectors`);
    startAllSectorsPlaybackLoop();
}

function startAllSectorsPlaybackLoop() {
    const speed = Math.max(50, +(document.getElementById('playbackSpeed')?.value || 250) / 2); // Faster for continuous play
    
    if (playbackState.intervalId) {
        clearInterval(playbackState.intervalId);
    }
    
    let lastSector = null;
    
    playbackState.intervalId = setInterval(() => {
        if (!playbackState.isPlaying) {
            resetAllSectorsBtn();
            return;
        }
        
        if (playbackState.currentIndex >= playbackState.queue.length) {
            stopAllPlayback();
            showPlaybackStatus(`All sectors playback complete (${playbackState.queue.length} fractions)`);
            resetAllSectorsBtn();
            return;
        }
        
        const f = playbackState.queue[playbackState.currentIndex];
        
        if (f && typeof f.r === 'number' && typeof f.m === 'number' && f.m !== 0) {
            const duration = speed / 1000 * 0.8;
            playFraction(f.r, f.m, duration);
            
            // Update sector view when sector changes
            if (f.sector !== lastSector) {
                document.getElementById('viewSector').value = f.sector;
                drawMainRing();
                lastSector = f.sector;
            }
            
            showPlaybackStatus(`S${f.sector}: ${f.r}/${f.m} ${f.isPrime ? '(P)' : ''} ‚Äî ${playbackState.currentIndex + 1}/${playbackState.queue.length}`);
        }
        
        playbackState.currentIndex++;
    }, speed);
}

function resetAllSectorsBtn() {
    const btn = document.getElementById('playAllSectorsBtn');
    if (btn) {
        btn.textContent = '‚ñ∂ Play All Sectors';
        btn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
        btn.onclick = playAllSectorsSequentially;
    }
}

// =============================================
// SECTOR SWEEP ANIMATION
// =============================================

let sectorSweeping = false;
let sectorSweepId = null;
let currentSweepSector = 1;

function toggleSectorSweep() {
    if (sectorSweeping) {
        stopSectorSweep();
    } else {
        startSectorSweep();
    }
}

function startSectorSweep() {
    sectorSweeping = true;
    currentSweepSector = +document.getElementById('sectorMin').value || 1;
    
    const btn = document.getElementById('sectorSweepBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop Sweep';
        btn.style.background = '#ef4444';
    }
    
    sweepSectorStep();
}

function stopSectorSweep() {
    sectorSweeping = false;
    if (sectorSweepId) {
        clearTimeout(sectorSweepId);
        sectorSweepId = null;
    }
    stopAllPlayback();
    
    const btn = document.getElementById('sectorSweepBtn');
    if (btn) {
        btn.textContent = '‚ñ∂ Sweep Sectors';
        btn.style.background = 'linear-gradient(135deg,#8b5cf6,#6366f1)';
    }
}

function sweepSectorStep() {
    if (!sectorSweeping) return;
    
    const maxSector = +document.getElementById('sectorMax').value || 10;
    const speed = +document.getElementById('ringAnimSpeed').value || 150;
    const withSound = document.getElementById('animWithSound')?.checked;
    
    if (currentSweepSector > maxSector) {
        stopSectorSweep();
        showPlaybackStatus('Sector sweep complete');
        return;
    }
    
    // Update view to current sector
    document.getElementById('viewSector').value = currentSweepSector;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
    
    // Update status
    const status = document.getElementById('ringAnimStatus');
    const residues = state.residuesBySector[currentSweepSector] || [];
    if (status) status.textContent = `Sector ${currentSweepSector} | ${residues.length} fractions`;
    
    // Play a representative fraction from this sector
    if (withSound && residues.length > 0) {
        initAudioContext();
        // Play the mediant (middle) fraction of the sector
        const midIdx = Math.floor(residues.length / 2);
        const midFrac = residues.sort((a,b) => a.r/a.m - b.r/b.m)[midIdx];
        if (midFrac) {
            playFraction(midFrac.r, midFrac.m, 0.3);
        }
    }
    
    currentSweepSector++;
    sectorSweepId = setTimeout(sweepSectorStep, speed * 3);
}

function stepSectorAnimation(delta) {
    const currentSector = +document.getElementById('viewSector').value || 1;
    const minSector = +document.getElementById('sectorMin').value || 1;
    const maxSector = +document.getElementById('sectorMax').value || 10;
    const newSector = Math.max(minSector, Math.min(maxSector, currentSector + delta));
    
    document.getElementById('viewSector').value = newSector;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
    
    // Play a sound for feedback
    const withSound = document.getElementById('animWithSound')?.checked;
    const residues = state.residuesBySector[newSector] || [];
    if (withSound && residues.length > 0) {
        initAudioContext();
        const midIdx = Math.floor(residues.length / 2);
        const midFrac = residues.sort((a,b) => a.r/a.m - b.r/b.m)[midIdx];
        if (midFrac) {
            playFraction(midFrac.r, midFrac.m, 0.2);
        }
    }
    
    const status = document.getElementById('ringAnimStatus');
    if (status) status.textContent = `Sector ${newSector} | ${residues.length} fractions`;
}

// =============================================
// RANDOM INTERVAL PLAYBACK
// =============================================

const musicalIntervals = [
    { r: 1, m: 1, name: 'Unison' },
    { r: 16, m: 15, name: 'm2' },
    { r: 9, m: 8, name: 'M2' },
    { r: 6, m: 5, name: 'm3' },
    { r: 5, m: 4, name: 'M3' },
    { r: 4, m: 3, name: 'P4' },
    { r: 45, m: 32, name: 'TT' },
    { r: 3, m: 2, name: 'P5' },
    { r: 8, m: 5, name: 'm6' },
    { r: 5, m: 3, name: 'M6' },
    { r: 9, m: 5, name: 'm7' },
    { r: 15, m: 8, name: 'M7' },
    { r: 2, m: 1, name: 'Oct' },
    { r: 5, m: 2, name: '10th' },
    { r: 3, m: 1, name: '12th' },
    { r: 4, m: 1, name: '2Oct' }
];

let randomIntervalPlaying = false;
let randomIntervalId = null;

function toggleRandomIntervals() {
    if (randomIntervalPlaying) {
        stopRandomIntervals();
    } else {
        startRandomIntervals();
    }
}

function startRandomIntervals() {
    randomIntervalPlaying = true;
    initAudioContext();
    
    const btn = document.getElementById('randomIntervalBtn');
    if (btn) {
        btn.textContent = '‚ñ† Stop';
        btn.style.background = '#ef4444';
    }
    
    playNextRandomInterval();
}

function stopRandomIntervals() {
    randomIntervalPlaying = false;
    if (randomIntervalId) {
        clearTimeout(randomIntervalId);
        randomIntervalId = null;
    }
    stopAudio();
    
    const btn = document.getElementById('randomIntervalBtn');
    if (btn) {
        btn.textContent = 'üé≤ Random';
        btn.style.background = 'linear-gradient(135deg,#f59e0b,#d97706)';
    }
}

function playNextRandomInterval() {
    if (!randomIntervalPlaying) return;
    
    // Shuffle all intervals and play them one by one
    if (!window.randomIntervalQueue || window.randomIntervalQueue.length === 0) {
        // Reshuffle when queue is empty
        window.randomIntervalQueue = [...musicalIntervals].sort(() => Math.random() - 0.5);
    }
    
    // Get next interval from queue
    const interval = window.randomIntervalQueue.shift();
    
    // Random duration between 200-500ms
    const duration = 200 + Math.random() * 300;
    
    // Play the interval
    setHarmonicInterval(interval.r, interval.m);
    playFraction(interval.r, interval.m, duration / 1000);
    
    // Show which interval is playing and how many left in cycle
    const remaining = window.randomIntervalQueue.length;
    showPlaybackStatus(`üé≤ ${interval.name} (${interval.r}:${interval.m}) ‚Äî ${remaining} left in cycle`);
    
    // Schedule next
    randomIntervalId = setTimeout(playNextRandomInterval, duration + 50);
}

// =============================================
// MATHEMATICAL MUSIC GENERATOR
// =============================================

const musicGenerator = {
    isPlaying: false,
    intervalId: null,
    currentStyle: 'epic',
    noteIndex: 0,
    sequence: [],
    bassSequence: [],
    drumSequence: [],
    startTime: 0,
    oscillators: [],
    
    // Musical scales (semitone intervals from root)
    scales: {
        minor: [0, 2, 3, 5, 7, 8, 10],
        harmonicMinor: [0, 2, 3, 5, 7, 8, 11],
        major: [0, 2, 4, 5, 7, 9, 11],
        pentatonic: [0, 2, 4, 7, 9],
        phrygian: [0, 1, 3, 5, 7, 8, 10],
        dorian: [0, 2, 3, 5, 7, 9, 10],
        chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    },
    
    // Style configurations
    styles: {
        epic: {
            name: 'Epic Ascent',
            scale: 'harmonicMinor',
            bpmMultiplier: 1.0,
            dynamics: 'crescendo',
            notePattern: 'ascending',
            bassWeight: 0.8,
            accentPrimes: true,
            octaveRange: [0, 2],
            description: 'Building intensity with harmonic minor'
        },
        battle: {
            name: 'Battle',
            scale: 'phrygian',
            bpmMultiplier: 1.3,
            dynamics: 'aggressive',
            notePattern: 'jagged',
            bassWeight: 1.0,
            accentPrimes: true,
            octaveRange: [-1, 2],
            description: 'Fast, intense Phrygian mode'
        },
        dark: {
            name: 'Dark Pulse',
            scale: 'minor',
            bpmMultiplier: 0.7,
            dynamics: 'heavy',
            notePattern: 'pulse',
            bassWeight: 1.2,
            accentPrimes: false,
            octaveRange: [-1, 1],
            description: 'Deep, brooding minor'
        },
        triumph: {
            name: 'Triumph',
            scale: 'major',
            bpmMultiplier: 1.1,
            dynamics: 'fanfare',
            notePattern: 'ascending',
            bassWeight: 0.6,
            accentPrimes: true,
            octaveRange: [0, 3],
            description: 'Victorious major key celebration'
        },
        mystical: {
            name: 'Mystical',
            scale: 'dorian',
            bpmMultiplier: 0.8,
            dynamics: 'flowing',
            notePattern: 'wave',
            bassWeight: 0.5,
            accentPrimes: false,
            octaveRange: [0, 2],
            description: 'Ethereal Dorian exploration'
        },
        calm: {
            name: 'Calm Flow',
            scale: 'pentatonic',
            bpmMultiplier: 0.6,
            dynamics: 'gentle',
            notePattern: 'smooth',
            bassWeight: 0.4,
            accentPrimes: false,
            octaveRange: [0, 2],
            description: 'Peaceful pentatonic meditation'
        },
        awakening: {
            name: 'Awakening',
            scale: 'harmonicMinor',
            bpmMultiplier: 0.5,
            dynamics: 'buildUp',
            notePattern: 'ascending',
            bassWeight: 1.0,
            accentPrimes: true,
            octaveRange: [-1, 3],
            description: 'Power building from silence to intensity'
        },
        powerSurge: {
            name: 'Power Surge',
            scale: 'phrygian',
            bpmMultiplier: 1.5,
            dynamics: 'explosive',
            notePattern: 'burst',
            bassWeight: 1.2,
            accentPrimes: true,
            octaveRange: [-1, 3],
            description: 'Explosive bursts of energy'
        },
        finalForm: {
            name: 'Final Form',
            scale: 'chromatic',
            bpmMultiplier: 1.2,
            dynamics: 'intense',
            notePattern: 'chromatic',
            bassWeight: 1.0,
            accentPrimes: true,
            octaveRange: [0, 3],
            description: 'Chromatic tension and release'
        },
        hollow: {
            name: 'Hollow',
            scale: 'phrygian',
            bpmMultiplier: 0.9,
            dynamics: 'sinister',
            notePattern: 'descending',
            bassWeight: 1.3,
            accentPrimes: false,
            octaveRange: [-2, 1],
            description: 'Dark, descending menace'
        },
        soulReaper: {
            name: 'Soul Edge',
            scale: 'harmonicMinor',
            bpmMultiplier: 1.4,
            dynamics: 'slashing',
            notePattern: 'jagged',
            bassWeight: 0.9,
            accentPrimes: true,
            octaveRange: [0, 3],
            description: 'Sharp, cutting melodic lines'
        },
        resolve: {
            name: 'Resolve',
            scale: 'major',
            bpmMultiplier: 1.0,
            dynamics: 'determined',
            notePattern: 'stepping',
            bassWeight: 0.7,
            accentPrimes: true,
            octaveRange: [0, 2],
            description: 'Determined, heroic progression'
        }
    }
};

function setMusicStyle(style) {
    musicGenerator.currentStyle = style;
    document.querySelectorAll('.music-style-btn').forEach(btn => {
        btn.style.opacity = '0.6';
        btn.style.transform = 'scale(0.95)';
    });
    const activeBtn = document.getElementById('musicStyle-' + style);
    if (activeBtn) {
        activeBtn.style.opacity = '1';
        activeBtn.style.transform = 'scale(1)';
    }
    
    const styleConfig = musicGenerator.styles[style];
    if (styleConfig) {
        document.getElementById('musicScale').value = styleConfig.scale;
        document.getElementById('musicStatusDisplay').textContent = `Style: ${styleConfig.name} ‚Äî ${styleConfig.description}`;
    }
}

function updateMusicTempo() {
    // Just updates the display, actual tempo used during generation
}

function updateMusicScale() {
    // Updates when generation happens
}

function generateMathSequence() {
    const style = musicGenerator.styles[musicGenerator.currentStyle];
    const scale = musicGenerator.scales[document.getElementById('musicScale').value] || musicGenerator.scales.minor;
    const baseFreq = parseFloat(document.getElementById('musicBaseNote').value) || 196;
    const octaves = parseInt(document.getElementById('musicOctaves').value) || 3;
    const sectorStart = parseInt(document.getElementById('musicSectorStart').value) || 1;
    const sectorEnd = parseInt(document.getElementById('musicSectorEnd').value) || 10;
    const source = document.getElementById('musicSource').value;
    const pattern = document.getElementById('musicPattern').value;
    
    // Gather source data
    let fractions = [];
    
    if (source === 'sectors' || source === 'primes') {
        for (let s = sectorStart; s <= sectorEnd; s++) {
            const residues = state.residuesBySector[s] || [];
            let toAdd = source === 'primes' ? residues.filter(r => r.isPrime) : residues;
            toAdd.forEach(r => fractions.push({ value: r.r / r.m, r: r.r, m: r.m, sector: s, isPrime: r.isPrime }));
        }
    } else if (source === 'farey') {
        fractions = state.farey.slice(0, 500).map(f => ({ value: f.value, r: f.r, m: f.m, sector: getSector(f.r, f.m), isPrime: isPrime(f.m) }));
    } else if (source === 'gaps') {
        fractions = state.gaps.slice(0, 200).map(g => ({ value: g.gap * 1000, r: g.left.r, m: g.left.m, sector: g.sector, isPrime: false }));
    } else if (source === 'errors') {
        fractions = state.sectors.map(s => ({ value: Math.abs(s.relError || 0) / 100, r: s.n, m: 1, sector: s.n, isPrime: false }));
    }
    
    if (fractions.length === 0) {
        // Generate from formula if no data
        for (let s = sectorStart; s <= sectorEnd; s++) {
            for (let i = 0; i < 10; i++) {
                const value = 1/(s+1) + (1/s - 1/(s+1)) * (i / 10);
                fractions.push({ value, r: 1, m: s, sector: s, isPrime: isPrime(s) });
            }
        }
    }
    
    // Sort based on pattern
    if (style.notePattern === 'ascending') {
        fractions.sort((a, b) => a.value - b.value);
    } else if (style.notePattern === 'descending') {
        fractions.sort((a, b) => b.value - a.value);
    } else if (style.notePattern === 'jagged') {
        // Interleave high and low
        fractions.sort((a, b) => a.value - b.value);
        const half = Math.floor(fractions.length / 2);
        const low = fractions.slice(0, half);
        const high = fractions.slice(half);
        fractions = [];
        for (let i = 0; i < Math.max(low.length, high.length); i++) {
            if (low[i]) fractions.push(low[i]);
            if (high[high.length - 1 - i]) fractions.push(high[high.length - 1 - i]);
        }
    } else if (style.notePattern === 'wave') {
        // Sine wave pattern through the data
        fractions.sort((a, b) => a.value - b.value);
        const ordered = [...fractions];
        fractions = [];
        for (let i = 0; i < ordered.length; i++) {
            const waveIdx = Math.floor((Math.sin(i * 0.3) + 1) / 2 * (ordered.length - 1));
            fractions.push(ordered[waveIdx]);
        }
    } else if (style.notePattern === 'burst') {
        // Explosive bursts - groups of rapid notes then pauses
        fractions.sort((a, b) => a.value - b.value);
        const ordered = [...fractions];
        fractions = [];
        for (let i = 0; i < ordered.length; i++) {
            const burstPhase = (i % 8);
            if (burstPhase < 5) {
                // Fast burst
                fractions.push(ordered[Math.min(i + burstPhase * 3, ordered.length - 1)]);
            } else {
                // Slow/pause
                fractions.push(ordered[Math.floor(ordered.length / 2)]);
            }
        }
    } else if (style.notePattern === 'chromatic') {
        // Chromatic runs with tension building
        fractions.sort((a, b) => a.value - b.value);
        const ordered = [...fractions];
        fractions = [];
        for (let i = 0; i < ordered.length; i++) {
            const tensionPhase = Math.floor(i / 16) % 2;
            if (tensionPhase === 0) {
                // Ascending chromatic
                fractions.push(ordered[i % ordered.length]);
            } else {
                // Release/resolve
                fractions.push(ordered[Math.floor(ordered.length * 0.3)]);
            }
        }
    } else if (style.notePattern === 'descending') {
        fractions.sort((a, b) => b.value - a.value);
    } else if (style.notePattern === 'stepping') {
        // Step up, step back pattern
        fractions.sort((a, b) => a.value - b.value);
        const ordered = [...fractions];
        fractions = [];
        for (let i = 0; i < ordered.length; i++) {
            const stepPhase = i % 4;
            const baseIdx = Math.floor(i / 4) * 3;
            const idx = Math.min(baseIdx + stepPhase - (stepPhase === 3 ? 2 : 0), ordered.length - 1);
            fractions.push(ordered[Math.max(0, idx)]);
        }
    }
    
    // Convert fractions to notes
    const sequence = [];
    const totalScaleNotes = scale.length * octaves;
    
    fractions.forEach((f, i) => {
        // Map fraction value (0-1) to scale position
        let scalePos = Math.floor(f.value * totalScaleNotes);
        scalePos = Math.max(0, Math.min(totalScaleNotes - 1, scalePos));
        
        const octave = Math.floor(scalePos / scale.length) + style.octaveRange[0];
        const noteInScale = scalePos % scale.length;
        const semitones = scale[noteInScale] + (octave * 12);
        const freq = baseFreq * Math.pow(2, semitones / 12);
        
        // Calculate velocity/dynamics
        let velocity = 0.5;
        if (style.dynamics === 'crescendo') {
            velocity = 0.3 + (i / fractions.length) * 0.6;
        } else if (style.dynamics === 'aggressive') {
            velocity = 0.6 + Math.random() * 0.3;
        } else if (style.dynamics === 'heavy') {
            velocity = 0.7;
        } else if (style.dynamics === 'fanfare') {
            velocity = f.isPrime ? 0.9 : 0.6;
        } else if (style.dynamics === 'gentle') {
            velocity = 0.3 + Math.random() * 0.2;
        } else if (style.dynamics === 'buildUp') {
            // Slow build from very quiet to very loud
            const phase = i / fractions.length;
            velocity = 0.1 + Math.pow(phase, 2) * 0.8;
        } else if (style.dynamics === 'explosive') {
            // Random explosive hits
            velocity = (i % 8 < 5) ? 0.7 + Math.random() * 0.3 : 0.3;
        } else if (style.dynamics === 'intense') {
            velocity = 0.6 + Math.sin(i * 0.5) * 0.2 + Math.random() * 0.2;
        } else if (style.dynamics === 'sinister') {
            // Low rumble with occasional spikes
            velocity = 0.4 + (f.isPrime ? 0.4 : 0) + Math.random() * 0.1;
        } else if (style.dynamics === 'slashing') {
            // Sharp attacks
            velocity = 0.5 + ((i % 3 === 0) ? 0.4 : 0);
        } else if (style.dynamics === 'determined') {
            // Steady with emphasis on beat
            velocity = 0.5 + ((i % 4 === 0) ? 0.3 : 0);
        } else if (style.dynamics === 'flowing') {
            velocity = 0.4 + Math.sin(i * 0.2) * 0.2;
        }
        
        // Accent primes
        if (style.accentPrimes && f.isPrime) {
            velocity = Math.min(1, velocity + 0.2);
        }
        
        sequence.push({
            freq,
            velocity,
            fraction: f,
            scaleNote: noteInScale,
            octave,
            index: i
        });
    });
    
    // Generate bass line
    const bassSequence = [];
    if (document.getElementById('musicAddBass').checked) {
        const bassOctave = style.octaveRange[0] - 1;
        let lastBassNote = 0;
        
        for (let i = 0; i < sequence.length; i += 4) {
            const rootSemitones = scale[0] + (bassOctave * 12);
            const fifthSemitones = scale[Math.min(4, scale.length - 1)] + (bassOctave * 12);
            
            const useFifth = (i / 4) % 2 === 1;
            const semitones = useFifth ? fifthSemitones : rootSemitones;
            const freq = baseFreq * Math.pow(2, semitones / 12);
            
            bassSequence.push({
                freq,
                velocity: style.bassWeight * 0.5,
                startIndex: i,
                duration: 4
            });
        }
    }
    
    // Generate drum sequence
    const drumSequence = [];
    if (document.getElementById('musicAddDrums').checked) {
        for (let i = 0; i < sequence.length; i++) {
            const beatInMeasure = i % 8;
            
            // Kick on 1 and 5 (or every 4 for intense styles)
            if (beatInMeasure === 0 || beatInMeasure === 4 || 
                (style.dynamics === 'aggressive' && beatInMeasure % 2 === 0) ||
                (style.dynamics === 'explosive' && i % 3 === 0)) {
                drumSequence.push({ type: 'kick', index: i, velocity: 0.7 });
            }
            
            // Snare on 2 and 6 (backbeat)
            if (beatInMeasure === 2 || beatInMeasure === 6) {
                drumSequence.push({ type: 'snare', index: i, velocity: 0.6 });
            }
            
            // Hi-hat on every beat for intense styles
            if (style.bpmMultiplier >= 1.0) {
                drumSequence.push({ type: 'hihat', index: i, velocity: 0.3 + (beatInMeasure % 2 === 0 ? 0.1 : 0) });
            } else if (beatInMeasure % 2 === 0) {
                drumSequence.push({ type: 'hihat', index: i, velocity: 0.25 });
            }
            
            // Crash on phrase starts (every 16 notes)
            if (i % 16 === 0 && i > 0) {
                drumSequence.push({ type: 'crash', index: i, velocity: 0.5 });
            }
        }
    }
    
    return { sequence, bassSequence, drumSequence };
}

function toggleMathMusic() {
    if (musicGenerator.isPlaying) {
        stopMathMusic();
    } else {
        startMathMusic();
    }
}

function startMathMusic() {
    initAudioContext();
    stopMathMusic();
    
    const generated = generateMathSequence();
    musicGenerator.sequence = generated.sequence;
    musicGenerator.bassSequence = generated.bassSequence;
    musicGenerator.drumSequence = generated.drumSequence || [];
    
    if (musicGenerator.sequence.length === 0) {
        document.getElementById('musicStatusDisplay').textContent = 'No data to generate music - run computation first';
        return;
    }
    
    musicGenerator.isPlaying = true;
    musicGenerator.noteIndex = 0;
    musicGenerator.startTime = Date.now();
    
    const btn = document.getElementById('musicPlayBtn');
    btn.innerHTML = '<span style="font-size:18px;">‚è∏</span> Playing...';
    btn.style.background = 'linear-gradient(135deg,#ef4444,#dc2626)';
    
    document.getElementById('musicProgressBar').style.display = 'block';
    
    // Draw initial visualization
    drawMusicVisualization();
    
    // Start playback loop
    playMathMusicNote();
}

function stopMathMusic() {
    musicGenerator.isPlaying = false;
    
    if (musicGenerator.intervalId) {
        clearTimeout(musicGenerator.intervalId);
        musicGenerator.intervalId = null;
    }
    
    // Stop any playing oscillators
    musicGenerator.oscillators.forEach(osc => {
        try { osc.stop(); } catch(e) {}
    });
    musicGenerator.oscillators = [];
    
    stopAudio();
    
    const btn = document.getElementById('musicPlayBtn');
    btn.innerHTML = '<span style="font-size:18px;">‚ñ∂</span> Generate & Play';
    btn.style.background = 'linear-gradient(135deg,#22c55e,#16a34a)';
    
    document.getElementById('musicProgressBar').style.display = 'none';
    document.getElementById('musicStatusDisplay').textContent = 'Ready to generate mathematical music';
    document.getElementById('musicCurrentNote').textContent = '‚Äî';
}

function playMathMusicNote() {
    if (!musicGenerator.isPlaying) return;
    
    const seq = musicGenerator.sequence;
    const duration = parseInt(document.getElementById('musicDuration').value) || 16;
    const bpm = parseInt(document.getElementById('musicBPM').value) || 120;
    const style = musicGenerator.styles[musicGenerator.currentStyle];
    const actualBPM = bpm * style.bpmMultiplier;
    const msPerBeat = 60000 / actualBPM;
    const msPerNote = msPerBeat / 2; // Eighth notes
    
    // Check if done
    if (duration > 0 && musicGenerator.noteIndex >= Math.min(seq.length, duration * 8)) {
        stopMathMusic();
        document.getElementById('musicStatusDisplay').textContent = 'Composition complete!';
        return;
    }
    
    // Loop if infinite
    const idx = musicGenerator.noteIndex % seq.length;
    const note = seq[idx];
    
    // Play the note
    playMusicTone(note.freq, msPerNote / 1000 * 0.9, note.velocity);
    
    // Play bass if it's time
    const bassNote = musicGenerator.bassSequence.find(b => b.startIndex === idx);
    if (bassNote) {
        playMusicTone(bassNote.freq, msPerNote / 1000 * bassNote.duration * 0.9, bassNote.velocity, 'triangle');
    }
    
    // Play drums if enabled
    const drums = musicGenerator.drumSequence.filter(d => d.index === idx);
    drums.forEach(drum => {
        playDrumSound(drum.type, drum.velocity);
    });
    
    // Update display
    const noteName = frequencyToNoteName(note.freq);
    document.getElementById('musicCurrentNote').textContent = noteName;
    
    const fracStr = note.fraction ? `${note.fraction.r}/${note.fraction.m}` : '';
    document.getElementById('musicStatusDisplay').textContent = 
        `${style.name} | Note ${idx + 1}/${seq.length} | ${fracStr} ‚Üí ${noteName} (${note.freq.toFixed(0)} Hz)`;
    
    // Update progress
    const progress = duration > 0 ? (musicGenerator.noteIndex / (duration * 8)) * 100 : (idx / seq.length) * 100;
    document.getElementById('musicProgressFill').style.width = progress + '%';
    
    // Visual feedback
    const overlay = document.getElementById('musicNoteOverlay');
    overlay.textContent = noteName;
    overlay.style.opacity = note.velocity;
    setTimeout(() => { overlay.style.opacity = '0'; }, msPerNote * 0.5);
    
    // Update visualization
    drawMusicVisualization(idx);
    
    musicGenerator.noteIndex++;
    musicGenerator.intervalId = setTimeout(playMathMusicNote, msPerNote);
}

function playMusicTone(freq, duration, volume, waveType = 'sawtooth') {
    if (!audioCtx) return;
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    
    osc.type = waveType;
    osc.frequency.value = freq;
    
    filter.type = 'lowpass';
    filter.frequency.value = 2000 + volume * 3000;
    filter.Q.value = 1;
    
    const vol = volume * (harmonicSettings?.volume || 0.5) * 0.4;
    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(vol * 0.3, audioCtx.currentTime + duration * 0.5);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);
    
    osc.start();
    osc.stop(audioCtx.currentTime + duration + 0.1);
    
    musicGenerator.oscillators.push(osc);
    
    // Cleanup
    setTimeout(() => {
        const idx = musicGenerator.oscillators.indexOf(osc);
        if (idx > -1) musicGenerator.oscillators.splice(idx, 1);
    }, (duration + 0.2) * 1000);
}

function playDrumSound(type, velocity) {
    if (!audioCtx) return;
    
    const vol = velocity * (harmonicSettings?.volume || 0.5) * 0.5;
    const now = audioCtx.currentTime;
    
    if (type === 'kick') {
        // Kick drum - sine wave with pitch drop
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
        
        gain.gain.setValueAtTime(vol * 1.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.3);
        
    } else if (type === 'snare') {
        // Snare - noise burst + tone
        const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
            noiseData[i] = Math.random() * 2 - 1;
        }
        
        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;
        
        const noiseGain = audioCtx.createGain();
        const noiseFilter = audioCtx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 1000;
        
        noiseGain.gain.setValueAtTime(vol * 0.8, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start(now);
        
        // Tone component
        const osc = audioCtx.createOscillator();
        const oscGain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = 180;
        oscGain.gain.setValueAtTime(vol * 0.5, now);
        oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        osc.connect(oscGain);
        oscGain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.1);
        
    } else if (type === 'hihat') {
        // Hi-hat - filtered noise
        const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.05, audioCtx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
            noiseData[i] = Math.random() * 2 - 1;
        }
        
        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 7000;
        
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(vol * 0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start(now);
        
    } else if (type === 'crash') {
        // Crash cymbal - long noise decay
        const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.8, audioCtx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
            noiseData[i] = Math.random() * 2 - 1;
        }
        
        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;
        
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 4000;
        
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(vol * 0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start(now);
    }
}

function frequencyToNoteName(freq) {
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const a4 = 440;
    const semitones = 12 * Math.log2(freq / a4);
    const noteNum = Math.round(semitones) + 69; // MIDI note number
    const octave = Math.floor(noteNum / 12) - 1;
    const noteName = noteNames[noteNum % 12];
    return noteName + octave;
}

function drawMusicVisualization(currentIdx = -1) {
    const canvas = document.getElementById('musicVisualizerCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const seq = musicGenerator.sequence;
    if (seq.length === 0) return;
    
    const barWidth = Math.max(2, W / Math.min(seq.length, 200));
    const visibleNotes = Math.min(seq.length, Math.floor(W / barWidth));
    const startIdx = Math.max(0, currentIdx - Math.floor(visibleNotes / 2));
    
    // Find frequency range for scaling
    const freqs = seq.map(n => n.freq);
    const minFreq = Math.min(...freqs);
    const maxFreq = Math.max(...freqs);
    const freqRange = maxFreq - minFreq || 1;
    
    // Draw notes
    for (let i = 0; i < visibleNotes && (startIdx + i) < seq.length; i++) {
        const note = seq[startIdx + i];
        const x = i * barWidth;
        const normalizedFreq = (note.freq - minFreq) / freqRange;
        const barHeight = 20 + normalizedFreq * (H - 40);
        const y = H - barHeight - 10;
        
        const isCurrent = (startIdx + i) === currentIdx;
        
        // Color based on velocity and current state
        if (isCurrent) {
            ctx.fillStyle = '#22c55e';
            ctx.shadowColor = '#22c55e';
            ctx.shadowBlur = 15;
        } else {
            const hue = 260 - normalizedFreq * 60;
            ctx.fillStyle = `hsla(${hue}, 70%, ${40 + note.velocity * 30}%, ${0.5 + note.velocity * 0.5})`;
            ctx.shadowBlur = 0;
        }
        
        ctx.fillRect(x, y, barWidth - 1, barHeight);
        
        // Mark primes
        if (note.fraction && note.fraction.isPrime) {
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(x + barWidth / 2, y - 5, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    ctx.shadowBlur = 0;
    
    // Draw playhead line
    if (currentIdx >= 0) {
        const playheadX = Math.floor(visibleNotes / 2) * barWidth;
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(playheadX, 0);
        ctx.lineTo(playheadX, H);
        ctx.stroke();
    }
}


function exportMathMusicMIDI() {
    // Export as a simple text representation (real MIDI would require a library)
    const seq = musicGenerator.sequence;
    if (seq.length === 0) {
        alert('Generate music first!');
        return;
    }
    
    let csv = 'Mathematical Music Sequence Export\n';
    csv += 'Style: ' + musicGenerator.currentStyle + '\n';
    csv += 'Scale: ' + document.getElementById('musicScale').value + '\n';
    csv += 'BPM: ' + document.getElementById('musicBPM').value + '\n\n';
    csv += 'Index,Frequency,Note,Velocity,Fraction,Sector,IsPrime\n';
    
    seq.forEach((note, i) => {
        const noteName = frequencyToNoteName(note.freq);
        const frac = note.fraction ? `${note.fraction.r}/${note.fraction.m}` : '';
        const sector = note.fraction ? note.fraction.sector : '';
        const isPrime = note.fraction ? note.fraction.isPrime : false;
        csv += `${i},${note.freq.toFixed(2)},${noteName},${note.velocity.toFixed(2)},${frac},${sector},${isPrime}\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `math_music_${musicGenerator.currentStyle}_${Date.now()}.csv`;
    a.click();
}

// Initialize music style buttons on load
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => setMusicStyle('epic'), 100);
});

</script>
</body>
                               </html>
