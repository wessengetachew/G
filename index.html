<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farey Sector Formula - Complete Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0f1a; color: #e2e8f0; line-height: 1.6; font-size: 14px; }
        
        /* GLOBAL HARMONIC TOOLBAR - TOP DROPDOWN */
        .harmonic-toolbar {
            background: linear-gradient(90deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);
            border-bottom: 2px solid #8b5cf6;
            position: sticky;
            top: 38px;
            z-index: 500;
        }
        .harmonic-toolbar-header {
            display: flex;
            align-items: center;
            padding: 6px 15px;
            cursor: pointer;
            gap: 15px;
        }
        .harmonic-toolbar-header:hover { background: rgba(139, 92, 246, 0.1); }
        .harmonic-toolbar-toggle {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .harmonic-toolbar-toggle:hover { opacity: 0.9; }
        .harmonic-toolbar-toggle .icon { font-size: 14px; }
        .harmonic-toolbar-toggle.playing { background: linear-gradient(135deg, #22c55e, #16a34a); animation: pulse 0.5s infinite; }
        .harmonic-quick-display {
            display: flex;
            align-items: center;
            gap: 20px;
            flex: 1;
            margin-left: 15px;
        }
        .harmonic-quick-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }
        .harmonic-quick-item label { color: #94a3b8; font-size: 11px; }
        .harmonic-quick-item .value { color: #8b5cf6; font-weight: 600; font-family: monospace; font-size: 13px; }
        .harmonic-quick-item .note { color: #22c55e; font-weight: 600; font-size: 13px; }
        .harmonic-quick-btns {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }
        .harmonic-quick-btn {
            padding: 5px 10px;
            font-size: 11px;
            background: rgba(99, 102, 241, 0.3);
            border: 1px solid #6366f1;
            border-radius: 4px;
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .harmonic-quick-btn:hover { background: rgba(99, 102, 241, 0.5); transform: translateY(-1px); }
        .harmonic-quick-btn.play { background: rgba(34, 197, 94, 0.3); border-color: #22c55e; }
        .harmonic-quick-btn.play:hover { background: rgba(34, 197, 94, 0.5); }
        .harmonic-quick-btn.stop { background: rgba(239, 68, 68, 0.3); border-color: #ef4444; }
        .harmonic-quick-btn.stop:hover { background: rgba(239, 68, 68, 0.5); }
        
        .harmonic-panel-dropdown {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            background: #0f172a;
        }
        .harmonic-panel-dropdown.expanded { 
            max-height: 600px; 
            overflow-y: auto; 
        }
        .harmonic-panel-content {
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .harmonic-toolbar-header.expanded .harmonic-toolbar-toggle {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }
        #harmonicArrow.rotated {
            transform: rotate(180deg);
        }
        .harmonic-card {
            background: #1e293b;
            border-radius: 6px;
            padding: 12px;
            border: 1px solid #334155;
        }
        .harmonic-card h5 {
            color: #a5b4fc;
            font-size: 11px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .harmonic-card h5 .badge { background: #22c55e; padding: 2px 6px; border-radius: 8px; font-size: 8px; color: white; }
        .harmonic-card-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .harmonic-card-row:last-child { margin-bottom: 0; }
        .harmonic-card-row label { font-size: 10px; color: #94a3b8; min-width: 55px; }
        .harmonic-card-row input[type="range"] { flex: 1; height: 4px; cursor: pointer; }
        .harmonic-card-row input[type="number"] { width: 55px; padding: 3px 5px; font-size: 10px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; }
        .harmonic-card-row select { flex: 1; padding: 4px 6px; font-size: 10px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; }
        .harmonic-card-row .val { font-size: 10px; color: #8b5cf6; font-weight: 600; min-width: 40px; text-align: right; font-family: monospace; }
        
        .interval-grid-compact { display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px; }
        .interval-btn-sm { padding: 5px 3px; font-size: 9px; background: #0f172a; border: 1px solid #475569; border-radius: 3px; color: #e2e8f0; cursor: pointer; text-align: center; transition: all 0.2s; font-family: monospace; }
        .interval-btn-sm:hover { background: #334155; border-color: #6366f1; transform: translateY(-1px); }
        .interval-btn-sm.active { background: #6366f1; border-color: #8b5cf6; color: white; }
        
        .mode-badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 9px; font-weight: 600; }
        .mode-badge.unison { background: #22c55e30; color: #4ade80; }
        .mode-badge.consonant { background: #3b82f630; color: #60a5fa; }
        .mode-badge.complex { background: #f59e0b30; color: #fbbf24; }
        .mode-badge.dissonant { background: #ef444430; color: #f87171; }
        
        .freq-box { background: #0f172a; padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #334155; }
        .freq-box .big { font-size: 20px; font-weight: bold; color: #8b5cf6; font-family: monospace; }
        .freq-box .small { font-size: 11px; color: #64748b; margin-top: 2px; }
        
        .arnold-canvas-sm { width: 100%; height: 70px; background: #0f172a; border-radius: 4px; border: 1px solid #334155; display: block; }
        .spectrum-canvas-sm { width: 100%; height: 40px; background: #0f172a; border-radius: 4px; border: 1px solid #334155; display: block; }
        
        .keyboard-row { display: flex; gap: 1px; height: 28px; }
        .key-white { flex: 1; background: linear-gradient(180deg, #f1f5f9, #cbd5e1); border-radius: 0 0 2px 2px; cursor: pointer; min-width: 14px; }
        .key-white:hover { background: #a5b4fc; }
        .key-white.active { background: #6366f1; }
        .key-black { width: 12px; background: linear-gradient(180deg, #1e293b, #0f172a); margin: 0 -6px; z-index: 1; height: 18px; border-radius: 0 0 2px 2px; cursor: pointer; }
        .key-black:hover { background: #475569; }
        .key-black.active { background: #8b5cf6; }
        
        .nav-links { background: linear-gradient(90deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%); padding: 8px 15px; border-bottom: 1px solid #4338ca; overflow-x: auto; white-space: nowrap; position: sticky; top: 0; z-index: 500; }
        .nav-links::-webkit-scrollbar { height: 4px; }
        .nav-links::-webkit-scrollbar-track { background: #1e1b4b; }
        .nav-links::-webkit-scrollbar-thumb { background: #6366f1; border-radius: 2px; }
        .nav-links a { display: inline-block; padding: 4px 10px; margin: 2px 3px; background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.4); border-radius: 4px; color: #a5b4fc; text-decoration: none; font-size: 11px; font-weight: 500; transition: all 0.2s; }
        .nav-links a:hover { background: rgba(99, 102, 241, 0.4); color: #e0e7ff; border-color: #6366f1; transform: translateY(-1px); }
        .nav-links-label { color: #64748b; font-size: 10px; margin-right: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; overflow-y: auto; padding: 20px; }
        .modal-overlay.active { display: flex; justify-content: center; align-items: flex-start; }
        .modal-content { background: #1e293b; border-radius: 12px; max-width: 900px; width: 100%; border: 1px solid #475569; margin: 20px auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 18px; border-bottom: 1px solid #334155; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border-radius: 12px 12px 0 0; }
        .modal-header h3 { margin: 0; font-size: 1.1em; }
        .modal-close { background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 16px; }
        .modal-body { padding: 18px; max-height: 75vh; overflow-y: auto; }
        
        .container { max-width: 1800px; margin: 0 auto; padding: 15px; }
        h1 { color: #f8fafc; font-size: 1.5em; margin-bottom: 4px; }
        .subtitle { color: #94a3b8; margin-bottom: 15px; font-size: 0.9em; }
        h2 { color: #f1f5f9; font-size: 1.1em; margin: 20px 0 12px 0; border-bottom: 1px solid #334155; padding-bottom: 6px; }
        h3 { color: #cbd5e1; font-size: 1em; margin: 12px 0 8px 0; }
        h4 { color: #94a3b8; font-size: 0.9em; margin: 8px 0 6px 0; }
        
        .formula-box { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        .formula-main { font-size: 1.3em; font-weight: bold; font-family: 'Cambria Math', serif; text-align: center; margin: 8px 0; }
        
        .control-panel { background: #1e293b; padding: 12px 15px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #334155; }
        .control-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .control-row:last-child { margin-bottom: 0; }
        .control-group { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: #0f172a; border-radius: 5px; }
        .control-group.highlight { border: 1px solid #6366f1; background: #1e1b4b; }
        label { font-weight: 600; color: #cbd5e1; font-size: 0.8em; white-space: nowrap; }
        input[type="number"], input[type="text"], select, textarea { padding: 6px 8px; font-size: 13px; border: 1px solid #475569; border-radius: 5px; background: #1e293b; color: #e2e8f0; }
        input[type="number"] { width: 70px; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }
        select { min-width: 90px; }
        button { padding: 8px 14px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { opacity: 0.9; }
        button.secondary { background: #334155; border: 1px solid #475569; }
        button.small { padding: 5px 10px; font-size: 11px; }
        .info-badge { background: #334155; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; color: #94a3b8; }
        .info-badge strong { color: #e2e8f0; }
        .info-badge.success { background: #14532d; border: 1px solid #16a34a; }
        .info-badge.warning { background: #713f12; border: 1px solid #a16207; }
        
        .mode-selector { display: flex; gap: 4px; }
        .mode-btn { padding: 6px 12px; background: #1e293b; border: 1px solid #475569; border-radius: 5px; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .mode-btn.active { background: #6366f1; border-color: #6366f1; color: white; }
        
        .tabs { display: flex; gap: 3px; margin-bottom: 12px; flex-wrap: wrap; }
        .tab { padding: 6px 12px; background: #1e293b; border: 1px solid #334155; border-radius: 5px 5px 0 0; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .tab.active { background: #334155; color: #f1f5f9; border-bottom-color: #334155; }
        .tab:hover { color: #e2e8f0; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .panel { background: #1e293b; border-radius: 8px; padding: 15px; border: 1px solid #334155; margin-bottom: 15px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
        .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        @media (max-width: 1200px) { .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; } }
        
        .chart-box { background: #0f172a; border-radius: 6px; padding: 12px; border: 1px solid #334155; }
        .chart-box h4 { margin-top: 0; }
        canvas { max-width: 100%; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.8em; }
        thead { background: #334155; }
        th { padding: 8px; text-align: left; font-weight: 600; color: #e2e8f0; }
        td { padding: 6px 8px; border-bottom: 1px solid #334155; }
        tbody tr:hover { background: #334155; }
        .table-scroll { max-height: 350px; overflow-y: auto; }
        
        .detail-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .detail-card { background: #0f172a; padding: 12px; border-radius: 6px; border: 1px solid #334155; }
        .detail-card h5 { color: #94a3b8; font-size: 0.75em; margin-bottom: 6px; text-transform: uppercase; }
        .detail-card .value { font-size: 1.2em; font-weight: bold; color: #6366f1; }
        .detail-card .sub { font-size: 0.8em; color: #64748b; margin-top: 3px; }
        
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
        .stat-card { background: #0f172a; padding: 10px; border-radius: 5px; border: 1px solid #334155; text-align: center; }
        .stat-value { font-size: 1.1em; font-weight: bold; color: #6366f1; }
        .stat-label { font-size: 0.7em; color: #94a3b8; margin-top: 3px; }
        
        .theorem-box { background: #1e1b4b; border-left: 3px solid #6366f1; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .derivation-box { background: #422006; border-left: 3px solid #f59e0b; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .rh-box { background: #450a0a; border-left: 3px solid #ef4444; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .connection-box { background: #14532d; border-left: 3px solid #22c55e; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        
        .ring-canvas { background: #0f172a; border-radius: 6px; border: 1px solid #334155; cursor: crosshair; }
        .point-tooltip { position: absolute; background: #1e293b; border: 1px solid #6366f1; padding: 8px 12px; border-radius: 6px; font-size: 0.8em; pointer-events: none; z-index: 100; display: none; min-width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .point-tooltip.visible { display: block; }
        .point-tooltip h5 { color: #6366f1; margin: 0 0 6px 0; font-size: 1em; }
        .point-tooltip .row { display: flex; justify-content: space-between; margin: 2px 0; }
        .point-tooltip .label { color: #94a3b8; }
        .point-tooltip .val { color: #e2e8f0; font-weight: 600; }
        
        .color-legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 8px; padding: 8px; background: #0f172a; border-radius: 5px; font-size: 0.75em; }
        .color-legend-item { display: flex; align-items: center; gap: 5px; }
        .color-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #475569; }
        
        .progress-bar { width: 100%; height: 5px; background: #334155; border-radius: 3px; overflow: hidden; margin: 8px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); transition: width 0.3s; }
        
        .matrix-display { font-family: 'Courier New', monospace; background: #0f172a; padding: 10px; border-radius: 5px; display: inline-block; margin: 5px; }
        .matrix-bracket { font-size: 2em; line-height: 1; }
        
        .residue-list { max-height: 180px; overflow-y: auto; background: #0f172a; padding: 8px; border-radius: 5px; font-family: monospace; font-size: 0.8em; }
        .residue-item { display: inline-block; padding: 3px 8px; margin: 3px; background: #334155; border-radius: 3px; cursor: default; transition: background 0.2s; }
        .residue-item:hover { background: #475569; }
        .residue-item.prime { background: #854d0e; color: #fbbf24; border: 1px solid #f59e0b; }
        .residue-item.prime:hover { background: #a16207; }
        .residue-item.twin { background: #166534; color: #4ade80; }
        
        .latex-output { background: #0f172a; padding: 12px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; border: 1px solid #334155; max-height: 250px; overflow-y: auto; }
        
        .cf-path { font-family: monospace; background: #334155; padding: 2px 6px; border-radius: 3px; margin: 2px; display: inline-block; }
        
        .screenshot-btn { position: absolute; top: 8px; right: 8px; padding: 4px 8px; background: rgba(99,102,241,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn { position: absolute; top: 8px; right: 90px; padding: 4px 8px; background: rgba(168,85,247,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn:hover { background: rgba(168,85,247,1); }
        .chart-wrapper { position: relative; }
        .composite-export-btn { margin-top: 10px; padding: 10px 16px; font-size: 13px; background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%); }
        .composite-export-btn:hover { opacity: 0.95; }
        #compositeCanvas { display: none; max-width: 100%; margin-top: 10px; }
        .composite-info { background: #1e1b4b; border: 1px solid #8b5cf6; padding: 10px 12px; border-radius: 5px; margin-top: 10px; font-size: 0.85em; color: #cbd5e1; }
        
        .screenshot-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; justify-content: center; align-items: center; flex-direction: column; padding: 20px; }
        .screenshot-overlay.active { display: flex; }
        .screenshot-preview { max-width: 90%; max-height: 60vh; border: 2px solid #6366f1; border-radius: 8px; }
        .screenshot-actions { margin-top: 20px; display: flex; gap: 10px; }
        .screenshot-actions button { padding: 12px 24px; font-size: 14px; }
        
        .heatmap-cell { display: inline-block; width: 20px; height: 20px; margin: 1px; border-radius: 2px; }
        
        .euler-term { display: inline-block; padding: 4px 8px; margin: 3px; background: #1e293b; border-radius: 4px; border: 1px solid #334155; font-family: monospace; }
        .euler-term.prime { border-color: #f59e0b; }
    </style>
</head>
<body>
<div class="nav-links">
    <span class="nav-links-label">Projects:</span>
    <a href="https://wessengetachew.github.io/2025/" target="_blank">2025</a>
    <a href="https://wessengetachew.github.io/Transform/" target="_blank">Transform</a>
    <a href="https://wessengetachew.github.io/finite/" target="_blank">Finite</a>
    <a href="https://wessengetachew.github.io/Primes/" target="_blank">Primes</a>
    <a href="https://wessengetachew.github.io/Farey/" target="_blank">Farey</a>
    <a href="https://wessengetachew.github.io/Composite/" target="_blank">Composite</a>
    <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank">Ethiopian</a>
    <a href="https://wessengetachew.github.io/2pir/" target="_blank">2πr</a>
    <a href="https://wessengetachew.github.io/1-2/" target="_blank">1-2</a>
    <a href="https://wessengetachew.github.io/Rational-/" target="_blank">Rational</a>
    <a href="https://wessengetachew.github.io/Infinitemoduli/" target="_blank">Infinite Moduli</a>
    <a href="https://wessengetachew.github.io/Pythagorean-/" target="_blank">Pythagorean</a>
    <a href="https://wessengetachew.github.io/Phase/" target="_blank">Phase</a>
    <a href="https://wessengetachew.github.io/Gemini/" target="_blank">Gemini</a>
    <a href="https://wessengetachew.github.io/Rebuild/" target="_blank">Rebuild</a>
    <a href="https://wessengetachew.github.io/Goldbach/" target="_blank">Goldbach</a>
</div>

<!-- GLOBAL HARMONIC ANALYSIS PANEL - COMPLETE -->
<!-- HARMONIC TOOLBAR - COLLAPSED BY DEFAULT -->
<div class="harmonic-toolbar" id="harmonicToolbar">
    <div class="harmonic-toolbar-header" onclick="toggleHarmonicDropdown()">
        <button class="harmonic-toolbar-toggle" id="harmonicToggle">
            <span class="icon">♪</span>
            HARMONIC ANALYSIS
            <span id="harmonicArrow" style="margin-left:8px;transition:transform 0.3s;">▼</span>
        </button>
        <div class="harmonic-quick-display">
            <div class="harmonic-quick-item">
                <label>Selected:</label>
                <span class="value" id="quickFraction">1/2</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Freq:</label>
                <span class="value" id="quickFreq">110 Hz</span>
            </div>
            <div class="harmonic-quick-item">
                <label>Note:</label>
                <span class="note" id="quickNote">A2</span>
            </div>
            <div class="harmonic-quick-btns">
                <button class="harmonic-quick-btn play" onclick="event.stopPropagation(); playSelectedFraction();">▶</button>
                <button class="harmonic-quick-btn stop" onclick="event.stopPropagation(); stopAudio();">■</button>
            </div>
        </div>
    </div>
    <div class="harmonic-panel-dropdown" id="harmonicDropdown">
        <div class="harmonic-panel-content">
            <!-- AUDIO ENGINE -->
            <div class="harmonic-card">
                <h5>Audio Engine <span class="badge">LIVE</span></h5>
                <div class="harmonic-card-row">
                    <label>Base Hz:</label>
                    <input type="range" id="baseFreq" min="55" max="880" value="220" oninput="updateBaseFreq()">
                    <span class="val" id="baseFreqVal">220</span>
                </div>
                <div class="harmonic-card-row">
                    <label>Volume:</label>
                    <input type="range" id="harmonicVolume" min="0" max="100" value="30" oninput="updateHarmonicVolume()">
                    <span class="val" id="volumeVal">30%</span>
                </div>
                <div class="harmonic-card-row">
                    <label>Wave:</label>
                    <select id="waveform" onchange="updateWaveform()">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="square">Square</option>
                        <option value="sawtooth">Sawtooth</option>
                    </select>
                </div>
                <div class="freq-box" style="margin-top:8px;">
                    <div class="big" id="currentFreqDisplay">110 Hz</div>
                    <div class="small" id="currentNoteDisplay">1/2 = A2</div>
                </div>
            </div>
            
            <!-- MUSICAL INTERVALS -->
            <div class="harmonic-card">
                <h5>Musical Intervals</h5>
                <div class="interval-grid-compact">
                    <button class="interval-btn-sm" onclick="setInterval(1,1)" title="Unison">1:1</button>
                    <button class="interval-btn-sm" onclick="setInterval(16,15)" title="m2">16:15</button>
                    <button class="interval-btn-sm" onclick="setInterval(9,8)" title="M2">9:8</button>
                    <button class="interval-btn-sm" onclick="setInterval(6,5)" title="m3">6:5</button>
                    <button class="interval-btn-sm" onclick="setInterval(5,4)" title="M3">5:4</button>
                    <button class="interval-btn-sm" onclick="setInterval(4,3)" title="P4">4:3</button>
                    <button class="interval-btn-sm" onclick="setInterval(45,32)" title="TT">45:32</button>
                    <button class="interval-btn-sm" onclick="setInterval(3,2)" title="P5">3:2</button>
                    <button class="interval-btn-sm" onclick="setInterval(8,5)" title="m6">8:5</button>
                    <button class="interval-btn-sm" onclick="setInterval(5,3)" title="M6">5:3</button>
                    <button class="interval-btn-sm" onclick="setInterval(9,5)" title="m7">9:5</button>
                    <button class="interval-btn-sm" onclick="setInterval(15,8)" title="M7">15:8</button>
                    <button class="interval-btn-sm" onclick="setInterval(2,1)" title="Oct">2:1</button>
                    <button class="interval-btn-sm" onclick="setInterval(5,2)" title="10th">5:2</button>
                    <button class="interval-btn-sm" onclick="setInterval(3,1)" title="12th">3:1</button>
                    <button class="interval-btn-sm" onclick="setInterval(4,1)" title="2Oct">4:1</button>
                </div>
                <div style="margin-top:8px;display:flex;gap:4px;justify-content:center;">
                    <button class="harmonic-quick-btn play" onclick="playSelectedFraction()">▶ Play</button>
                    <button class="harmonic-quick-btn" onclick="playArpeggio()">Arpeggio</button>
                    <button class="harmonic-quick-btn" onclick="playChord()">Chord</button>
                    <button class="harmonic-quick-btn stop" onclick="stopAudio()">■ Stop</button>
                </div>
            </div>
            
            <!-- HARMONIC MODE -->
            <div class="harmonic-card">
                <h5>Harmonic Mode</h5>
                <div style="text-align:center;margin:8px 0;">
                    <span class="mode-badge consonant" id="harmonicModeIndicator">Consonant</span>
                    <span style="font-size:10px;color:#64748b;margin-left:6px;" id="modeQValue">q ≤ 4</span>
                </div>
                <div style="font-size:9px;color:#64748b;display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:8px;">
                    <div><span class="mode-badge unison" style="font-size:8px;">Unison</span> q=1</div>
                    <div><span class="mode-badge consonant" style="font-size:8px;">Consonant</span> q≤4</div>
                    <div><span class="mode-badge complex" style="font-size:8px;">Complex</span> q≤16</div>
                    <div><span class="mode-badge dissonant" style="font-size:8px;">Dissonant</span> q>16</div>
                </div>
            </div>
            
            <!-- ARNOLD TONGUE PREVIEW -->
            <div class="harmonic-card">
                <h5>Arnold Tongue</h5>
                <canvas id="arnoldMiniCanvas" class="arnold-canvas-sm" width="200" height="70"></canvas>
                <div class="harmonic-card-row" style="margin-top:6px;">
                    <label>K:</label>
                    <input type="range" id="arnoldK" min="0" max="100" value="50" oninput="updateArnoldTongue()">
                    <span class="val" id="arnoldKVal">0.50</span>
                </div>
            </div>
            
            <!-- HARMONIC SERIES -->
            <div class="harmonic-card">
                <h5>Harmonic Series</h5>
                <div class="harmonic-card-row">
                    <label>Partials:</label>
                    <input type="range" id="numPartials" min="1" max="16" value="8" oninput="updateHarmonicSeries()">
                    <span class="val" id="partialsVal">8</span>
                </div>
                <canvas id="harmonicSeriesCanvas" class="spectrum-canvas-sm" width="200" height="40"></canvas>
                <div style="margin-top:6px;display:flex;gap:4px;">
                    <button class="harmonic-quick-btn" onclick="playHarmonicSeries()" style="flex:1;">Harmonic</button>
                    <button class="harmonic-quick-btn" onclick="playSubharmonicSeries()" style="flex:1;">Subharmonic</button>
                </div>
            </div>
            
            <!-- GLOBAL OPTIONS -->
            <div class="harmonic-card">
                <h5>Options</h5>
                <div style="font-size:10px;display:flex;flex-direction:column;gap:4px;">
                    <label><input type="checkbox" id="applyHarmonicColor" onchange="applyHarmonicColoring()"> Color by consonance</label>
                    <label><input type="checkbox" id="showArnoldOnTree" onchange="drawSectorTree()"> Arnold on tree</label>
                    <label><input type="checkbox" id="autoPlayOnClick" checked> Auto-play on click</label>
                    <label><input type="checkbox" id="showFreqOnHover"> Show freq on hover</label>
                </div>
            </div>
        
            <!-- SELECTED FRACTION -->
            <div class="harmonic-card">
                <h5>Selected Fraction</h5>
                <div id="selectedFractionInfo" style="font-size:10px;color:#94a3b8;">
                    Click any point to select
                </div>
            </div>
            
            <!-- RESET BUTTON -->
            <div class="harmonic-card" style="text-align:center;">
                <button class="harmonic-quick-btn" onclick="resetHarmonicDefaults()" style="padding:6px 12px;">Reset Defaults</button>
            </div>
        </div>
    </div>
</div>
<div class="container">
    <h1>Farey Sector Formula - Complete Research Platform</h1>
    <p class="subtitle">Comprehensive analysis with RH connections, modular arithmetic, and advanced visualizations</p>
    
    <div class="formula-box">
        <div class="formula-main">C(n, N) = 3N² / (π² n(n+1))</div>
        <p style="text-align:center; font-size:0.85em; opacity:0.9;">Asymptotic count of coprime pairs (r, m) with r/m in sector S_n = (1/(n+1), 1/n]</p>
    </div>
    
    <div class="control-panel">
        <div class="control-row">
            <label>Mode:</label>
            <div class="mode-selector">
                <div class="mode-btn active" onclick="setMode('exact')" id="mode-exact">Exact</div>
                <div class="mode-btn" onclick="setMode('hybrid')" id="mode-hybrid">Hybrid</div>
                <div class="mode-btn" onclick="setMode('formula')" id="mode-formula">Formula</div>
            </div>
            <span class="info-badge" id="modeDescription">Exact enumeration</span>
        </div>
        <div class="control-row">
            <div class="control-group highlight">
                <label>N:</label>
                <input type="number" id="nMin" value="100" min="2"> to
                <input type="number" id="nMax" value="100" min="2">
            </div>
            <div class="control-group highlight">
                <label>Sectors:</label>
                <input type="number" id="sectorMin" value="1" min="1"> to
                <input type="number" id="sectorMax" value="15" min="1">
            </div>
            <button onclick="computeAll()">Compute</button>
            <button class="secondary" onclick="cancelComputation()">Cancel</button>
            <button class="secondary" onclick="exportAllData()">Export All</button>
            <button class="composite-export-btn" onclick="exportCompositeTab()" title="Export all visible charts to single 4K image">4K Composite Export</button>
        </div>
        <div class="progress-bar" id="progressBar" style="display:none;"><div class="progress-fill" id="progressFill"></div></div>
        <div id="statusArea"></div>
    </div>
    
    <div class="tabs">
        <div class="tab active" onclick="switchTab('main')">Main</div>
        <div class="tab" onclick="switchTab('theory')">Theory</div>
        <div class="tab" onclick="switchTab('theoryviz')">Theory Viz</div>
        <div class="tab" onclick="switchTab('gaps')">Gaps</div>
        <div class="tab" onclick="switchTab('franel')">Franel-Landau</div>
        <div class="tab" onclick="switchTab('dedekind')">Dedekind</div>
        <div class="tab" onclick="switchTab('cf')">Continued Fractions</div>
        <div class="tab" onclick="switchTab('psl')">PSL(2,Z)</div>
        <div class="tab" onclick="switchTab('euler')">Euler Product</div>
        <div class="tab" onclick="switchTab('modular')">Modular</div>
        <div class="tab" onclick="switchTab('3d')">3D View</div>
        <div class="tab" onclick="switchTab('hyperbolic')">Hyperbolic</div>
        <div class="tab" onclick="switchTab('animation')">Animation</div>
        <div class="tab" onclick="switchTab('smith')">Smith Chart</div>
        <div class="tab" onclick="switchTab('stats')">Statistics</div>
        <div class="tab" onclick="switchTab('primes')">Primes</div>
        <div class="tab" onclick="switchTab('harmonic')">Harmonic</div>
        <div class="tab" onclick="switchTab('primorial')">Primorial Sieve</div>
        <div class="tab" onclick="switchTab('research')">Research</div>
    </div>
    
    <!-- MAIN TAB -->
    <div id="tab-main" class="tab-content active">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #6366f1;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Main Sector Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#6366f1;">C(n,N) = 3N² / (π² n(n+1))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;"><strong>Definition:</strong> Sectors are defined by consecutive Farey bounds: sector S_n spans the interval (1/(n+1), 1/n], a decreasing sequence of intervals that partition [0,1]. <strong>Formula Purpose:</strong> This asymptotic formula provides increasingly accurate predictions of the count of coprime pairs (r,m) with r/m in sector S_n, where N is the maximum denominator. As N grows, the accuracy of this prediction improves significantly. The formula shows how the Farey sequence distributes its fractions across the unit interval with mathematical precision.</p>
        </div>
        <div class="stat-grid" id="mainStats"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Exact vs Predicted</h4><canvas id="mainCountChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Relative Error %</h4><canvas id="mainErrorChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px;">
            <h4>Sector Data <span style="font-weight:normal; color:#64748b;">(click row to see primes)</span></h4>
            <div class="table-scroll"><table id="mainTable"><thead><tr><th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th><th>Primes</th><th>Composites</th></tr></thead><tbody></tbody></table></div>
        </div>
        <div class="panel chart-wrapper">
            <h4>Sector Ring <span style="font-weight:normal; color:#64748b;">(click points to see tree path)</span></h4>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Sector: <input type="number" id="viewSector" value="1" min="1" onchange="drawMainRing()"></label>
                <label>Color: <select id="colorMode" onchange="drawMainRing()"><option value="sector">Sector</option><option value="prime">Prime</option><option value="denominator">Denom</option><option value="gap">Gap</option></select></label>
                <label><input type="checkbox" id="showAllSectors" onchange="drawMainRing()"> All</label>
                <button class="secondary" onclick="openSectorModal(+document.getElementById('viewSector').value)">View Sector Details</button>
            </div>
            <div style="text-align:center;position:relative;"><canvas id="mainRing" class="ring-canvas" width="600" height="600"></canvas><div class="point-tooltip" id="pointTooltip"></div></div>
            <div class="color-legend" id="colorLegend"></div>
            <div style="margin-top:10px;"><button onclick="screenshotFullTab('main')">Screenshot Full Main Tab</button></div>
        </div>
        
        <div class="panel chart-wrapper">
            <h4>Sector Tree Path <span style="font-weight:normal; color:#64748b;">(Stern-Brocot navigation)</span></h4>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Tree Depth: <input type="number" id="treeDepth" value="8" min="3" max="15" onchange="drawSectorTree()"></label>
                <label><input type="checkbox" id="showTreeLabels" checked onchange="drawSectorTree()"> Labels</label>
                <label><input type="checkbox" id="showTreeGrid" onchange="drawSectorTree()"> Grid</label>
                <label><input type="checkbox" id="animatePath" checked> Animate</label>
                <button class="secondary" onclick="clearTreePath()">Clear Path</button>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playTreeFraction()" id="treePlayBtn" title="Play selected fraction">▶ Play</button>
                <button class="secondary" onclick="playTreeScale()" title="Play all fractions in path">♪ Scale</button>
            </div>
            <div style="text-align:center;position:relative;">
                <canvas id="sectorTreeCanvas" class="ring-canvas" width="900" height="500"></canvas>
            </div>
            <div id="treePathInfo" style="margin-top:10px; padding:10px; background:#0f172a; border-radius:5px; font-family:monospace; font-size:0.9em;">
                <span style="color:#64748b;">Click a point on the ring above to see its tree path</span>
            </div>
            <div class="color-legend">
                <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Tree nodes</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Path to target</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Target fraction</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>L (left)</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>R (right)</div>
                <div class="color-legend-item" style="border-left:1px solid #475569; padding-left:10px;"><strong style="color:#8b5cf6;">Arnold:</strong></div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Unison</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>Consonant</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Complex</div>
            </div>
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('main')" style="padding:12px 24px; font-size:14px;">Screenshot Full Main Tab</button>
            <button class="secondary" onclick="exportMainTabData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Main Tab Data</button>
        </div>
    </div>
    
    <!-- THEORY TAB -->
    <div id="tab-theory" class="tab-content">
        <div class="panel">
            <h2 style="text-align:center; font-size:1.3em; margin-bottom:8px;">Directional Density of Coprime Lattice Points in Farey Sectors</h2>
            <p style="text-align:center; color:#94a3b8; font-style:italic; margin-bottom:20px;">Wessen Getachew</p>
            
            <div class="theorem-box" style="background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%); border-left-color: #8b5cf6;">
                <h4 style="color:#e0e7ff; margin-top:0;">Abstract</h4>
                <p style="margin:0; font-size:0.95em;">We study the distribution of coprime integer pairs (a,b) with bounded height whose rational slope lies in a fixed Farey sector S_n = (1/(n+1), 1/n]. Using classical summatory totient estimates together with a geometric decomposition of rational directions, we derive an explicit asymptotic formula for the number of primitive lattice points in each sector. This result provides a localized refinement of the global coprime density 1/zeta(2), revealing directional structure in the distribution of visible lattice points.</p>
            </div>
            
            <h3 style="margin-top:20px;">1. Introduction and Motivation</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #f59e0b; margin:10px 0;">
                <p>The probability that two randomly chosen integers are coprime is 1/zeta(2) = 6/pi^2 approximately 0.6079, a classical result with interpretations in analytic number theory and geometry of numbers. Geometrically, this corresponds to the density of visible lattice points in Z^2.</p>
                <p style="margin-top:8px;">Farey sequences organize rational numbers in [0,1] by increasing denominator and naturally partition rational directions into intervals. While global coprime density is well understood, we focus on <strong>directional coprime density</strong> - how primitive lattice points distribute across specific rational slope bands.</p>
            </div>
            
            <h3 style="margin-top:20px;">2. Definitions</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Farey Sector</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        S_n = (1/(n+1), 1/n]
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Intervals partitioning (0,1], bounded by consecutive Farey fractions.</p>
                </div>
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Primitive Lattice Point</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        (a,b) in Z^2 where gcd(a,b) = 1, b >= 1
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Pairs with coprime coordinates representing visible lattice points.</p>
                </div>
            </div>
            
            <h3>3. Main Result</h3>
            <div class="derivation-box" style="background: linear-gradient(135deg, #422006 0%, #5a3a1a 100%); border-left-color: #fbbf24;">
                <strong style="color:#fcd34d; font-size:1.1em;">Farey Sector Density Theorem</strong>
                <p style="margin:12px 0 0 0;">Let n be fixed. As N approaches infinity, the number of coprime integer pairs with slope in the Farey sector S_n satisfies:</p>
                <div style="background:#0f172a; padding:12px; border-radius:5px; font-family:monospace; font-size:1em; margin:10px 0; text-align:center;">
                    <strong>C(n,N) ~ (3/pi^2) * N^2 / (n(n+1))</strong>
                </div>
                <p style="margin:10px 0 0 0; font-size:0.9em;">Where C(n,N) counts pairs (a,b) with 1 <= b <= N, gcd(a,b)=1, and a/b in S_n.</p>
            </div>
            
            <h3 style="margin-top:20px;">4. Proof Sketch</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #22c55e; margin:10px 0;">
                <p><strong>Step 1:</strong> The condition a/b in S_n = (1/(n+1), 1/n] is equivalent to b/(n+1) < a <= b/n.</p>
                <p style="margin:8px 0;"><strong>Step 2:</strong> For each b, the number of integers a in this range is b/(n(n+1)) + O(1).</p>
                <p style="margin:8px 0;"><strong>Step 3:</strong> Restricting to coprime pairs: Sum over b<=N of phi(b)/(n(n+1)) + O(N)</p>
                <p style="margin:8px 0;"><strong>Step 4:</strong> Apply the classical summatory totient estimate:</p>
                <div style="background:#0a0f1a; padding:8px; margin:8px 0; border-radius:4px; font-family:monospace;">
                    Sum of phi(b) = (3/pi^2)N^2 + O(N log N)
                </div>
                <p style="margin:8px 0;"><strong>Conclusion:</strong> C(n,N) = (1/(n(n+1))) * ((3/pi^2)N^2 + O(N log N))</p>
            </div>
            
            <h3 style="margin-top:20px;">5. Computational Verification</h3>
            <table style="width:100%; margin-top:10px; border-collapse:collapse; font-size:0.85em;">
                <thead><tr style="background:#334155;"><th style="padding:8px;">Sector n</th><th>Width 1/(n(n+1))</th><th>Asymptotic Factor</th><th>Global Fraction</th></tr></thead>
                <tbody>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">1</td><td style="padding:8px;">1/2</td><td style="padding:8px;">3/(2pi^2)</td><td style="padding:8px;">approximately 0.1519</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">2</td><td style="padding:8px;">1/6</td><td style="padding:8px;">3/(6pi^2)</td><td style="padding:8px;">approximately 0.0506</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">3</td><td style="padding:8px;">1/12</td><td style="padding:8px;">3/(12pi^2)</td><td style="padding:8px;">approximately 0.0253</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">n</td><td style="padding:8px;">1/(n(n+1))</td><td style="padding:8px;">3/(pi^2 n(n+1))</td><td style="padding:8px;">1/n(n+1) * 6/pi^2</td></tr>
                </tbody>
            </table>
            <p style="margin-top:10px; font-size:0.85em; color:#94a3b8;">Numerical experiments confirm convergence to predicted asymptotics at rates consistent with O(N log N) error decay. Interactive visualizations above display accumulation of primitive lattice points within each Farey sector.</p>
            
            <h3 style="margin-top:20px;">6. Key Theoretical Connections</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Euler and Coprime Density</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Global density 1/zeta(2) = 6/pi^2 emerges as sum of sectoral contributions.</p>
                </div>
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Franel-Landau Connection</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Farey gap distribution relates to RH via: Sum|F_k - k/|F_N|| = O(N^(1/2+epsilon)) iff RH</p>
                </div>
            </div>
            
            <h3>7. Conclusion</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #3b82f6; margin:10px 0;">
                <p style="margin:0;">Farey sectors provide a natural geometric decomposition of rational directions. By combining this structure with classical coprime density results, we obtain an explicit directional refinement of visible lattice point counts. This framework enables anisotropic analysis of arithmetic distributions and provides foundation for modular constraints, higher-dimensional generalizations, and computational number theory.</p>
            </div>
            
            <p style="margin-top:20px; text-align:center; color:#64748b; font-size:0.85em;">Acknowledgments: Foundational work of Euler, Mertens, and others on totient summation and Farey geometry.</p>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('theory')">Screenshot Full Theory Tab</button></div>
        </div>
    </div>
    
    <!-- THEORY VIZ TAB -->
    <div id="tab-theoryviz" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Interactive Theory Visualization</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Visual exploration of the Farey Sector Density Theorem with interactive elements</p>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Max Sectors:</label>
                    <input type="number" id="tvMaxSectors" value="8" min="3" max="20" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Max N:</label>
                    <input type="number" id="tvMaxN" value="150" min="20" max="500" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Lattice Size:</label>
                    <input type="number" id="tvLatticeSize" value="22" min="10" max="40" onchange="drawTheoryViz()">
                </div>
                <div class="control-group">
                    <label>Highlight Sector:</label>
                    <input type="number" id="tvHighlightSector" value="2" min="1" max="10" onchange="drawTheoryViz()">
                </div>
                <button onclick="drawTheoryViz()">Refresh All</button>
                <button class="secondary" onclick="animateTheoryViz()">Animate Growth</button>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Sector Partition of (0,1]</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowSectorValues" checked onchange="drawSectorPartition()"> Values</label>
                    <label><input type="checkbox" id="tvShowSectorWidths" onchange="drawSectorPartition()"> Widths</label>
                    <label>Style: <select id="tvPartitionStyle" onchange="drawSectorPartition()"><option value="bar">Bar</option><option value="arc">Arc</option><option value="number">Number Line</option></select></label>
                </div>
                <canvas id="sectorPartitionCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="sectorPartitionLegend"></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Cone: C(n,N) ~ N²/n(n+1)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sectors to show: <input type="number" id="tvConeSectors" value="4" min="1" max="10" onchange="drawDensityCone()"></label>
                    <label><input type="checkbox" id="tvShowConeRef" checked onchange="drawDensityCone()"> 6/π² ref</label>
                    <label><input type="checkbox" id="tvLogScale" onchange="drawDensityCone()"> Log Y</label>
                </div>
                <canvas id="densityConeCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="densityConeLegend"></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Summatory Totient: Σφ(b) ~ 3N²/π²</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowTotientActual" checked onchange="drawTotientSum()"> Actual</label>
                    <label><input type="checkbox" id="tvShowTotientPredicted" checked onchange="drawTotientSum()"> Predicted</label>
                    <label><input type="checkbox" id="tvShowTotientError" onchange="drawTotientSum()"> Error</label>
                    <label><input type="checkbox" id="tvTotientFill" onchange="drawTotientSum()"> Fill</label>
                </div>
                <canvas id="totientSumCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual Σφ(b)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Asymptotic 3N²/π²</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Visible Lattice Points by Direction</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowHidden" checked onchange="drawLatticeViz()"> Hidden pts</label>
                    <label><input type="checkbox" id="tvShowSectorLines" checked onchange="drawLatticeViz()"> Sector lines</label>
                    <label><input type="checkbox" id="tvColorBySector" onchange="drawLatticeViz()"> Color by sector</label>
                    <label>Point size: <input type="range" id="tvPointSize" min="2" max="8" value="4" onchange="drawLatticeViz()"></label>
                </div>
                <canvas id="latticeVizCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Visible (gcd=1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Hidden (gcd>1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Sector Boundary</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Proof Visualization: Step-by-Step Accumulation</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sector n: <input type="number" id="tvProofSector" value="2" min="1" max="10" onchange="drawProofSteps()"></label>
                    <label><input type="checkbox" id="tvShowContribBars" checked onchange="drawProofSteps()"> Contrib bars</label>
                    <label><input type="checkbox" id="tvShowProofPredicted" checked onchange="drawProofSteps()"> Predicted</label>
                </div>
                <canvas id="proofStepsCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Cumulative count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted asymptotic</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>φ(b)/(n(n+1)) contribution</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Convergence Rate Analysis</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Analysis type: <select id="tvConvergenceType" onchange="drawConvergenceAnalysis()"><option value="relative">Relative Error</option><option value="absolute">Absolute Error</option><option value="ratio">Actual/Predicted</option></select></label>
                    <label><input type="checkbox" id="tvShowConvergenceTrend" checked onchange="drawConvergenceAnalysis()"> Trend line</label>
                </div>
                <canvas id="convergenceCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="convergenceLegend"></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Sector Density Heatmap: C(n,N) across parameters</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>N range: <input type="number" id="tvHeatmapNMin" value="20" min="10" max="100"> to <input type="number" id="tvHeatmapNMax" value="150" min="50" max="300"></label>
                <label>Sectors: <input type="number" id="tvHeatmapSectors" value="10" min="3" max="15"></label>
                <label>Color: <select id="tvHeatmapColor" onchange="drawDensityHeatmap()"><option value="viridis">Viridis</option><option value="plasma">Plasma</option><option value="coolwarm">Cool-Warm</option></select></label>
                <button onclick="drawDensityHeatmap()">Generate</button>
            </div>
            <canvas id="densityHeatmapCanvas" width="1100" height="300"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#440154"></div>Low density</div><div class="color-legend-item"><div class="color-swatch" style="background:#21918c"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#fde725"></div>High density</div></div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Theorem Summary:</strong> For fixed sector n, as N approaches infinity: C(n,N) = (3/π²) × N² / (n(n+1)) + O(N log N). This follows from summing φ(b)/(n(n+1)) over denominators b ≤ N and applying the classical totient summation formula.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('theoryviz')">Screenshot Full Theory Viz Tab</button></div>
    </div>
    
    <!-- GAPS TAB -->
    <div id="tab-gaps" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Farey Gap Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.2em;text-align:center;color:#8b5cf6;">gap(a/b, c/d) = |c/d - a/b| = 1/(b*d)</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">For consecutive Farey fractions a/b and c/d, the gap between them equals exactly 1/(b*d). This elegant formula shows that gaps decrease as denominators grow. The distribution reveals how fractions cluster and spread across the unit interval.</p>
        </div>
        <div class="stat-grid" id="gapStats" style="margin-top:12px;"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Gap Distribution (Color = Size)</h4><canvas id="gapDistChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Gap vs Denominator Product</h4><canvas id="gapVsDenomChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px; background:#0f172a;">
            <h4>Largest Gaps <span style="font-weight:normal;color:#64748b;">(sorted by gap size)</span></h4>
            <div class="table-scroll">
                <table id="gapTable">
                    <thead><tr><th>#</th><th>Left Fraction</th><th>Right Fraction</th><th>Actual Gap</th><th>Theoretical 1/(bd)</th><th>Match</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        <div class="connection-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> Every gap exactly equals 1/(bd) where b and d are the denominators of consecutive Farey fractions. This is a consequence of the mediant property: for neighbors a/b and c/d, we have |ad - bc| = 1.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('gaps')">Screenshot Full Gaps Tab</button></div>
    </div>
    
    <!-- FRANEL-LANDAU TAB -->
    <div id="tab-franel" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #06b6d4;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Franel-Landau Theorem</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#06b6d4;">Σ|δ_k| = O(N^(1/2+ε)) ⟺ Riemann Hypothesis</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Define δ_k = F_k - k/|F_N| as the k-th Farey fraction deviation. The growth rate of Σ|δ_k| is directly equivalent to the Riemann Hypothesis. If RH is true, the sum grows slower than N^(1/2+ε) for any ε > 0. This provides a concrete computational test for RH properties through Farey sequence analysis. <strong style="color:#f87171;">Note: These computations illustrate known equivalences but do not constitute a proof or disproof of RH.</strong></p>
        </div>
        <div class="stat-grid" id="franelStats" style="margin-top:12px;"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Deviation δ_k vs k</h4><canvas id="franelDeviationChart"></canvas></div>
                <div class="chart-box"><h4>Cumulative |δ| / N^α</h4><canvas id="franelCumulativeChart"></canvas></div>
            </div>
            <div class="chart-box" style="margin-top:15px;"><h4>Σ|δ| / N^α for various α</h4><canvas id="franelAlphaChart"></canvas></div>
            <div class="derivation-box" style="margin-top:15px;"><strong>Interpretation:</strong> If RH is true, the normalized sum should stay bounded. Divergence for alpha <= 1/2 would contradict RH.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('franel')">Screenshot Full Franel Tab</button></div>
    </div>
    
    <!-- DEDEKIND TAB -->
    <div id="tab-dedekind" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #f59e0b;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Dedekind Sums</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#f59e0b;">s(h,k) = Σ_{j=1}^{k-1} ((j/k))((hj/k))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Dedekind sums are arithmetic functions encoding properties of coprime pairs (h,k). They satisfy reciprocity formulas: s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk)). These sums connect to modular forms and are fundamental in algebraic number theory.</p>
        </div>
        <div class="panel">
            <h3>Dedekind Sums</h3>
            <div class="theorem-box"><strong>Definition:</strong> s(h,k) = Σ_{j=1}^{k-1} ((j/k))((hj/k)) where ((x)) = x - ⌊x⌋ - 1/2 if x∉ℤ, else 0</div>
            <div class="control-row" style="margin:12px 0;"><label>Max k: <input type="number" id="dedekindMaxK" value="20" min="2" onchange="computeDedekind()"></label></div>
            <div class="grid-2">
                <div class="chart-box"><h4>s(h,k) Heatmap</h4><canvas id="dedekindHeatmap" width="400" height="400"></canvas></div>
                <div class="chart-box"><h4>s(1,k) vs k</h4><canvas id="dedekindChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Dedekind Sum Table</h4><div class="table-scroll"><table id="dedekindTable"><thead><tr><th>h</th><th>k</th><th>s(h,k)</th><th>12k·s(h,k)</th><th>gcd</th></tr></thead><tbody></tbody></table></div></div>
            <div class="connection-box" style="margin-top:12px;"><strong>Reciprocity:</strong> s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk))</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('dedekind')">Screenshot Full Dedekind Tab</button></div>
        </div>
    </div>
    
    <!-- CONTINUED FRACTIONS TAB -->
    <div id="tab-cf" class="tab-content">
        <div class="panel">
            <h3>Continued Fractions</h3>
            <div class="theorem-box"><strong>Stern-Brocot Encoding:</strong> Path L^a R^b L^c... encodes CF [0; a, b, c, ...]</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Sector: <input type="number" id="cfSector" value="2" min="1" onchange="updateCFDisplay()"></label>
                <label>Max terms: <input type="number" id="cfMaxTerms" value="50" onchange="updateCFDisplay()"></label>
                <button onclick="updateCFDisplay()">Refresh</button>
                <button style="background:linear-gradient(135deg,#22c55e,#16a34a);" onclick="playCFSelected()" title="Play selected CF fraction">▶ Play</button>
                <button class="secondary" onclick="playCFConvergents()" title="Play convergents as scale">♪ Convergents</button>
                <button class="secondary" onclick="playCFAll()" title="Play all fractions in sector">♪ All</button>
            </div>
            
            <div class="panel" style="background:#1e1b4b; border:1px solid #6366f1; margin-bottom:15px;">
                <h4 style="color:#a5b4fc; margin-top:0;">Selected Fraction</h4>
                <div id="cfSelectedInfo" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:12px;">
                    <div style="color:#64748b; grid-column:1/-1;">Click a row in the table below to select a fraction</div>
                </div>
            </div>
            
            <div class="panel" style="background:#0f172a;"><h4>Continued Fraction Expansions <span style="font-weight:normal;color:#64748b;">(click row to select & play)</span></h4><div class="table-scroll"><table id="cfTable"><thead><tr><th>r/m</th><th>CF [a0; a1, a2, ...]</th><th>Path</th><th>Length</th><th>Sum(a_i)</th><th>Freq</th><th>Play</th></tr></thead><tbody></tbody></table></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>CF Length Distribution</h4><canvas id="cfLengthChart"></canvas></div>
                <div class="chart-box"><h4>First Partial Quotient</h4><canvas id="cfFirstChart"></canvas></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('cf')">Screenshot Full CF Tab</button></div>
        </div>
    </div>
    
    <!-- PSL(2,Z) TAB -->
    <div id="tab-psl" class="tab-content">
        <div class="panel">
            <h3>PSL(2,ℤ) Matrices</h3>
            <div class="theorem-box"><strong>Farey Neighbor Property:</strong> For consecutive Farey fractions a/b, c/d: |ad - bc| = 1, giving matrix [a,c; b,d] ∈ SL(2,ℤ)</div>
            <div class="control-row" style="margin:12px 0;"><label>Max denom: <input type="number" id="pslMaxDenom" value="12" min="3" onchange="computePSL()"></label></div>
            <div class="panel" style="background:#0f172a;"><h4>Neighbor Matrices</h4><div id="pslMatrices" style="max-height:300px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Ford Circles</h4><canvas id="fordCanvas" width="500" height="250"></canvas></div>
                <div class="chart-box"><h4>Determinant Verification</h4><div id="pslVerification"></div></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('psl')">Screenshot Full PSL Tab</button></div>
        </div>
    </div>
    
    <!-- EULER PRODUCT TAB -->
    <div id="tab-euler" class="tab-content">
        <div class="panel">
            <h3>Euler Product for ζ(2)</h3>
            <div class="theorem-box"><strong>Euler:</strong> ζ(2) = Σ 1/n² = ∏_p 1/(1-1/p²) = π²/6, hence 6/π² = ∏_p (1-1/p²)</div>
            <div class="control-row" style="margin:12px 0;"><label>Primes up to: <input type="number" id="eulerMaxP" value="50" min="5" onchange="computeEulerProduct()"></label></div>
            <div class="stat-grid" id="eulerStats"></div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Product Terms</h4><div id="eulerTerms" style="max-height:200px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Partial Product → 6/π²</h4><canvas id="eulerProductChart"></canvas></div>
                <div class="chart-box"><h4>Partial Sum → π²/6</h4><canvas id="eulerSumChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:12px;"><strong>Connection:</strong> The coprime probability 6/pi^2 emerges from excluding multiples of each prime p with probability 1/p^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('euler')">Screenshot Full Euler Tab</button></div>
        </div>
    </div>
    
    <!-- MODULAR TAB -->
    <div id="tab-modular" class="tab-content">
        <div class="panel">
            <h3>Modular Arithmetic Analysis</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Filter mod k: <input type="number" id="modK" value="6" min="2" onchange="updateModularAnalysis()"></label>
                <label>Residue a: <input type="number" id="modA" value="1" min="0" onchange="updateModularAnalysis()"></label>
                <button onclick="updateModularAnalysis()">Apply Filter</button>
            </div>
            <div class="stat-grid" id="modularStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Residue Class Distribution</h4><canvas id="residueClassChart"></canvas></div>
                <div class="chart-box"><h4>Prime Channel Ownership</h4><canvas id="primeChannelChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Lifting Tower: m → 2m, 3m, ...</h4>
                <div id="liftingDisplay"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('modular')">Screenshot Full Modular Tab</button></div>
        </div>
    </div>
    
    <!-- 3D VIEW TAB -->
    <div id="tab-3d" class="tab-content">
        <div class="panel">
            <h3>3D Sector Cone</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Rotate X: <input type="range" id="rot3dX" min="-90" max="90" value="30" onchange="draw3D()"></label>
                <label>Rotate Z: <input type="range" id="rot3dZ" min="0" max="360" value="45" onchange="draw3D()"></label>
                <label>Perspective: <input type="range" id="perspective3d" min="100" max="1000" value="500" onchange="draw3D()"></label>
            </div>
            <div style="text-align:center;"><canvas id="canvas3d" class="ring-canvas" width="700" height="600"></canvas></div>
            <div class="derivation-box" style="margin-top:12px;">Third axis represents denominator m. Points at height m have coprime numerators r with r/m in the sector range. The cone structure shows density increasing with m^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('3d')">Screenshot Full 3D Tab</button></div>
        </div>
    </div>
    
    <!-- HYPERBOLIC TAB -->
    <div id="tab-hyperbolic" class="tab-content">
        <div class="panel">
            <h3>Hyperbolic Plane / Poincaré Disk</h3>
            <div class="theorem-box"><strong>Farey Tessellation:</strong> The hyperbolic plane is tessellated by ideal triangles with vertices at Farey fractions on ∂H.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Max denom: <input type="number" id="hypMaxDenom" value="15" min="3" onchange="drawHyperbolic()"></label>
                <label>Highlight sector: <input type="number" id="hypSector" value="2" min="1" onchange="drawHyperbolic()"></label>
            </div>
            <div style="text-align:center;"><canvas id="hypCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('hyperbolic')">Screenshot Full Hyperbolic Tab</button></div>
        </div>
    </div>
    
    <!-- ANIMATION TAB -->
    <div id="tab-animation" class="tab-content">
        <div class="panel">
            <h3>Farey Sequence Growth</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Animate to N: <input type="number" id="animMaxN" value="50" min="5"></label>
                <label>Speed (ms): <input type="number" id="animSpeed" value="200" min="50"></label>
                <button onclick="startAnimation()">Start</button>
                <button class="secondary" onclick="stopAnimation()">Stop</button>
                <span id="animStatus" class="info-badge">Ready</span>
            </div>
            <div style="text-align:center;"><canvas id="animCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div class="stat-grid" id="animStats" style="margin-top:12px;"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('animation')">Screenshot Full Animation Tab</button></div>
        </div>
    </div>
    
    <!-- SMITH CHART TAB -->
    <div id="tab-smith" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Smith Chart Transform (Cayley Map)</h3>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Cayley Transform</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">Γ = (z - 1)/(z + 1)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Input z</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">z = R·e^(iθ), θ = 2πr/M + α</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Properties</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">Conformal • Angle-preserving</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Sector:</label>
                    <input type="number" id="smithSector" value="2" min="1" max="15" onchange="drawSmithChart()">
                </div>
                <div class="control-group highlight">
                    <label>Phase α:</label>
                    <input type="range" id="smithPhase" min="0" max="360" value="90" onchange="updateSmithPhaseLabel(); drawSmithChart()">
                    <span id="smithPhaseLabel">90°</span>
                </div>
                <div class="control-group">
                    <label>Radius Mode:</label>
                    <select id="smithRadiusMode" onchange="drawSmithChart()">
                        <option value="unit">Unit (R=1)</option>
                        <option value="index">By Index</option>
                        <option value="modulus" selected>By Modulus</option>
                        <option value="custom">Custom Scale</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Scale:</label>
                    <input type="number" id="smithCustomScale" value="1.0" min="0.1" max="5" step="0.1" onchange="drawSmithChart()">
                </div>
            </div>
            <div class="control-row">
                <label><input type="checkbox" id="smithShowGrid" checked onchange="drawSmithChart()"> Smith Grid</label>
                <label><input type="checkbox" id="smithShowConstR" checked onchange="drawSmithChart()"> Constant-R Circles</label>
                <label><input type="checkbox" id="smithShowConstX" checked onchange="drawSmithChart()"> Constant-X Arcs</label>
                <label><input type="checkbox" id="smithShowLabels" onchange="drawSmithChart()"> Point Labels</label>
                <label><input type="checkbox" id="smithColorByPrime" onchange="drawSmithChart()"> Color by Prime</label>
                <label><input type="checkbox" id="smithShowAllSectors" onchange="drawSmithChart()"> All Sectors</label>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Smith Chart (Cayley Transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Transformed points</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime moduli</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Constant-R</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#475569"></div>Constant-X</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Original z-plane (Pre-transform)</h4>
                <div style="text-align:center;position:relative;">
                    <canvas id="smithOriginalCanvas" class="ring-canvas" width="550" height="550"></canvas>
                </div>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>z = R·e^(iθ)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Unit circle</div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;background:#0f172a;">
            <h4>Transform Mathematics</h4>
            <div class="grid-3" style="gap:15px;">
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Cayley Transform</strong>
                    <div style="font-family:monospace;font-size:0.9em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Γ = (z - 1)/(z + 1)<br>
                        z = R·e^(iθ)
                    </div>
                </div>
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Real Part</strong>
                    <div style="font-family:monospace;font-size:0.85em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Re(Γ) = (AC + B²)/(C² + B²)<br>
                        A = Rcosθ - 1, B = Rsinθ<br>
                        C = Rcosθ + 1
                    </div>
                </div>
                <div class="theorem-box" style="margin:0;">
                    <strong style="color:#c4b5fd;">Imaginary Part</strong>
                    <div style="font-family:monospace;font-size:0.85em;margin-top:8px;background:#0a0f1a;padding:8px;border-radius:4px;">
                        Im(Γ) = B(C - A)/(C² + B²)<br>
                        Special (R=1):<br>
                        Γ(θ) = i·tan(θ/2)
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Transform Data</h4>
            <div class="table-scroll" style="max-height:250px;">
                <table id="smithDataTable">
                    <thead><tr><th>r/m</th><th>θ (rad)</th><th>R</th><th>z = Re^iθ</th><th>Γ = (z-1)/(z+1)</th><th>|Γ|</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('smith')">Screenshot Full Smith Tab</button></div>
    </div>
    
    <!-- STATISTICS TAB -->
    <div id="tab-stats" class="tab-content">
        <div class="panel">
            <h3>Statistical Analysis</h3>
            <div class="grid-2">
                <div class="chart-box"><h4>Random vs Actual Distribution</h4><canvas id="randomCompareChart"></canvas></div>
                <div class="chart-box"><h4>Cross-Sector Correlation</h4><canvas id="correlationChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Error Term O(N log N)</h4><canvas id="errorTermChart"></canvas></div>
                <div class="chart-box"><h4>Local Density Analysis</h4><canvas id="localDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Correlation Matrix</h4>
                <div id="correlationMatrix"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('stats')">Screenshot Full Statistics Tab</button></div>
        </div>
    </div>
    
    <!-- PRIMES TAB -->
    <div id="tab-primes" class="tab-content">
        <div class="panel">
            <h3>Prime Analysis</h3>
            <div class="stat-grid" id="primeStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Twin Prime Gap Markers</h4><canvas id="twinPrimeChart"></canvas></div>
                <div class="chart-box"><h4>Prime vs Composite Moduli</h4><canvas id="primeVsCompositeChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Prime k-tuple Correlations</h4><canvas id="ktupleChart"></canvas></div>
                <div class="chart-box"><h4>Prime Denominator Density</h4><canvas id="primeDenomDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Twin Prime Gaps in Farey Sequence</h4>
                <div id="twinPrimeList" class="residue-list"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('primes')">Screenshot Full Primes Tab</button></div>
        </div>
    </div>
    
    <!-- HARMONIC ANALYSIS TAB -->
    <div id="tab-harmonic" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Harmonic Analysis & Arnold Tongues</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Map Farey fractions to musical frequencies, explore consonance/dissonance, and visualize Arnold tongues</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Frequency Ratio</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">f = f₀ × (p/q)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Consonance Principle</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">Small q = Pure intervals</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">Arnold Tongue Width</div>
                    <div style="color:#f1f5f9;font-size:0.9em;">∝ K/q (coupling/denom)</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Base Frequency:</label>
                    <input type="number" id="harmonicBaseFreq" value="220" min="20" max="2000" onchange="updateHarmonicTab()">
                    <span>Hz</span>
                </div>
                <div class="control-group">
                    <label>Sector:</label>
                    <input type="number" id="harmonicSector" value="2" min="1" max="15" onchange="updateHarmonicTab()">
                </div>
                <div class="control-group">
                    <label>Max Denom:</label>
                    <input type="number" id="harmonicMaxDenom" value="32" min="4" max="100" onchange="updateHarmonicTab()">
                </div>
                <button onclick="updateHarmonicTab()">Refresh</button>
                <button class="secondary" onclick="playHarmonicScale()">Play Scale</button>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Arnold Tongues (Stern-Brocot)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Coupling K: <input type="range" id="arnoldCoupling" min="0" max="100" value="60" oninput="drawArnoldTongues()"></label>
                    <span id="arnoldCouplingVal" style="color:#8b5cf6;">0.60</span>
                    <label><input type="checkbox" id="arnoldShowLabels" checked onchange="drawArnoldTongues()"> Labels</label>
                </div>
                <canvas id="arnoldTongueCanvas" width="550" height="400"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Unison (q=1)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>Consonant (q≤4)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Complex (q≤16)</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Dissonant (q>16)</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Frequency Spectrum</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="freqLogScale" onchange="drawFrequencySpectrum()"> Log scale</label>
                    <label><input type="checkbox" id="freqShowOctaves" checked onchange="drawFrequencySpectrum()"> Octaves</label>
                    <label>Sort: <select id="freqSortMode" onchange="drawFrequencySpectrum()"><option value="freq">Frequency</option><option value="consonance">Consonance</option><option value="denom">Denominator</option></select></label>
                </div>
                <canvas id="freqSpectrumCanvas" width="550" height="400"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Frequency bars</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Octave lines</div>
                </div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Consonance Map</h4>
                <canvas id="consonanceMapCanvas" width="550" height="350"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>High consonance</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>Low consonance</div>
                </div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Interval Circle (Pitch Class)</h4>
                <canvas id="intervalCircleCanvas" width="550" height="350"></canvas>
                <div class="color-legend">
                    <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Fraction position</div>
                    <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>12-TET reference</div>
                </div>
            </div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Musical Intervals in Sector</h4>
            <div class="table-scroll" style="max-height:300px;">
                <table id="intervalTable">
                    <thead><tr><th>Fraction</th><th>Ratio</th><th>Frequency</th><th>Cents</th><th>Closest Note</th><th>Interval Name</th><th>Mode</th><th>Play</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Harmonic Theory:</strong> Fractions p/q with small denominators q produce consonant intervals. The ancient Greeks discovered that simple ratios like 2:1 (octave), 3:2 (fifth), and 4:3 (fourth) sound harmonious. Arnold tongues show how these ratios create stable "locking" regions in coupled oscillator systems - wider tongues indicate more robust synchronization.
        </div>
        
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('harmonic')">Screenshot Full Harmonic Tab</button></div>
    </div>
    
    <!-- PRIMORIAL SIEVE TAB -->
    <div id="tab-primorial" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Primorial Sieve & Farey Sector Connection</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Exploring how primorial residue classes connect to Farey sector distribution</p>
            <div style="display:flex;gap:15px;flex-wrap:wrap;margin-top:12px;">
                <div style="background:rgba(99,102,241,0.2);padding:10px 15px;border-radius:6px;border:1px solid #6366f1;">
                    <div style="color:#a5b4fc;font-size:0.75em;">Primorial Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">φ(P_k)/P_k = ∏(1-1/p)</div>
                </div>
                <div style="background:rgba(34,197,94,0.2);padding:10px 15px;border-radius:6px;border:1px solid #22c55e;">
                    <div style="color:#86efac;font-size:0.75em;">Unified Formula</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">C(n,N,a,k) = 3N²/(π²n(n+1)φ(k))</div>
                </div>
                <div style="background:rgba(245,158,11,0.2);padding:10px 15px;border-radius:6px;border:1px solid #f59e0b;">
                    <div style="color:#fcd34d;font-size:0.75em;">30×2ⁿ Density</div>
                    <div style="color:#f1f5f9;font-size:1.1em;font-family:monospace;">φ(30×2ⁿ)/(30×2ⁿ) = 4/15</div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Primorial Base:</label>
                    <select id="primorialBase" onchange="updatePrimorialSieve()">
                        <option value="6">P₂ = 6 (2×3)</option>
                        <option value="30" selected>P₃ = 30 (2×3×5)</option>
                        <option value="210">P₄ = 210 (2×3×5×7)</option>
                        <option value="2310">P₅ = 2310 (2×3×5×7×11)</option>
                    </select>
                </div>
                <div class="control-group highlight">
                    <label>Power 2ⁿ:</label>
                    <input type="number" id="primorialPower" value="0" min="0" max="6" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Max N:</label>
                    <input type="number" id="primorialN" value="200" min="50" max="1000" onchange="updatePrimorialSieve()">
                </div>
                <div class="control-group">
                    <label>Sectors:</label>
                    <input type="number" id="primorialSectors" value="8" min="3" max="15" onchange="updatePrimorialSieve()">
                </div>
                <button onclick="updatePrimorialSieve()">Compute</button>
                <button class="secondary" onclick="animateLiftingTree()">Animate Lifting</button>
            </div>
        </div>
        
        <div class="stat-grid" id="primorialStats"></div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Sector × Residue Heatmap</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="heatmapNormalize" checked onchange="drawSectorResidueHeatmap()"> Normalize rows</label>
                    <label><input type="checkbox" id="heatmapShowValues" onchange="drawSectorResidueHeatmap()"> Show values</label>
                    <label>Color: <select id="heatmapColorScheme" onchange="drawSectorResidueHeatmap()"><option value="purple">Purple</option><option value="heat">Heat</option><option value="viridis">Viridis</option></select></label>
                </div>
                <canvas id="sectorResidueHeatmap" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#1e1b4b"></div>Low</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#c4b5fd"></div>High</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Constant Verification: φ(k×2ⁿ)/(k×2ⁿ)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Show up to 2^<input type="number" id="densityMaxPower" value="8" min="1" max="12" onchange="drawDensityConstant()"></label>
                    <label><input type="checkbox" id="densityShowTheory" checked onchange="drawDensityConstant()"> Theory line</label>
                </div>
                <canvas id="densityConstantCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual φ(m)/m</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Constant = φ(P_k)/P_k</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Lifting Tree: Residue Class Splitting</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Levels: <input type="number" id="liftingLevels" value="4" min="2" max="6" onchange="drawLiftingTree()"></label>
                    <label>Highlight sector: <input type="number" id="liftingSector" value="2" min="1" max="10" onchange="drawLiftingTree()"></label>
                    <label><input type="checkbox" id="liftingShowCounts" checked onchange="drawLiftingTree()"> Counts</label>
                </div>
                <canvas id="liftingTreeCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Residue class</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>In sector</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Split children</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Unified Formula Verification</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Residue class a: <select id="unifiedResidueClass" onchange="drawUnifiedFormulaChart()"></select></label>
                    <label><input type="checkbox" id="unifiedShowAll" onchange="drawUnifiedFormulaChart()"> All classes</label>
                </div>
                <canvas id="unifiedFormulaCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual C(n,N,a,k)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted 3N²/(π²n(n+1)φ(k))</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Prime Distribution Across Residue Classes</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="primeDistShowExpected" checked onchange="drawPrimeDistribution()"> Expected line</label>
                    <label><input type="checkbox" id="primeDistBySector" onchange="drawPrimeDistribution()"> Split by sector</label>
                </div>
                <canvas id="primeDistributionCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected (uniform)</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Sector Uniformity Test</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Test sector: <input type="number" id="uniformitySector" value="2" min="1" max="10" onchange="drawUniformityTest()"></label>
                    <label><input type="checkbox" id="uniformityShowChiSq" checked onchange="drawUniformityTest()"> χ² stat</label>
                </div>
                <canvas id="uniformityTestCanvas" width="550" height="400"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Actual per class</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Expected C(n,N)/φ(k)</div></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Primorial Comparison: φ(P_k)/P_k → 6/π² Convergence</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>Show primorials up to P_<input type="number" id="primorialCompareMax" value="8" min="3" max="12" onchange="drawPrimorialComparison()"></label>
                <label><input type="checkbox" id="primorialShowProduct" checked onchange="drawPrimorialComparison()"> Show ∏(1-1/p²)</label>
                <label><input type="checkbox" id="primorialShowRatio" onchange="drawPrimorialComparison()"> Show ratio</label>
            </div>
            <canvas id="primorialComparisonCanvas" width="1100" height="350"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>φ(P_k)/P_k</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>∏(1-1/p²) partial</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/π²</div></div>
        </div>
        
        <div class="panel" style="margin-top:15px;background:#0f172a;">
            <h4>Coprime Residue Classes for Current Modulus</h4>
            <div id="residueClassList" class="residue-list" style="max-height:150px;"></div>
        </div>
        
        <div class="panel" style="margin-top:15px;">
            <h4>Sector × Residue Data Table</h4>
            <div class="table-scroll" style="max-height:300px;">
                <table id="sectorResidueTable">
                    <thead><tr><th>Sector</th><th>Total</th><th>Per Class Avg</th><th>χ² Stat</th><th>Uniform?</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> The unified formula C(n,N,a,k) = 3N²/(π²n(n+1)φ(k)) combines Farey sector distribution with primorial residue filtering. This shows that coprimes distribute uniformly across residue classes within each sector, and the density φ(30×2ⁿ)/(30×2ⁿ) = 4/15 remains constant under power-of-2 scaling.
        </div>
        
        <div style="margin-top:15px; padding:15px; background:#1e293b; border-radius:8px; border:1px solid #334155; text-align:center;">
            <button onclick="screenshotFullTab('primorial')" style="padding:12px 24px; font-size:14px;">Screenshot Full Primorial Tab</button>
            <button class="secondary" onclick="exportPrimorialData()" style="margin-left:10px; padding:12px 24px; font-size:14px;">Export Primorial Data</button>
        </div>
    </div>
    
    <!-- RESEARCH TAB -->
    <div id="tab-research" class="tab-content">
        <div class="panel">
            <h3>Research Tools</h3>
            
            <h4>Custom Formula Tester</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>Formula C(n,N) = </label>
                <input type="text" id="customFormula" value="3*N*N/(Math.PI*Math.PI*n*(n+1))" style="width:300px;">
                <button onclick="testCustomFormula()">Test</button>
            </div>
            <div class="chart-box" style="margin-top:12px;"><h4>Custom vs Standard</h4><canvas id="customFormulaChart"></canvas></div>
            
            <h4 style="margin-top:20px;">Batch Parameter Sweep</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>N range: <input type="number" id="batchNMin" value="50"> to <input type="number" id="batchNMax" value="200"> step <input type="number" id="batchNStep" value="10"></label>
                <button onclick="runBatchSweep()">Run Sweep</button>
            </div>
            <div class="table-scroll" style="margin-top:12px;"><table id="batchTable"><thead><tr><th>N</th><th>|F_N|</th><th>Σ|δ|</th><th>Σ|δ|/√N</th><th>Max Gap</th><th>Mean Gap</th></tr></thead><tbody></tbody></table></div>
            
            <h4 style="margin-top:20px;">Publication Export</h4>
            <div class="control-row" style="margin:12px 0;">
                <button onclick="exportLatexFigures()">LaTeX Figures</button>
                <button onclick="exportCSVAll()">Full CSV</button>
                <button onclick="exportJSON()">JSON Data</button>
            </div>
            <div class="latex-output" id="latexFigures"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('research')">Screenshot Full Research Tab</button></div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="pointModal"><div class="modal-content" style="max-width:450px;"><div class="modal-header"><h3 id="pointModalTitle">Point</h3><button class="modal-close" onclick="closePointModal()">x</button></div><div class="modal-body" id="pointModalBody"></div></div></div>

<div class="modal-overlay" id="sectorModal"><div class="modal-content" style="max-width:700px;"><div class="modal-header"><h3 id="sectorModalTitle">Sector Details</h3><button class="modal-close" onclick="closeSectorModal()">x</button></div><div class="modal-body" id="sectorModalBody"></div></div></div>

<div class="screenshot-overlay" id="screenshotOverlay">
    <h3 style="color:#f1f5f9; margin-bottom:20px;">Screenshot Preview (with Legend)</h3>
    <img id="screenshotPreview" class="screenshot-preview">
    <div class="screenshot-actions">
        <button onclick="downloadScreenshot()">Download PNG</button>
        <button onclick="copyScreenshot()">Copy to Clipboard</button>
        <button class="secondary" onclick="closeScreenshotOverlay()">Close</button>
    </div>
</div>

<script>
const state = {
    mode: 'exact', nMin: 100, nMax: 100, sectorMin: 1, sectorMax: 15,
    sectors: [], residuesBySector: {}, allResidues: [], gaps: [], farey: [],
    computing: false, charts: {}, ringPoints: [], animationId: null
};

const sectorColors = ['#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899','#f43f5e','#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6','#06b6d4','#0ea5e9','#3b82f6'];
function getSectorColor(n) { return sectorColors[(n-1) % sectorColors.length]; }

// Canvas state
let currentScreenshotData = null;

function downloadScreenshot() {
    if (!currentScreenshotData) return;
    const a = document.createElement('a');
    a.href = currentScreenshotData;
    a.download = 'farey_chart_' + Date.now() + '.png';
    a.click();
}

async function copyScreenshot() {
    if (!currentScreenshotData) return;
    try {
        const blob = await (await fetch(currentScreenshotData)).blob();
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        alert('Copied to clipboard!');
    } catch (e) {
        alert('Copy failed: ' + e.message);
    }
}

function closeScreenshotOverlay() {
    document.getElementById('screenshotOverlay').classList.remove('active');
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = 'Sector ' + n + ': (1/' + (n+1) + ', 1/' + n + ']';
    
    let primesHtml = primes.length > 0 
        ? primes.map(p => '<span class="residue-item prime" title="m=' + p.m + ' is prime">' + p.r + '/' + p.m + '</span>').join('') 
        : '<span style="color:#64748b">No prime moduli in this sector</span>';
    
    let compositesHtml = composites.length > 0 
        ? composites.slice(0,100).map(c => '<span class="residue-item">' + c.r + '/' + c.m + '</span>').join('') 
        : '<span style="color:#64748b">No composite moduli in this sector</span>';
    
    if (composites.length > 100) {
        compositesHtml += '<span style="color:#64748b; display:block; margin-top:8px;">... and ' + (composites.length - 100) + ' more</span>';
    }
    
    let html = '<div class="stat-grid" style="margin-bottom:15px;">' +
        '<div class="stat-card"><div class="stat-value">' + res.length + '</div><div class="stat-label">Total Pairs</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#f59e0b">' + primes.length + '</div><div class="stat-label">Prime Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#6366f1">' + composites.length + '</div><div class="stat-label">Composite Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector ? fmt(sector.predicted) : '-') + '</div><div class="stat-label">Predicted</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-') + '</div><div class="stat-label">Error</div></div>' +
        '</div>' +
        '<h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (' + primes.length + ')</h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(245,158,11,0.3);">' + primesHtml + '</div>' +
        '<h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (' + composites.length + ') <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(99,102,241,0.3);">' + compositesHtml + '</div>' +
        '<div style="margin-top:15px; display:flex; gap:10px;">' +
        '<button onclick="exportSectorData(' + n + ')">Export Sector CSV</button>' +
        '<button class="secondary" onclick="viewSectorOnRing(' + n + ')">View on Ring</button>' +
        '</div>';
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += r.r + ',' + r.m + ',' + r.value + ',' + r.isPrime + '\n';
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sector_' + n + '_data.csv';
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

function screenshotFullTab(tabName) {
    const tabElement = document.getElementById('tab-' + tabName);
    if (!tabElement) { alert('Tab not found'); return; }
    
    const canvases = tabElement.querySelectorAll('canvas');
    const statGrids = tabElement.querySelectorAll('.stat-grid');
    const tables = tabElement.querySelectorAll('table');
    
    const padding = 40;
    const titleHeight = 80;
    const statsHeight = statGrids.length > 0 ? 100 : 0;
    
    // Calculate canvas section - 2 per row
    const canvasCount = canvases.length;
    const canvasRows = Math.ceil(canvasCount / 2);
    const canvasSectionHeight = canvasRows * 340;
    
    // Check if we have odd number of canvases (will have empty space)
    const hasEmptySpace = canvasCount % 2 === 1;
    
    // Calculate table height
    let tableHeight = 0;
    if (tables.length > 0) {
        const rows = Math.min(tables[0].querySelectorAll('tbody tr').length, 12);
        tableHeight = rows * 24 + 60;
    }
    tableHeight = Math.min(tableHeight, 350);
    
    // Formula panel height (for empty space or bottom)
    const formulaPanelHeight = 200;
    
    const totalWidth = 1000;
    const totalHeight = titleHeight + statsHeight + canvasSectionHeight + tableHeight + formulaPanelHeight + padding * 2;
    
    const composite = document.createElement('canvas');
    composite.width = totalWidth * 2;
    composite.height = totalHeight * 2;
    const ctx = composite.getContext('2d');
    ctx.scale(2, 2);
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    
    let currentY = padding;
    
    // Tab info for formulas
    const tabInfo = {
        'main': {
            title: 'Main Sector Analysis',
            formula: 'C(n, N) = 3N² / (π² n(n+1))',
            description: 'Asymptotic count of coprime pairs (r, m) with r/m in sector Sₙ = (1/(n+1), 1/n]',
            params: ['Coprime density: 6/π² ≈ 0.6079', 'Sector width: 1/(n(n+1))', 'Error term: O(N log N)']
        },
        'theory': {
            title: 'Farey Sector Density Theory',
            formula: 'C(n, N) ~ (3/π²) · N² / n(n+1)',
            description: 'Distribution of coprime integer pairs with bounded height whose rational slope lies in a fixed Farey sector',
            params: ['Σφ(b) = 3N²/π² + O(N log N)', 'Global density: 1/ζ(2) = 6/π²', 'Visible lattice points']
        },
        'theoryviz': {
            title: 'Theory Visualization',
            formula: 'C(n, N) = 3N² / (π² n(n+1))',
            description: 'Interactive visual exploration of the Farey Sector Density Theorem',
            params: ['Summatory totient: Σφ(b) ~ 3N²/π²', 'Sector partition of (0,1]', 'Convergence analysis']
        },
        'gaps': {
            title: 'Farey Gap Analysis',
            formula: 'gap(a/b, c/d) = |c/d - a/b| = 1/(b·d)',
            description: 'For consecutive Farey fractions, the gap equals exactly 1/(b·d)',
            params: ['Mediant property: |ad - bc| = 1', 'Gap decreases with denominator', 'Uniform distribution']
        },
        'franel': {
            title: 'Franel-Landau Theorem',
            formula: 'Σ|δₖ| = O(N^(1/2+ε)) ⟺ RH',
            description: 'Equivalence between Farey sequence deviation growth and the Riemann Hypothesis',
            params: ['δₖ = Fₖ - k/|Fₙ|', 'RH implies bounded Σ|δ|/√N', 'Computational verification']
        },
        'dedekind': {
            title: 'Dedekind Sums',
            formula: 's(h,k) = Σⱼ₌₁ᵏ⁻¹ ((j/k))((hj/k))',
            description: 'Arithmetic functions encoding properties of coprime pairs with reciprocity laws',
            params: ['Reciprocity: s(h,k) + s(k,h) = -1/4 + ...', 'Sawtooth function ((x))', 'Modular forms connection']
        },
        'cf': {
            title: 'Continued Fractions',
            formula: 'r/m = [a₀; a₁, a₂, ...]',
            description: 'Stern-Brocot tree encoding via continued fraction expansion',
            params: ['Path L^a R^b encodes [0; a, b, ...]', 'Convergents approximate r/m', 'Best rational approximations']
        },
        'psl': {
            title: 'PSL(2,ℤ) Matrices',
            formula: '[a,c; b,d] ∈ SL(2,ℤ) with |ad-bc|=1',
            description: 'Farey neighbors correspond to matrices with determinant ±1',
            params: ['Ford circles tangency', 'Hyperbolic tessellation', 'Modular group action']
        },
        'euler': {
            title: 'Euler Product for ζ(2)',
            formula: 'ζ(2) = Πₚ 1/(1-1/p²) = π²/6',
            description: 'The coprime density emerges from excluding prime multiples',
            params: ['6/π² = Πₚ(1-1/p²)', 'Prime sieve interpretation', 'Basel problem solution']
        },
        'modular': {
            title: 'Modular Arithmetic Analysis',
            formula: 'm ≡ a (mod k)',
            description: 'Residue class distribution and prime channel analysis',
            params: ['Lifting tower: m → 2m, 3m, ...', 'Prime channel ownership', 'Residue class uniformity']
        },
        '3d': {
            title: '3D Sector Cone Visualization',
            formula: 'Points at height m have coprime r with r/m ∈ Sₙ',
            description: 'Third axis represents denominator m, showing density growth with m²',
            params: ['Perspective projection', 'Color by prime/composite', 'Rotation controls']
        },
        'hyperbolic': {
            title: 'Hyperbolic Plane / Poincaré Disk',
            formula: 'Farey tessellation of ℍ',
            description: 'The hyperbolic plane is tessellated by ideal triangles with Farey vertices',
            params: ['Geodesics between neighbors', 'Ford circles on boundary', 'PSL(2,ℤ) action']
        },
        'animation': {
            title: 'Farey Sequence Growth Animation',
            formula: '|Fₙ| ~ 3N²/π²',
            description: 'Watch the Farey sequence grow as N increases',
            params: ['Progressive density increase', 'Prime/composite distribution', 'Mediant insertion']
        },
        'smith': {
            title: 'Smith Chart Transform',
            formula: 'Γ = (Z-1)/(Z+1)',
            description: 'Map Farey fractions to Smith chart coordinates',
            params: ['Impedance transformation', 'Reflection coefficient', 'Complex plane mapping']
        },
        'stats': {
            title: 'Statistical Analysis',
            formula: 'Expected: 6N²/π², Actual: |coprimes|',
            description: 'Statistical comparison of actual vs theoretical distributions',
            params: ['Cross-sector correlation', 'Error term analysis', 'Local density variation']
        },
        'primes': {
            title: 'Prime Analysis',
            formula: 'φ(p) = p-1 for prime p',
            description: 'Prime denominator distribution and twin prime patterns',
            params: ['Prime vs composite ratio', 'k-tuple correlations', 'Gap patterns at primes']
        },
        'research': {
            title: 'Research Tools',
            formula: 'Custom: C(n,N) = f(n,N)',
            description: 'Tools for testing custom formulas and batch parameter sweeps',
            params: ['LaTeX export', 'CSV/JSON data export', 'Parameter sweep analysis']
        }
    };
    
    const info = tabInfo[tabName] || { title: tabName, formula: '', description: '', params: [] };
    
    // Header with gradient
    const gradient = ctx.createLinearGradient(0, 0, totalWidth, titleHeight);
    gradient.addColorStop(0, '#1e1b4b');
    gradient.addColorStop(1, '#312e81');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, totalWidth, titleHeight);
    
    // Title
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 24px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Farey Sector Formula - ' + info.title, padding, currentY + 30);
    
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#a5b4fc';
    ctx.fillText('N = ' + state.nMax + ' | Sectors ' + state.sectorMin + '-' + state.sectorMax + ' | ' + new Date().toLocaleString(), padding, currentY + 55);
    
    // Formula badge
    ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
    const formulaWidth = ctx.measureText(info.formula).width + 30;
    ctx.fillRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.strokeStyle = '#6366f1';
    ctx.strokeRect(totalWidth - padding - formulaWidth - 10, currentY + 15, formulaWidth + 20, 35);
    ctx.fillStyle = '#e0e7ff';
    ctx.font = 'bold 14px "Cambria Math", serif';
    ctx.textAlign = 'right';
    ctx.fillText(info.formula, totalWidth - padding - 5, currentY + 38);
    
    currentY = titleHeight;
    
    // Stats section
    if (statGrids.length > 0) {
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(padding, currentY + 10, totalWidth - padding * 2, statsHeight - 20);
        ctx.strokeStyle = '#334155';
        ctx.strokeRect(padding, currentY + 10, totalWidth - padding * 2, statsHeight - 20);
        
        const statCards = statGrids[0].querySelectorAll('.stat-card');
        const statWidth = (totalWidth - padding * 2) / Math.min(statCards.length, 6);
        
        statCards.forEach((card, i) => {
            if (i >= 6) return;
            const x = padding + i * statWidth + statWidth / 2;
            const label = card.querySelector('.stat-label');
            const value = card.querySelector('.stat-value');
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '11px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(label ? label.textContent : '', x, currentY + 35);
            
            const valueEl = card.querySelector('.stat-value');
            ctx.fillStyle = valueEl && valueEl.style.color ? valueEl.style.color : '#6366f1';
            ctx.font = 'bold 18px system-ui';
            ctx.fillText(value ? value.textContent : '', x, currentY + 60);
        });
        currentY += statsHeight;
    }
    
    // Canvases - 2 per row
    const canvasWidth = (totalWidth - padding * 3) / 2;
    const canvasHeight = 300;
    
    canvases.forEach((canvas, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        // Get title from parent chart-box
        const chartBox = canvas.closest('.chart-box');
        const title = chartBox ? (chartBox.querySelector('h4') ? chartBox.querySelector('h4').textContent : 'Chart') : 'Chart';
        
        // Background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title bar
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(x, y, canvasWidth, 25);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText(title, x + 10, y + 17);
        
        // Draw canvas scaled
        const scale = Math.min((canvasWidth - 20) / canvas.width, (canvasHeight - 45) / canvas.height);
        const drawWidth = canvas.width * scale;
        const drawHeight = canvas.height * scale;
        const drawX = x + (canvasWidth - drawWidth) / 2;
        const drawY = y + 30 + (canvasHeight - 40 - drawHeight) / 2;
        
        try {
            ctx.drawImage(canvas, drawX, drawY, drawWidth, drawHeight);
        } catch (e) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('Canvas render error', drawX + 20, drawY + 50);
        }
    });
    
    // Fill empty space if odd number of canvases
    if (hasEmptySpace && canvasCount > 0) {
        const col = canvasCount % 2;
        const row = Math.floor(canvasCount / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 40);
        
        // Formula/Info panel in empty space
        ctx.fillStyle = '#1e1b4b';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title
        ctx.fillStyle = '#c7d2fe';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Key Formulas & Parameters', x + canvasWidth/2, y + 30);
        
        // Main formula box
        ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
        ctx.fillRect(x + 20, y + 50, canvasWidth - 40, 50);
        ctx.strokeStyle = '#8b5cf6';
        ctx.strokeRect(x + 20, y + 50, canvasWidth - 40, 50);
        ctx.fillStyle = '#f1f5f9';
        ctx.font = 'bold 16px "Cambria Math", serif';
        ctx.fillText(info.formula, x + canvasWidth/2, y + 82);
        
        // Description
        ctx.fillStyle = '#94a3b8';
        ctx.font = '11px system-ui';
        const descLines = wrapText(ctx, info.description, canvasWidth - 40);
        descLines.forEach((line, i) => {
            ctx.fillText(line, x + canvasWidth/2, y + 125 + i * 16);
        });
        
        // Parameters
        ctx.fillStyle = '#cbd5e1';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Parameters:', x + 25, y + 180);
        
        ctx.font = '11px system-ui';
        ctx.fillStyle = '#a5b4fc';
        info.params.forEach((param, i) => {
            ctx.fillText('• ' + param, x + 30, y + 200 + i * 20);
        });
        
        // Current values
        ctx.fillStyle = '#64748b';
        ctx.font = '10px system-ui';
        ctx.fillText('Current: N=' + state.nMax + ', Sectors=' + state.sectorMin + '-' + state.sectorMax, x + 25, y + canvasHeight - 20);
    }
    
    currentY += canvasSectionHeight;
    
    // Tables section
    if (tables.length > 0 && tableHeight > 60) {
        const table = tables[0];
        const headers = table.querySelectorAll('thead th');
        const rows = table.querySelectorAll('tbody tr');
        
        ctx.fillStyle = '#cbd5e1';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Data Table', padding, currentY + 20);
        currentY += 30;
        
        // Header
        ctx.fillStyle = '#334155';
        ctx.fillRect(padding, currentY, totalWidth - padding * 2, 24);
        
        const colWidth = (totalWidth - padding * 2) / Math.max(headers.length, 1);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 10px system-ui';
        headers.forEach((h, i) => {
            ctx.fillText(h.textContent.substring(0, 12), padding + 8 + i * colWidth, currentY + 16);
        });
        currentY += 24;
        
        // Rows
        ctx.font = '10px system-ui';
        const maxRows = Math.min(rows.length, 10);
        for (let r = 0; r < maxRows; r++) {
            const row = rows[r];
            const cells = row.querySelectorAll('td');
            
            if (r % 2 === 0) {
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(padding, currentY, totalWidth - padding * 2, 20);
            }
            
            cells.forEach((cell, i) => {
                ctx.fillStyle = cell.style.color || '#e2e8f0';
                ctx.fillText(cell.textContent.substring(0, 15), padding + 8 + i * colWidth, currentY + 14);
            });
            currentY += 20;
        }
        
        if (rows.length > maxRows) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('... and ' + (rows.length - maxRows) + ' more rows', padding + 8, currentY + 14);
            currentY += 20;
        }
    }
    
    // Bottom formula panel
    currentY = totalHeight - formulaPanelHeight - padding;
    
    ctx.fillStyle = '#1e293b';
    ctx.fillRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(padding, currentY, totalWidth - padding * 2, formulaPanelHeight);
    
    // Left side - Main formula
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Core Formula', padding + 20, currentY + 25);
    
    ctx.fillStyle = 'rgba(99, 102, 241, 0.15)';
    ctx.fillRect(padding + 20, currentY + 35, (totalWidth - padding * 2) / 2 - 40, 45);
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 18px "Cambria Math", serif';
    ctx.textAlign = 'center';
    ctx.fillText(info.formula, padding + 20 + ((totalWidth - padding * 2) / 2 - 40) / 2, currentY + 65);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    const descLines2 = wrapText(ctx, info.description, (totalWidth - padding * 2) / 2 - 50);
    descLines2.forEach((line, i) => {
        ctx.fillText(line, padding + 25, currentY + 100 + i * 14);
    });
    
    // Right side - Parameters and constants
    const rightX = padding + (totalWidth - padding * 2) / 2 + 20;
    ctx.fillStyle = '#c7d2fe';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText('Key Parameters', rightX, currentY + 25);
    
    ctx.fillStyle = '#a5b4fc';
    ctx.font = '11px system-ui';
    info.params.forEach((param, i) => {
        ctx.fillText('• ' + param, rightX + 5, currentY + 50 + i * 18);
    });
    
    // Constants box
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(rightX, currentY + 120, 200, 55);
    ctx.strokeStyle = '#334155';
    ctx.strokeRect(rightX, currentY + 120, 200, 55);
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.fillText('Universal Constants:', rightX + 10, currentY + 138);
    ctx.fillStyle = '#6366f1';
    ctx.font = '11px monospace';
    ctx.fillText('6/π² = ' + (6/Math.PI/Math.PI).toFixed(8), rightX + 10, currentY + 155);
    ctx.fillText('π²/6 = ' + (Math.PI*Math.PI/6).toFixed(8), rightX + 10, currentY + 170);
    
    // Footer
    ctx.fillStyle = '#475569';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', totalWidth / 2, totalHeight - 15);
    
    currentScreenshotData = composite.toDataURL('image/png');
    document.getElementById('screenshotPreview').src = currentScreenshotData;
    document.getElementById('screenshotOverlay').classList.add('active');
}

// Helper function to wrap text
function wrapText(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';
    
    words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        if (ctx.measureText(testLine).width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
        } else {
            currentLine = testLine;
        }
    });
    if (currentLine) lines.push(currentLine);
    return lines.slice(0, 3); // Max 3 lines
}

// Utilities
function gcd(a, b) { while(b) { [a,b] = [b, a%b]; } return a; }
function isPrime(n) { if(n<2) return false; if(n===2) return true; if(n%2===0) return false; for(let i=3;i*i<=n;i+=2) if(n%i===0) return false; return true; }
function mobius(n) { if(n===1) return 1; let c=0; for(let p=2;p*p<=n;p++) { if(n%p===0) { if(n%(p*p)===0) return 0; c++; n/=p; } } if(n>1) c++; return c%2===0?1:-1; }
function getSector(r,m) { const f=r/m; if(f<=0||f>1) return null; return Math.floor(1/f); }
function formula(n,N) { return (3*N*N)/(Math.PI*Math.PI*n*(n+1)); }
function fmt(x) { if(x>=1e9) return (x/1e9).toFixed(1)+'B'; if(x>=1e6) return (x/1e6).toFixed(1)+'M'; if(x>=1e3) return (x/1e3).toFixed(1)+'K'; return x.toFixed(x<10?2:0); }

// Continued fraction
function toCF(r, m) {
    const cf = [];
    while(m !== 0) { const q = Math.floor(r/m); cf.push(q); [r,m] = [m, r - q*m]; }
    return cf;
}
function cfPath(cf) {
    let path = '';
    for(let i=0; i<cf.length; i++) { path += (i%2===0?'R':'L').repeat(cf[i]); }
    return path;
}

// Dedekind sum
function sawtoothSum(h, k) {
    let s = 0;
    for(let j=1; j<k; j++) {
        const jk = j/k, hjk = (h*j/k) % 1;
        const s1 = jk - Math.floor(jk) - 0.5;
        const s2 = hjk - Math.floor(hjk) - 0.5;
        s += s1 * s2;
    }
    return s;
}

function setMode(mode) {
    state.mode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('mode-'+mode).classList.add('active');
    document.getElementById('modeDescription').textContent = {exact:'Exact enumeration',hybrid:'Hybrid mode',formula:'Formula only'}[mode];
}

async function computeAll() {
    if(state.computing) return;
    state.computing = true;
    state.nMin = +document.getElementById('nMin').value;
    state.nMax = +document.getElementById('nMax').value;
    state.sectorMin = +document.getElementById('sectorMin').value;
    state.sectorMax = +document.getElementById('sectorMax').value;
    
    document.getElementById('progressBar').style.display = 'block';
    document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing...</span>';
    
    state.sectors = []; state.residuesBySector = {}; state.allResidues = []; state.gaps = []; state.farey = [];
    
    const N = state.nMax;
    if(state.mode !== 'formula' && N <= 1500) {
        await computeExact(N);
    } else {
        computeFormulaOnly();
    }
    
    computeGaps();
    updateAllDisplays();
    
    document.getElementById('progressBar').style.display = 'none';
    document.getElementById('statusArea').innerHTML = '<span class="info-badge success">Done</span>';
    state.computing = false;
}

async function computeExact(N) {
    let ops = 0;
    for(let m=2; m<=N; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const s = getSector(r,m);
                const res = {r, m, sector:s, isPrime:isPrime(m), value:r/m};
                state.allResidues.push(res);
                if(s && s>=state.sectorMin && s<=state.sectorMax) {
                    if(!state.residuesBySector[s]) state.residuesBySector[s] = [];
                    state.residuesBySector[s].push(res);
                }
            }
        }
        ops += m;
        if(m%50===0) { document.getElementById('progressFill').style.width = (m/N*100)+'%'; await new Promise(r=>setTimeout(r,0)); }
        if(!state.computing) return;
    }
    state.allResidues.sort((a,b) => a.value - b.value);
    state.farey = state.allResidues.map(r => ({r:r.r, m:r.m, value:r.value}));
    
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        const res = state.residuesBySector[n] || [];
        const exact = res.length, pred = formula(n,N);
        const primeCount = res.filter(x=>x.isPrime).length;
        state.sectors.push({n, exact, predicted:pred, error:exact-pred, relError:exact>0?((exact-pred)/exact)*100:0, width:1/(n*(n+1)), primeCount});
    }
}

function computeFormulaOnly() {
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        state.sectors.push({n, exact:null, predicted:formula(n,state.nMax), error:null, relError:null, width:1/(n*(n+1)), primeCount:null});
    }
}

function computeGaps() {
    state.gaps = [];
    for(let i=0; i<state.allResidues.length-1; i++) {
        const l = state.allResidues[i], r = state.allResidues[i+1];
        const gap = r.value - l.value;
        state.gaps.push({left:l, right:r, gap, theoretical:1/(l.m*r.m), denomProduct:l.m*r.m, sector:l.sector});
        state.allResidues[i].gapRight = gap;
    }
    state.gaps.sort((a,b) => b.gap - a.gap);
}

function cancelComputation() { state.computing = false; }

function updateAllDisplays() {
    updateMainStats(); updateMainCharts(); updateMainTable(); drawMainRing(); drawSectorTree();
    drawTheoryViz();
    updateGapAnalysis(); computeFranel(); computeDedekind(); updateCFDisplay();
    computePSL(); computeEulerProduct(); updateModularAnalysis(); draw3D();
    drawHyperbolic(); drawSmithChart(); updateStatistics(); updatePrimeAnalysis();
}

// THEORY VIZ FUNCTIONS
function phi(n) { let r=0; for(let i=1; i<n; i++) if(gcd(i,n)===1) r++; return r; }

function drawTheoryViz() {
    drawSectorPartition();
    drawDensityCone();
    drawTotientSum();
    drawLatticeViz();
    drawProofSteps();
    drawConvergenceAnalysis();
    drawDensityHeatmap();
}

function drawSectorPartition() {
    const canvas = document.getElementById('sectorPartitionCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxSectors = +(document.getElementById('tvMaxSectors')?.value || 8);
    const showValues = document.getElementById('tvShowSectorValues')?.checked ?? true;
    const showWidths = document.getElementById('tvShowSectorWidths')?.checked ?? false;
    const style = document.getElementById('tvPartitionStyle')?.value || 'bar';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 50, barH = 40;
    const centerY = H/2;
    
    let legendHtml = '';
    
    if (style === 'arc') {
        // Arc/pie style
        const cx = W/2, cy = H/2, radius = Math.min(W,H)/2 - 60;
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, 2*Math.PI); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const a1 = left * 2 * Math.PI - Math.PI/2;
            const a2 = right * 2 * Math.PI - Math.PI/2;
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, a1, a2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.stroke();
            
            if (showValues && n <= 6) {
                const midAngle = (a1 + a2) / 2;
                const labelR = radius * 0.7;
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 11px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`S${n}`, cx + Math.cos(midAngle)*labelR, cy + Math.sin(midAngle)*labelR + 4);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else if (style === 'number') {
        // Number line style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        // Tick marks
        for (let i = 0; i <= 10; i++) {
            const x = margin + (i/10) * (W - 2*margin);
            ctx.beginPath(); ctx.moveTo(x, centerY - 10); ctx.lineTo(x, centerY + 10); ctx.stroke();
            ctx.fillStyle = '#94a3b8'; ctx.font = '10px system-ui'; ctx.textAlign = 'center';
            ctx.fillText((i/10).toFixed(1), x, centerY + 25);
        }
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color;
            ctx.fillRect(x1, centerY - 5, x2 - x1, 10);
            
            if (showValues && x2-x1 > 20) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.fillText(`S${n}`, (x1+x2)/2, centerY - 15);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else {
        // Default bar style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.fillRect(x1, centerY - barH, x2 - x1, barH * 2);
            ctx.strokeStyle = color; ctx.lineWidth = 1;
            ctx.strokeRect(x1, centerY - barH, x2 - x1, barH * 2);
            
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 11px system-ui';
            ctx.textAlign = 'center';
            if(x2-x1 > 25) ctx.fillText(`S${n}`, (x1+x2)/2, centerY + 4);
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px system-ui';
            ctx.fillText(`1/${n+1}`, x1, centerY + barH + 18);
            
            if (showWidths && x2-x1 > 30) {
                const width = 1/(n*(n+1));
                ctx.fillStyle = '#64748b';
                ctx.font = '8px system-ui';
                ctx.fillText(`w=${width.toFixed(3)}`, (x1+x2)/2, centerY + barH + 35);
            }
            
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}=(1/${n+1},1/${n}]</div>`;
        }
        
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('0', margin - 12, centerY + barH + 18);
        ctx.textAlign = 'right';
        ctx.fillText('1', W - margin + 12, centerY + barH + 18);
    }
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sectors Partition (0,1]', W/2, 25);
    
    document.getElementById('sectorPartitionLegend').innerHTML = legendHtml;
}

function drawDensityCone() {
    const canvas = document.getElementById('densityConeCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const numSectors = +(document.getElementById('tvConeSectors')?.value || 4);
    const showRef = document.getElementById('tvShowConeRef')?.checked ?? true;
    const logScale = document.getElementById('tvLogScale')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:55, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    const maxY = formula(1, maxN);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY * i / 4), margin.l - 5, y + 3);
    }
    
    let legendHtml = '';
    for (let n = 1; n <= numSectors; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let N = 10; N <= maxN; N += 3) {
            const C = formula(n, N);
            const x = margin.l + (N / maxN) * plotW;
            const yVal = logScale ? Math.log(C + 1) / Math.log(maxY + 1) : C / maxY;
            const y = margin.t + plotH - yVal * plotH;
            N === 10 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.font = '10px system-ui';
        const labelY = margin.t + plotH - (formula(n, maxN) / maxY) * plotH;
        ctx.fillText(`n=${n}`, W - margin.r - 30, Math.max(margin.t + 15, labelY + 4));
        
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    if (showRef) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        const refY = margin.t + plotH * 0.4;
        ctx.moveTo(margin.l, refY);
        ctx.lineTo(W - margin.r, refY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.fillText('6/π² ref', W - margin.r - 35, refY - 5);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/π²</div>`;
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N →', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('C(n,N) →', 0, 0);
    ctx.restore();
    
    document.getElementById('densityConeLegend').innerHTML = legendHtml;
}

function drawTotientSum() {
    const canvas = document.getElementById('totientSumCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const showActual = document.getElementById('tvShowTotientActual')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowTotientPredicted')?.checked ?? true;
    const showError = document.getElementById('tvShowTotientError')?.checked ?? false;
    const fill = document.getElementById('tvTotientFill')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:65, r:20, t:20, b:40};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumPhi = 0;
    const data = [];
    for (let b = 1; b <= maxN; b++) {
        cumPhi += phi(b);
        data.push({b, cumPhi, predicted: 3*b*b/(Math.PI*Math.PI)});
    }
    
    const maxY = data[data.length-1].cumPhi;
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY*i/4), margin.l - 5, y+3);
    }
    
    if (showActual) {
        if (fill) {
            ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
            ctx.beginPath();
            ctx.moveTo(margin.l, margin.t + plotH);
            data.forEach((d, i) => {
                const x = margin.l + (d.b / maxN) * plotW;
                const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
                ctx.lineTo(x, y);
            });
            ctx.lineTo(margin.l + plotW, margin.t + plotH);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    if (showError) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const maxErr = Math.max(...data.map(d => Math.abs(d.cumPhi - d.predicted)));
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const err = Math.abs(d.cumPhi - d.predicted) / maxErr;
            const y = margin.t + plotH - err * plotH * 0.3;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('b →', W/2, H - 10);
}

function drawLatticeViz() {
    const canvas = document.getElementById('latticeVizCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const highlightSector = +(document.getElementById('tvHighlightSector')?.value || 2);
    const showHidden = document.getElementById('tvShowHidden')?.checked ?? true;
    const showSectorLines = document.getElementById('tvShowSectorLines')?.checked ?? true;
    const colorBySector = document.getElementById('tvColorBySector')?.checked ?? false;
    const pointSize = +(document.getElementById('tvPointSize')?.value || 4);
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 45;
    const scale = (Math.min(W, H) - 2*margin) / maxB;
    
    // Draw sector boundary lines first
    if (showSectorLines) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        
        // Lines for highlighted sector boundaries
        const leftSlope = 1/(highlightSector+1);
        const rightSlope = 1/highlightSector;
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * leftSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * rightSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    for (let b = 1; b <= maxB; b++) {
        for (let a = 1; a <= b; a++) {
            const x = margin + a * scale;
            const y = H - margin - b * scale;
            
            const visible = gcd(a, b) === 1;
            
            if (!visible && !showHidden) continue;
            
            let color;
            if (!visible) {
                color = '#334155';
            } else if (colorBySector) {
                const sector = getSector(a, b);
                color = sector ? getSectorColor(sector) : '#6366f1';
            } else {
                color = '#6366f1';
            }
            
            // Highlight points in selected sector
            const inSector = visible && a/b > 1/(highlightSector+1) && a/b <= 1/highlightSector;
            
            ctx.fillStyle = inSector ? '#22c55e' : color;
            ctx.beginPath();
            ctx.arc(x, y, visible ? pointSize : pointSize/2, 0, 2*Math.PI);
            ctx.fill();
        }
    }
    
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, H - margin);
    ctx.lineTo(W - margin, H - margin);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('a →', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('b →', 0, 0);
    ctx.restore();
    
    // Sector label
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector ${highlightSector} highlighted`, W/2, 20);
}

function drawProofSteps() {
    const canvas = document.getElementById('proofStepsCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const n = +(document.getElementById('tvProofSector')?.value || 2);
    const maxB = +(document.getElementById('tvMaxN')?.value || 100);
    const showContrib = document.getElementById('tvShowContribBars')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowProofPredicted')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumCount = 0;
    const data = [];
    for (let b = 2; b <= maxB; b++) {
        const sectorRes = (state.residuesBySector[n]||[]).filter(r => r.m === b).length;
        const contrib = sectorRes > 0 ? sectorRes : Math.round(phi(b) / (n * (n+1)));
        cumCount += contrib;
        data.push({b, cumCount, predicted: formula(n, b), contrib});
    }
    
    const maxY = Math.max(data[data.length-1].cumCount, data[data.length-1].predicted);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
    }
    
    if (showContrib) {
        ctx.fillStyle = '#f59e0b30';
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const h = (d.contrib / maxY) * plotH * 3;
            ctx.fillRect(x - 2, margin.t + plotH - h, 4, h);
        });
    }
    
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (d.b / maxB) * plotW;
        const y = margin.t + plotH - (d.cumCount / maxY) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Denominator b →', W/2, H - 10);
    
    ctx.fillStyle = '#8b5cf6';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector n=${n}`, W/2, 18);
}

function drawConvergenceAnalysis() {
    const canvas = document.getElementById('convergenceCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const analysisType = document.getElementById('tvConvergenceType')?.value || 'relative';
    const showTrend = document.getElementById('tvShowConvergenceTrend')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:30, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate convergence data for multiple N values
    const data = [];
    for (let N = 20; N <= 200; N += 10) {
        const sectorData = [];
        for (let n = 1; n <= 5; n++) {
            // Simulate exact count based on formula with random error
            const predicted = formula(n, N);
            const exactEstimate = predicted + (Math.random() - 0.5) * Math.sqrt(N) * 2;
            
            let value;
            if (analysisType === 'relative') {
                value = ((exactEstimate - predicted) / predicted) * 100;
            } else if (analysisType === 'absolute') {
                value = exactEstimate - predicted;
            } else {
                value = exactEstimate / predicted;
            }
            sectorData.push({n, value});
        }
        data.push({N, sectors: sectorData});
    }
    
    // Find y-axis range
    let minY = Infinity, maxY = -Infinity;
    data.forEach(d => {
        d.sectors.forEach(s => {
            if (s.value < minY) minY = s.value;
            if (s.value > maxY) maxY = s.value;
        });
    });
    const yRange = maxY - minY || 1;
    
    // Grid
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        const label = minY + (i/4) * yRange;
        ctx.fillText(label.toFixed(analysisType === 'ratio' ? 2 : 1), margin.l - 5, y + 3);
    }
    
    // Draw lines for each sector
    let legendHtml = '';
    for (let n = 1; n <= 5; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        data.forEach((d, i) => {
            const sectorData = d.sectors.find(s => s.n === n);
            if (sectorData) {
                const x = margin.l + (i / (data.length - 1)) * plotW;
                const y = margin.t + plotH - ((sectorData.value - minY) / yRange) * plotH;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    // Trend line (zero for relative/absolute, 1 for ratio)
    if (showTrend) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        const targetY = analysisType === 'ratio' ? 1 : 0;
        const y = margin.t + plotH - ((targetY - minY) / yRange) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.setLineDash([]);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Target</div>`;
    }
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N →', W/2, H - 10);
    
    const titles = {relative: 'Relative Error %', absolute: 'Absolute Error', ratio: 'Actual / Predicted'};
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(titles[analysisType], W/2, 18);
    
    document.getElementById('convergenceLegend').innerHTML = legendHtml;
}

function drawDensityHeatmap() {
    const canvas = document.getElementById('densityHeatmapCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const nMin = +(document.getElementById('tvHeatmapNMin')?.value || 20);
    const nMax = +(document.getElementById('tvHeatmapNMax')?.value || 150);
    const numSectors = +(document.getElementById('tvHeatmapSectors')?.value || 10);
    const colorScheme = document.getElementById('tvHeatmapColor')?.value || 'viridis';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:80, t:30, b:50};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate heatmap data
    const nSteps = 20;
    const nStep = (nMax - nMin) / nSteps;
    
    let minVal = Infinity, maxVal = -Infinity;
    const heatData = [];
    
    for (let i = 0; i <= nSteps; i++) {
        const N = nMin + i * nStep;
        const row = [];
        for (let n = 1; n <= numSectors; n++) {
            const val = formula(n, N);
            row.push(val);
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
        }
        heatData.push({N, values: row});
    }
    
    // Color functions
    function getColor(t, scheme) {
        if (scheme === 'viridis') {
            const r = Math.round(68 + t * (253 - 68));
            const g = Math.round(1 + t * (231 - 1));
            const b = Math.round(84 + t * (37 - 84));
            return `rgb(${r},${g},${b})`;
        } else if (scheme === 'plasma') {
            const r = Math.round(13 + t * (240 - 13));
            const g = Math.round(8 + t * (249 - 8));
            const b = Math.round(135 + t * (33 - 135));
            return `rgb(${r},${g},${b})`;
        } else {
            // Cool-warm
            if (t < 0.5) {
                const r = Math.round(59 + t * 2 * (255 - 59));
                const g = Math.round(76 + t * 2 * (255 - 76));
                const b = Math.round(192 - t * 2 * (192 - 255));
                return `rgb(${r},${g},${b})`;
            } else {
                const r = 255;
                const g = Math.round(255 - (t - 0.5) * 2 * (255 - 59));
                const b = Math.round(255 - (t - 0.5) * 2 * (255 - 76));
                return `rgb(${r},${g},${b})`;
            }
        }
    }
    
    // Draw heatmap cells
    const cellW = plotW / numSectors;
    const cellH = plotH / (nSteps + 1);
    
    heatData.forEach((row, i) => {
        row.values.forEach((val, j) => {
            const t = (val - minVal) / (maxVal - minVal);
            ctx.fillStyle = getColor(t, colorScheme);
            ctx.fillRect(margin.l + j * cellW, margin.t + i * cellH, cellW - 1, cellH - 1);
        });
    });
    
    // X-axis labels (sectors)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    for (let n = 1; n <= numSectors; n++) {
        ctx.fillText(`S${n}`, margin.l + (n - 0.5) * cellW, H - margin.b + 20);
    }
    ctx.fillText('Sector n', margin.l + plotW/2, H - 10);
    
    // Y-axis labels (N values)
    ctx.textAlign = 'right';
    for (let i = 0; i <= nSteps; i += 4) {
        const N = Math.round(nMin + i * nStep);
        ctx.fillText(N, margin.l - 5, margin.t + i * cellH + cellH/2 + 3);
    }
    ctx.save();
    ctx.translate(15, margin.t + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.fillText('N →', 0, 0);
    ctx.restore();
    
    // Color bar
    const barW = 20, barH = plotH;
    const barX = W - margin.r + 20;
    for (let i = 0; i < barH; i++) {
        const t = 1 - i / barH;
        ctx.fillStyle = getColor(t, colorScheme);
        ctx.fillRect(barX, margin.t + i, barW, 1);
    }
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(barX, margin.t, barW, barH);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(fmt(maxVal), barX + barW + 5, margin.t + 10);
    ctx.fillText(fmt(minVal), barX + barW + 5, margin.t + barH);
    ctx.fillText('C(n,N)', barX + barW + 5, margin.t + barH/2);
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Sector Density Heatmap (N: ${nMin}-${nMax})`, W/2, 18);
}

let theoryAnimationId = null;
function animateTheoryViz() {
    if (theoryAnimationId) {
        cancelAnimationFrame(theoryAnimationId);
        theoryAnimationId = null;
        return;
    }
    
    let currentN = 20;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const originalN = document.getElementById('tvMaxN').value;
    
    function step() {
        document.getElementById('tvMaxN').value = currentN;
        drawTheoryViz();
        
        currentN += 5;
        if (currentN <= maxN) {
            theoryAnimationId = requestAnimationFrame(() => setTimeout(step, 100));
        } else {
            document.getElementById('tvMaxN').value = originalN;
            theoryAnimationId = null;
        }
    }
    step();
}

function updateMainStats() {
    const hasExact = state.sectors.some(s=>s.exact!==null);
    const total = hasExact ? state.sectors.reduce((s,x)=>s+(x.exact||0),0) : null;
    const totalPred = state.sectors.reduce((s,x)=>s+x.predicted,0);
    document.getElementById('mainStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${fmt(state.nMax)}</div><div class="stat-label">N</div></div>
        <div class="stat-card"><div class="stat-value">${state.sectorMax}</div><div class="stat-label">Sectors</div></div>
        ${hasExact?`<div class="stat-card"><div class="stat-value">${fmt(total)}</div><div class="stat-label">Exact</div></div>`:''}
        <div class="stat-card"><div class="stat-value">${fmt(totalPred)}</div><div class="stat-label">Predicted</div></div>
        <div class="stat-card"><div class="stat-value">${(6/Math.PI/Math.PI).toFixed(4)}</div><div class="stat-label">6/π²</div></div>
    `;
}

function updateMainCharts() {
    const labels = state.sectors.map(s=>s.n);
    const hasExact = state.sectors.some(s=>s.exact!==null);
    
    if(state.charts.mainCount) state.charts.mainCount.destroy();
    const ds = [{label:'Predicted',data:state.sectors.map(s=>s.predicted),borderColor:'#22c55e',borderDash:[5,5],fill:false}];
    if(hasExact) ds.unshift({label:'Exact',data:state.sectors.map(s=>s.exact),borderColor:'#6366f1',backgroundColor:'rgba(99,102,241,0.1)',fill:true});
    state.charts.mainCount = new Chart(document.getElementById('mainCountChart'),{type:'line',data:{labels,datasets:ds},options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.mainError) state.charts.mainError.destroy();
    if(hasExact) {
        state.charts.mainError = new Chart(document.getElementById('mainErrorChart'),{type:'bar',data:{labels,datasets:[{label:'Rel Err%',data:state.sectors.map(s=>s.relError),backgroundColor:'rgba(245,158,11,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    }
}

function updateMainTable() {
    const tbody = document.querySelector('#mainTable tbody');
    let html = '';
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        const primeCount = res.filter(r => r.isPrime).length;
        const compositeCount = res.length - primeCount;
        const errColor = s.relError && Math.abs(s.relError) > 10 ? '#f87171' : '#4ade80';
        html += '<tr onclick="openSectorModal(' + s.n + ')" style="cursor:pointer" title="Click to see sector ' + s.n + ' details">' +
            '<td><strong>' + s.n + '</strong></td>' +
            '<td>(1/' + (s.n+1) + ', 1/' + s.n + ']</td>' +
            '<td>' + (s.exact !== null ? s.exact : '-') + '</td>' +
            '<td>' + fmt(s.predicted) + '</td>' +
            '<td style="color:' + errColor + '">' + (s.relError ? s.relError.toFixed(1) + '%' : '-') + '</td>' +
            '<td style="color:#f59e0b">' + (primeCount || '-') + '</td>' +
            '<td style="color:#6366f1">' + (compositeCount || '-') + '</td>' +
            '</tr>';
    });
    tbody.innerHTML = html;
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = `Sector ${n}: (1/${n+1}, 1/${n}]`;
    
    let html = `
        <div class="stat-grid" style="margin-bottom:15px;">
            <div class="stat-card"><div class="stat-value">${res.length}</div><div class="stat-label">Total Pairs</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#f59e0b">${primes.length}</div><div class="stat-label">Prime Moduli</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#6366f1">${composites.length}</div><div class="stat-label">Composite Moduli</div></div>
            <div class="stat-card"><div class="stat-value">${sector ? fmt(sector.predicted) : '-'}</div><div class="stat-label">Predicted</div></div>
            <div class="stat-card"><div class="stat-value">${sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-'}</div><div class="stat-label">Error</div></div>
        </div>
        
        <h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (${primes.length})</h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #f59e0b30;">
            ${primes.length > 0 ? primes.map(p => `<span class="residue-item prime" title="m=${p.m} is prime">${p.r}/${p.m}</span>`).join('') : '<span style="color:#64748b">No prime moduli in this sector</span>'}
        </div>
        
        <h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (${composites.length}) <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #6366f130;">
            ${composites.length > 0 ? composites.slice(0,100).map(c => `<span class="residue-item">${c.r}/${c.m}</span>`).join('') : '<span style="color:#64748b">No composite moduli in this sector</span>'}
            ${composites.length > 100 ? `<span style="color:#64748b; display:block; margin-top:8px;">... and ${composites.length - 100} more</span>` : ''}
        </div>
        
        <div style="margin-top:15px; display:flex; gap:10px;">
            <button onclick="exportSectorData(${n})">Export Sector CSV</button>
            <button class="secondary" onclick="viewSectorOnRing(${n})">View on Ring</button>
        </div>
    `;
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += `${r.r},${r.m},${r.value},${r.isPrime}\n`;
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `sector_${n}_data.csv`;
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

function drawMainRing() {
    const canvas = document.getElementById('mainRing'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-35;
    const sector = +document.getElementById('viewSector').value;
    const colorMode = document.getElementById('colorMode').value;
    const showAll = document.getElementById('showAllSectors').checked;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
    for(let n=1; n<=Math.min(15,state.sectorMax); n++) {
        const angle = (1/n)*2*Math.PI;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(angle)*maxR, cy-Math.sin(angle)*maxR); ctx.stroke();
        ctx.fillStyle='#64748b'; ctx.font='9px system-ui';
        ctx.fillText(`1/${n}`, cx+Math.cos(angle)*(maxR+12)-8, cy-Math.sin(angle)*(maxR+12));
    }
    
    if(!showAll) {
        const a1=(1/(sector+1))*2*Math.PI, a2=(1/sector)*2*Math.PI;
        ctx.fillStyle='rgba(99,102,241,0.1)'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,maxR,-a2,-a1); ctx.closePath(); ctx.fill();
    }
    
    state.ringPoints = [];
    let residues = showAll ? Object.values(state.residuesBySector).flat() : (state.residuesBySector[sector]||[]);
    
    let maxGap=0, minGap=Infinity;
    residues.forEach(r => { const g=r.gapRight||0; if(g>maxGap)maxGap=g; if(g>0&&g<minGap)minGap=g; });
    
    residues.forEach(res => {
        const {r,m,sector:s,isPrime:ip} = res;
        const angle = (r/m)*2*Math.PI, rad = (m/state.nMax)*maxR;
        const x = cx+rad*Math.cos(angle), y = cy-rad*Math.sin(angle);
        let color;
        switch(colorMode) {
            case 'sector': color = getSectorColor(s); break;
            case 'prime': color = ip?'#f59e0b':'#6366f1'; break;
            case 'denominator': color = `hsl(${260-(m/state.nMax)*200},70%,60%)`; break;
            case 'gap': const g=res.gapRight||minGap; const gn=maxGap>minGap?(g-minGap)/(maxGap-minGap):0.5; color=`hsl(${120-gn*120},80%,50%)`; break;
            default: color='#6366f1';
        }
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,colorMode==='prime'&&ip?3:2,0,2*Math.PI); ctx.fill();
        state.ringPoints.push({x,y,r,m,sector:s,isPrime:ip,gap:res.gapRight,color});
    });
    
    ctx.fillStyle='#e2e8f0'; ctx.beginPath(); ctx.arc(cx,cy,4,0,2*Math.PI); ctx.fill();
    updateColorLegend(colorMode, showAll, sector);
}

function updateColorLegend(colorMode, showAll, sector) {
    const legend = document.getElementById('colorLegend');
    let html = '';
    switch(colorMode) {
        case 'sector': if(showAll) { for(let s=1;s<=Math.min(10,state.sectorMax);s++) html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(s)}"></div>S${s}</div>`; } else html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(sector)}"></div>Sector ${sector}</div>`; break;
        case 'prime': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Composite</div>`; break;
        case 'denominator': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(260,70%,60%)"></div>Small m</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(60,70%,60%)"></div>Large m</div>`; break;
        case 'gap': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(120,80%,50%)"></div>Small</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,80%,50%)"></div>Large</div>`; break;
    }
    legend.innerHTML = html;
}

document.getElementById('mainRing').addEventListener('click', function(e) {
    const rect = this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=15;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    if(closest) {
        openPointModal(closest);
        selectPointForTree(closest);
        selectFractionForHarmonic(closest.r, closest.m);
    }
});

document.getElementById('mainRing').addEventListener('mousemove', function(e) {
    const rect=this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=12;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    const tooltip = document.getElementById('pointTooltip');
    if(closest) {
        tooltip.innerHTML = `<h5>${closest.r}/${closest.m}</h5><div class="row"><span class="label">Value:</span><span class="val">${(closest.r/closest.m).toFixed(6)}</span></div><div class="row"><span class="label">Sector:</span><span class="val">${closest.sector}</span></div><div class="row"><span class="label">Mod:</span><span class="val">${closest.m} (${closest.isPrime?'P':'C'})</span></div>`;
        tooltip.style.left = (e.clientX-rect.left+10)+'px'; tooltip.style.top = (e.clientY-rect.top-10)+'px';
        tooltip.classList.add('visible');
    } else tooltip.classList.remove('visible');
});

function openPointModal(p) {
    document.getElementById('pointModalTitle').textContent = `${p.r}/${p.m}`;
    const cf = toCF(p.r, p.m);
    document.getElementById('pointModalBody').innerHTML = `
        <div class="detail-grid">
            <div class="detail-card"><h5>Fraction</h5><div class="value">${p.r}/${p.m}</div><div class="sub">= ${(p.r/p.m).toFixed(8)}</div></div>
            <div class="detail-card"><h5>Sector</h5><div class="value">${p.sector}</div><div class="sub">(1/${p.sector+1}, 1/${p.sector}]</div></div>
            <div class="detail-card"><h5>Modulus</h5><div class="value" style="color:${p.isPrime?'#f59e0b':'#6366f1'}">${p.m}</div><div class="sub">${p.isPrime?'Prime':'Composite'}</div></div>
        </div>
        <div class="theorem-box"><strong>CF:</strong> [${cf.join('; ')}]<br><strong>Path:</strong> ${cfPath(cf)}</div>
        <div style="margin-top:12px;">
            <button onclick="closePointModal(); openSectorModal(${p.sector});">View All in Sector ${p.sector}</button>
        </div>
    `;
    document.getElementById('pointModal').classList.add('active');
}
function closePointModal() { document.getElementById('pointModal').classList.remove('active'); }
function openSectorModal(n) { document.getElementById('viewSector').value=n; document.getElementById('showAllSectors').checked=false; drawMainRing(); }

// SECTOR TREE VISUALIZATION
let selectedTreePoint = null;
let treeAnimationId = null;

function drawSectorTree() {
    const canvas = document.getElementById('sectorTreeCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const depth = +document.getElementById('treeDepth').value;
    const showLabels = document.getElementById('showTreeLabels').checked;
    const showGrid = document.getElementById('showTreeGrid').checked;
    const showArnold = document.getElementById('showArnoldOnTree')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw grid if enabled
    if (showGrid) {
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        for (let i = 1; i < depth; i++) {
            const y = 40 + (i / depth) * (H - 80);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
    }
    
    // Build and draw Stern-Brocot tree
    const treeNodes = buildSternBrocotTree(depth);
    
    // Draw edges first
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    treeNodes.forEach(node => {
        if (node.parent) {
            ctx.beginPath();
            ctx.moveTo(node.parent.x, node.parent.y);
            ctx.lineTo(node.x, node.y);
            ctx.stroke();
        }
    });
    
    // Draw nodes
    treeNodes.forEach(node => {
        const isOnPath = selectedTreePoint && isNodeOnPath(node, selectedTreePoint);
        const isTarget = selectedTreePoint && node.r === selectedTreePoint.r && node.m === selectedTreePoint.m;
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, isTarget ? 10 : (isOnPath ? 7 : 5), 0, 2 * Math.PI);
        
        if (isTarget) {
            ctx.fillStyle = '#22c55e';
        } else if (isOnPath) {
            ctx.fillStyle = '#f59e0b';
        } else if (showArnold && typeof getHarmonicMode === 'function') {
            // Color by harmonic mode (Arnold tongue)
            const mode = getHarmonicMode(node.m);
            ctx.fillStyle = mode.color;
        } else {
            ctx.fillStyle = '#6366f1';
        }
        ctx.fill();
        
        if (showLabels && node.depth <= 5) {
            ctx.fillStyle = '#e2e8f0';
            ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
        }
    });
    
    // Draw highlighted path if point selected
    if (selectedTreePoint) {
        drawTreePath(ctx, treeNodes, selectedTreePoint);
    }
    
    // Draw tree labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('0/1', 10, 30);
    ctx.textAlign = 'right';
    ctx.fillText('1/1', W - 10, 30);
    ctx.textAlign = 'center';
    ctx.fillText('1/2 (root)', W/2, 25);
    
    // Depth markers
    ctx.textAlign = 'left';
    ctx.fillStyle = '#475569';
    for (let d = 1; d <= Math.min(depth, 6); d++) {
        const y = 40 + (d / depth) * (H - 80);
        ctx.fillText(`d=${d}`, 5, y + 4);
    }
}

function buildSternBrocotTree(maxDepth) {
    const nodes = [];
    const W = document.getElementById('sectorTreeCanvas').width;
    const H = document.getElementById('sectorTreeCanvas').height;
    
    // Root node: 1/2
    const root = { r: 1, m: 2, depth: 1, x: W/2, y: 50, parent: null, path: '', leftAncestor: {r:0,m:1}, rightAncestor: {r:1,m:1} };
    nodes.push(root);
    
    // BFS to build tree
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        if (node.depth >= maxDepth) continue;
        
        const nextDepth = node.depth + 1;
        const levelY = 40 + (nextDepth / maxDepth) * (H - 80);
        const spreadFactor = Math.pow(0.5, nextDepth) * W * 0.45;
        
        // Left child: mediant of left ancestor and current
        const leftR = node.leftAncestor.r + node.r;
        const leftM = node.leftAncestor.m + node.m;
        if (leftM <= 200) {
            const leftChild = {
                r: leftR, m: leftM, depth: nextDepth,
                x: node.x - spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'L',
                leftAncestor: node.leftAncestor,
                rightAncestor: { r: node.r, m: node.m }
            };
            nodes.push(leftChild);
            queue.push(leftChild);
        }
        
        // Right child: mediant of current and right ancestor
        const rightR = node.r + node.rightAncestor.r;
        const rightM = node.m + node.rightAncestor.m;
        if (rightM <= 200) {
            const rightChild = {
                r: rightR, m: rightM, depth: nextDepth,
                x: node.x + spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'R',
                leftAncestor: { r: node.r, m: node.m },
                rightAncestor: node.rightAncestor
            };
            nodes.push(rightChild);
            queue.push(rightChild);
        }
    }
    
    return nodes;
}

function isNodeOnPath(node, target) {
    // Check if this node is on the path to the target
    const targetPath = getPathToFraction(target.r, target.m);
    return targetPath.startsWith(node.path) || node.path === '' || 
           (node.r === 1 && node.m === 2 && targetPath.length > 0);
}

function getPathToFraction(r, m) {
    // Generate the Stern-Brocot path to reach r/m
    let path = '';
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    const targetVal = r / m;
    const maxIter = 100;
    let iter = 0;
    
    while (iter < maxIter && (medR !== r || medM !== m)) {
        const medVal = medR / medM;
        
        if (targetVal < medVal) {
            // Go left
            path += 'L';
            rightR = medR;
            rightM = medM;
        } else if (targetVal > medVal) {
            // Go right
            path += 'R';
            leftR = medR;
            leftM = medM;
        } else {
            break;
        }
        
        medR = leftR + rightR;
        medM = leftM + rightM;
        iter++;
    }
    
    return path;
}

function drawTreePath(ctx, treeNodes, target) {
    const path = getPathToFraction(target.r, target.m);
    const animate = document.getElementById('animatePath').checked;
    
    // Find nodes on path
    const pathNodes = [treeNodes.find(n => n.r === 1 && n.m === 2)]; // Start with root
    let currentPath = '';
    
    for (let i = 0; i < path.length; i++) {
        currentPath += path[i];
        const node = treeNodes.find(n => n.path === currentPath);
        if (node) pathNodes.push(node);
    }
    
    // Draw path edges with highlight
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#f59e0b';
    ctx.shadowBlur = 10;
    
    for (let i = 0; i < pathNodes.length - 1; i++) {
        const from = pathNodes[i];
        const to = pathNodes[i + 1];
        
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        
        // Draw direction indicator
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;
        const dir = path[i];
        
        ctx.fillStyle = dir === 'L' ? '#ef4444' : '#3b82f6';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(dir, midX + (dir === 'L' ? -15 : 15), midY);
    }
    
    ctx.shadowBlur = 0;
    
    // Draw target node larger
    if (pathNodes.length > 0) {
        const targetNode = pathNodes[pathNodes.length - 1];
        ctx.beginPath();
        ctx.arc(targetNode.x, targetNode.y, 12, 0, 2 * Math.PI);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${target.r}/${target.m}`, targetNode.x, targetNode.y - 18);
    }
}

function updateTreePathInfo(point) {
    const path = getPathToFraction(point.r, point.m);
    const cf = toCF(point.r, point.m);
    
    // Count L's and R's
    const lCount = (path.match(/L/g) || []).length;
    const rCount = (path.match(/R/g) || []).length;
    
    // Format path with colors
    const coloredPath = path.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    document.getElementById('treePathInfo').innerHTML = `
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:15px;">
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Target Fraction</div>
                <div style="color:#22c55e; font-size:1.4em; font-weight:bold;">${point.r}/${point.m}</div>
                <div style="color:#64748b; font-size:0.85em;">= ${(point.r/point.m).toFixed(8)}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
                <div style="font-size:1.1em; word-break:break-all;">${coloredPath || '<span style="color:#22c55e;">ROOT</span>'}</div>
                <div style="color:#64748b; font-size:0.85em;">Length: ${path.length} steps</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Path Statistics</div>
                <div><span style="color:#ef4444;">L: ${lCount}</span> | <span style="color:#3b82f6;">R: ${rCount}</span></div>
                <div style="color:#64748b; font-size:0.85em;">Ratio: ${lCount > 0 ? (rCount/lCount).toFixed(2) : '∞'}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
                <div style="color:#8b5cf6;">[${cf.join('; ')}]</div>
                <div style="color:#64748b; font-size:0.85em;">Depth: ${cf.length} terms</div>
            </div>
        </div>
        <div style="margin-top:12px; padding-top:12px; border-top:1px solid #334155;">
            <span style="color:#94a3b8; font-size:0.8em;">Sector:</span> <span style="color:#6366f1;">${point.sector}</span> 
            <span style="margin-left:15px; color:#94a3b8; font-size:0.8em;">Modulus:</span> 
            <span style="color:${point.isPrime ? '#f59e0b' : '#6366f1'};">${point.m} (${point.isPrime ? 'Prime' : 'Composite'})</span>
        </div>
    `;
}

function clearTreePath() {
    selectedTreePoint = null;
    drawSectorTree();
    document.getElementById('treePathInfo').innerHTML = '<span style="color:#64748b;">Click a point on the ring above to see its tree path</span>';
}

function playTreeFraction() {
    if (selectedTreePoint) {
        playFraction(selectedTreePoint.r, selectedTreePoint.m, 0.8);
        
        // Visual feedback
        const btn = document.getElementById('treePlayBtn');
        btn.style.transform = 'scale(1.1)';
        setTimeout(() => btn.style.transform = 'scale(1)', 150);
    } else {
        alert('Select a point on the ring first to play its frequency');
    }
}

function playTreeScale() {
    if (!selectedTreePoint) {
        alert('Select a point on the ring first');
        return;
    }
    
    initAudioContext();
    
    // Get all fractions along the path to the selected point
    const path = getPathToFraction(selectedTreePoint.r, selectedTreePoint.m);
    const fractions = [{ r: 1, m: 2 }]; // Start with root
    
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    for (let i = 0; i < path.length; i++) {
        if (path[i] === 'L') {
            rightR = medR;
            rightM = medM;
        } else {
            leftR = medR;
            leftM = medM;
        }
        medR = leftR + rightR;
        medM = leftM + rightM;
        fractions.push({ r: medR, m: medM });
    }
    
    // Play each fraction in sequence
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => {
            playFraction(f.r, f.m, 0.35);
            
            // Highlight in tree path info
            const info = document.getElementById('treePathInfo');
            if (info) {
                const highlight = document.createElement('span');
                highlight.style.cssText = 'background:#6366f1;padding:2px 6px;border-radius:3px;margin-left:5px;';
                highlight.textContent = `Playing: ${f.r}/${f.m}`;
                const existing = info.querySelector('.playing-indicator');
                if (existing) existing.remove();
                highlight.className = 'playing-indicator';
                info.appendChild(highlight);
            }
        }, delay);
        delay += 300;
    });
    
    // Clean up indicator after all notes played
    setTimeout(() => {
        const indicator = document.querySelector('.playing-indicator');
        if (indicator) indicator.remove();
    }, delay + 500);
}

function selectPointForTree(point) {
    selectedTreePoint = point;
    updateTreePathInfo(point);
    
    const animate = document.getElementById('animatePath').checked;
    if (animate) {
        animateTreePath(point);
    } else {
        drawSectorTree();
    }
}

function animateTreePath(point) {
    if (treeAnimationId) {
        cancelAnimationFrame(treeAnimationId);
    }
    
    const path = getPathToFraction(point.r, point.m);
    let currentStep = 0;
    
    function animateStep() {
        const canvas = document.getElementById('sectorTreeCanvas');
        const ctx = canvas.getContext('2d');
        const depth = +document.getElementById('treeDepth').value;
        const showLabels = document.getElementById('showTreeLabels').checked;
        
        // Redraw base tree
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const treeNodes = buildSternBrocotTree(depth);
        
        // Draw all edges
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        treeNodes.forEach(node => {
            if (node.parent) {
                ctx.beginPath();
                ctx.moveTo(node.parent.x, node.parent.y);
                ctx.lineTo(node.x, node.y);
                ctx.stroke();
            }
        });
        
        // Draw nodes
        treeNodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#6366f1';
            ctx.fill();
            
            if (showLabels && node.depth <= 5) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
            }
        });
        
        // Draw animated path up to current step
        const partialPath = path.substring(0, currentStep);
        let currentNode = treeNodes.find(n => n.r === 1 && n.m === 2);
        
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#f59e0b';
        ctx.shadowBlur = 10;
        
        let pathStr = '';
        for (let i = 0; i < partialPath.length; i++) {
            pathStr += partialPath[i];
            const nextNode = treeNodes.find(n => n.path === pathStr);
            if (nextNode && currentNode) {
                ctx.beginPath();
                ctx.moveTo(currentNode.x, currentNode.y);
                ctx.lineTo(nextNode.x, nextNode.y);
                ctx.stroke();
                
                // Direction label
                const midX = (currentNode.x + nextNode.x) / 2;
                const midY = (currentNode.y + nextNode.y) / 2;
                ctx.fillStyle = partialPath[i] === 'L' ? '#ef4444' : '#3b82f6';
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(partialPath[i], midX + (partialPath[i] === 'L' ? -15 : 15), midY);
                
                currentNode = nextNode;
            }
        }
        
        ctx.shadowBlur = 0;
        
        // Highlight current position
        if (currentNode) {
            ctx.beginPath();
            ctx.arc(currentNode.x, currentNode.y, currentStep === path.length ? 12 : 8, 0, 2 * Math.PI);
            ctx.fillStyle = currentStep === path.length ? '#22c55e' : '#f59e0b';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        currentStep++;
        
        if (currentStep <= path.length) {
            treeAnimationId = requestAnimationFrame(() => setTimeout(animateStep, 150));
        }
    }
    
    animateStep();
}

// GAP ANALYSIS
function updateGapAnalysis() {
    if(state.gaps.length===0) { document.getElementById('gapStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const gaps = state.gaps.map(g=>g.gap);
    const mean = gaps.reduce((a,b)=>a+b,0)/gaps.length;
    const sorted = [...gaps].sort((a,b)=>a-b);
    const median = sorted[Math.floor(sorted.length/2)];
    const maxGap = sorted[sorted.length-1];
    const minGap = sorted[0];
    
    document.getElementById('gapStats').innerHTML = 
        '<div class="stat-card"><div class="stat-value">' + state.gaps.length + '</div><div class="stat-label">Total Gaps</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + mean.toExponential(2) + '</div><div class="stat-label">Mean Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + median.toExponential(2) + '</div><div class="stat-label">Median</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#ef4444">' + maxGap.toExponential(2) + '</div><div class="stat-label">Max Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#22c55e">' + minGap.toExponential(2) + '</div><div class="stat-label">Min Gap</div></div>';
    
    // Gap Distribution - Gradient colored histogram
    const bins = 20;
    const bw = (maxGap - minGap) / bins;
    const hist = new Array(bins).fill(0);
    gaps.forEach(g => { const b = Math.min(bins-1, Math.floor((g-minGap)/bw)); hist[b]++; });
    
    const gradientColors = hist.map((_, i) => {
        const ratio = i / (bins - 1);
        const r = Math.round(34 + ratio * (239 - 34));
        const g = Math.round(197 - ratio * (197 - 68));
        const b = Math.round(94 - ratio * (94 - 68));
        return 'rgba(' + r + ',' + g + ',' + b + ',0.8)';
    });
    
    if(state.charts.gapDist) state.charts.gapDist.destroy();
    state.charts.gapDist = new Chart(document.getElementById('gapDistChart'), {
        type: 'bar',
        data: {
            labels: hist.map((_, i) => (minGap + i * bw).toExponential(1)),
            datasets: [{
                label: 'Frequency',
                data: hist,
                backgroundColor: gradientColors,
                borderColor: gradientColors.map(c => c.replace('0.8', '1')),
                borderWidth: 1,
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Gap Size Distribution (Small to Large)', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8', maxRotation: 45, font: { size: 9 } },
                    grid: { color: '#334155' }
                },
                y: { 
                    title: { display: true, text: 'Count', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Gap vs Denom Product - Scatter with theoretical curve
    const sample = state.gaps.slice(0, 500);
    const scatterData = sample.map(g => ({ x: g.left.m * g.right.m, y: g.gap }));
    
    // Generate theoretical curve points
    const maxProd = Math.max(...sample.map(g => g.left.m * g.right.m));
    const theoreticalPoints = [];
    for (let p = 4; p <= maxProd; p += Math.max(1, Math.floor(maxProd / 100))) {
        theoreticalPoints.push({ x: p, y: 1 / p });
    }
    
    if(state.charts.gapVsDenom) state.charts.gapVsDenom.destroy();
    state.charts.gapVsDenom = new Chart(document.getElementById('gapVsDenomChart'), {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Actual Gaps',
                    data: scatterData,
                    backgroundColor: scatterData.map(d => {
                        const ratio = Math.min(1, d.y * 1000);
                        return 'rgba(' + Math.round(99 + ratio * 140) + ',' + Math.round(102 - ratio * 50) + ',' + Math.round(241 - ratio * 100) + ',0.6)';
                    }),
                    pointRadius: 3,
                    pointHoverRadius: 6
                },
                {
                    label: 'Theoretical 1/(bd)',
                    data: theoreticalPoints,
                    type: 'line',
                    borderColor: '#22c55e',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { labels: { color: '#94a3b8' } },
                title: { display: true, text: 'Gap = 1/(b×d) Verification', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Denominator Product (b×d)', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                },
                y: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Update gap table with more info
    document.querySelector('#gapTable tbody').innerHTML = state.gaps.slice(0, 30).map((g, i) => {
        const match = Math.abs(g.gap - g.theoretical) < 1e-15;
        return '<tr>' +
            '<td>' + (i+1) + '</td>' +
            '<td><strong>' + g.left.r + '/' + g.left.m + '</strong></td>' +
            '<td><strong>' + g.right.r + '/' + g.right.m + '</strong></td>' +
            '<td style="color:#f59e0b">' + g.gap.toExponential(4) + '</td>' +
            '<td style="color:#22c55e">' + g.theoretical.toExponential(4) + '</td>' +
            '<td style="color:' + (match ? '#22c55e' : '#ef4444') + '">' + (match ? 'Yes' : 'No') + '</td>' +
            '</tr>';
    }).join('');
}

// FRANEL-LANDAU
function computeFranel() {
    if(state.farey.length===0) { document.getElementById('franelStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const n = state.farey.length;
    const deviations = state.farey.map((f,k) => ({ k, delta: f.value - (k+1)/n }));
    const sumAbsDelta = deviations.reduce((s,d)=>s+Math.abs(d.delta),0);
    const N = state.nMax;
    
    document.getElementById('franelStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${n}</div><div class="stat-label">|F_N|</div></div>
        <div class="stat-card"><div class="stat-value">${sumAbsDelta.toFixed(4)}</div><div class="stat-label">Σ|δ|</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.sqrt(N)).toFixed(4)}</div><div class="stat-label">Σ|δ|/√N</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.pow(N,0.5+0.01)).toFixed(4)}</div><div class="stat-label">Σ|δ|/N^0.51</div></div>
    `;
    
    const sampleRate = Math.max(1, Math.floor(n/200));
    const sampled = deviations.filter((_,i)=>i%sampleRate===0);
    
    if(state.charts.franelDeviation) state.charts.franelDeviation.destroy();
    state.charts.franelDeviation = new Chart(document.getElementById('franelDeviationChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'δ_k',data:sampled.map(d=>d.delta),borderColor:'#6366f1',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    let cumSum = 0;
    const cumData = sampled.map(d => { cumSum += Math.abs(d.delta)*sampleRate; return cumSum/Math.sqrt(d.k+1); });
    if(state.charts.franelCumulative) state.charts.franelCumulative.destroy();
    state.charts.franelCumulative = new Chart(document.getElementById('franelCumulativeChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'Cum|δ|/√k',data:cumData,borderColor:'#8b5cf6',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const alphas = [0.4, 0.45, 0.5, 0.55, 0.6];
    const alphaData = alphas.map(a => sumAbsDelta / Math.pow(N, a));
    if(state.charts.franelAlpha) state.charts.franelAlpha.destroy();
    state.charts.franelAlpha = new Chart(document.getElementById('franelAlphaChart'),{type:'bar',data:{labels:alphas.map(a=>`α=${a}`),datasets:[{label:'Σ|δ|/N^α',data:alphaData,backgroundColor:alphas.map(a=>a<=0.5?'rgba(239,68,68,0.7)':'rgba(34,197,94,0.7)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// DEDEKIND
function computeDedekind() {
    const maxK = +document.getElementById('dedekindMaxK').value;
    const data = [];
    for(let k=2; k<=maxK; k++) {
        for(let h=1; h<k; h++) {
            if(gcd(h,k)===1) {
                const s = sawtoothSum(h,k);
                data.push({h,k,s,s12k:12*k*s});
            }
        }
    }
    
    document.querySelector('#dedekindTable tbody').innerHTML = data.slice(0,50).map(d=>`<tr><td>${d.h}</td><td>${d.k}</td><td>${d.s.toFixed(4)}</td><td>${d.s12k.toFixed(2)}</td><td>${gcd(d.h,d.k)}</td></tr>`).join('');
    
    const s1k = [];
    for(let k=2; k<=maxK; k++) { s1k.push({k, s:sawtoothSum(1,k)}); }
    if(state.charts.dedekind) state.charts.dedekind.destroy();
    state.charts.dedekind = new Chart(document.getElementById('dedekindChart'),{type:'line',data:{labels:s1k.map(d=>d.k),datasets:[{label:'s(1,k)',data:s1k.map(d=>d.s),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Heatmap
    const canvas = document.getElementById('dedekindHeatmap'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cellW=W/maxK, cellH=H/maxK;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    let minS=Infinity, maxS=-Infinity;
    data.forEach(d => { if(d.s<minS)minS=d.s; if(d.s>maxS)maxS=d.s; });
    data.forEach(d => {
        const norm = (d.s-minS)/(maxS-minS);
        ctx.fillStyle = `hsl(${260-norm*200},70%,50%)`;
        ctx.fillRect(d.h*cellW, d.k*cellH, cellW-1, cellH-1);
    });
}

// CONTINUED FRACTIONS
let selectedCFFraction = null;

function updateCFDisplay() {
    const sector = +document.getElementById('cfSector').value;
    const maxTerms = +document.getElementById('cfMaxTerms').value;
    const residues = (state.residuesBySector[sector]||[]).slice(0, maxTerms);
    
    const cfData = residues.map(res => {
        const cf = toCF(res.r, res.m);
        const freq = harmonicSettings.baseFreq * (res.r / res.m);
        const note = frequencyToNote(freq);
        const mode = getHarmonicMode(res.m);
        return { 
            r: res.r, 
            m: res.m, 
            cf, 
            path: cfPath(cf), 
            len: cf.length, 
            sum: cf.reduce((a,b)=>a+b,0),
            freq,
            note,
            mode
        };
    });
    
    // Store for later use
    window.cfDataCache = cfData;
    
    document.querySelector('#cfTable tbody').innerHTML = cfData.map((d, idx) => `
        <tr onclick="selectCFFraction(${idx})" style="cursor:pointer;" class="cf-row" data-idx="${idx}">
            <td><strong>${d.r}/${d.m}</strong></td>
            <td style="font-family:monospace;font-size:0.85em;">[${d.cf.join('; ')}]</td>
            <td class="cf-path" style="max-width:120px;overflow:hidden;text-overflow:ellipsis;">${d.path.slice(0,15)}${d.path.length>15?'...':''}</td>
            <td>${d.len}</td>
            <td>${d.sum}</td>
            <td style="color:#8b5cf6;">${d.freq.toFixed(1)}</td>
            <td>
                <button onclick="event.stopPropagation(); playCFFractionByIndex(${idx})" style="padding:3px 8px;font-size:10px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:3px;color:white;cursor:pointer;">▶</button>
            </td>
        </tr>
    `).join('');
    
    const lenDist = {};
    cfData.forEach(d => { lenDist[d.len] = (lenDist[d.len]||0)+1; });
    const lenLabels = Object.keys(lenDist).sort((a,b)=>a-b);
    if(state.charts.cfLength) state.charts.cfLength.destroy();
    state.charts.cfLength = new Chart(document.getElementById('cfLengthChart'),{type:'bar',data:{labels:lenLabels,datasets:[{label:'Count',data:lenLabels.map(l=>lenDist[l]),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const firstDist = {};
    cfData.forEach(d => { if(d.cf.length>1) { const f=d.cf[1]; firstDist[f]=(firstDist[f]||0)+1; } });
    const firstLabels = Object.keys(firstDist).sort((a,b)=>a-b).slice(0,15);
    if(state.charts.cfFirst) state.charts.cfFirst.destroy();
    state.charts.cfFirst = new Chart(document.getElementById('cfFirstChart'),{type:'bar',data:{labels:firstLabels,datasets:[{label:'Count',data:firstLabels.map(l=>firstDist[l]),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Clear selection info
    if (!selectedCFFraction) {
        document.getElementById('cfSelectedInfo').innerHTML = '<div style="color:#64748b; grid-column:1/-1;">Click a row in the table below to select a fraction</div>';
    }
}

function selectCFFraction(idx) {
    const cfData = window.cfDataCache;
    if (!cfData || !cfData[idx]) return;
    
    const d = cfData[idx];
    selectedCFFraction = d;
    
    // Highlight selected row
    document.querySelectorAll('.cf-row').forEach(row => row.style.background = '');
    document.querySelector(`.cf-row[data-idx="${idx}"]`).style.background = 'rgba(99,102,241,0.2)';
    
    // Update selection info panel
    document.getElementById('cfSelectedInfo').innerHTML = `
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Fraction</div>
            <div style="color:#22c55e; font-size:1.5em; font-weight:bold;">${d.r}/${d.m}</div>
            <div style="color:#64748b; font-size:0.85em;">= ${(d.r/d.m).toFixed(8)}</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
            <div style="color:#8b5cf6; font-size:1.1em; font-family:monospace;">[${d.cf.join('; ')}]</div>
            <div style="color:#64748b; font-size:0.85em;">Length: ${d.len} terms</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
            <div style="font-size:0.9em; word-break:break-all;">${formatColoredPath(d.path)}</div>
        </div>
        <div>
            <div style="color:#94a3b8; font-size:0.8em;">Frequency</div>
            <div style="color:#8b5cf6; font-size:1.3em; font-weight:bold;">${d.freq.toFixed(2)} Hz</div>
            <div style="color:#22c55e;">${d.note.name} <span class="mode-badge ${d.mode.class}" style="font-size:9px;">${d.mode.name}</span></div>
        </div>
        <div style="display:flex; flex-direction:column; gap:6px; justify-content:center;">
            <button onclick="playCFSelected()" style="padding:8px 12px;font-size:12px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;border-radius:4px;color:white;cursor:pointer;font-weight:bold;">▶ Play Fraction</button>
            <button onclick="playCFConvergents()" style="padding:8px 12px;font-size:12px;background:#6366f1;border:none;border-radius:4px;color:white;cursor:pointer;">♪ Convergents</button>
        </div>
    `;
    
    // Trigger global harmonic
    triggerGlobalHarmonic(d.r, d.m);
}

function formatColoredPath(path) {
    if (!path || path.length === 0) return '<span style="color:#22c55e;">ROOT</span>';
    const maxShow = 30;
    const truncated = path.length > maxShow;
    const showPath = truncated ? path.slice(0, maxShow) : path;
    
    const colored = showPath.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    return colored + (truncated ? '<span style="color:#64748b;">...</span>' : '');
}

function playCFFractionByIndex(idx) {
    const cfData = window.cfDataCache;
    if (!cfData || !cfData[idx]) return;
    
    const d = cfData[idx];
    playFraction(d.r, d.m, 0.6);
    
    // Also select it
    selectCFFraction(idx);
}

function playCFSelected() {
    if (!selectedCFFraction) {
        alert('Select a fraction from the table first');
        return;
    }
    playFraction(selectedCFFraction.r, selectedCFFraction.m, 0.8);
}

function playCFConvergents() {
    if (!selectedCFFraction) {
        alert('Select a fraction from the table first');
        return;
    }
    
    initAudioContext();
    
    // Compute convergents from the continued fraction
    const cf = selectedCFFraction.cf;
    const convergents = [];
    
    let p_prev = 1, q_prev = 0;
    let p_curr = cf[0], q_curr = 1;
    
    convergents.push({ r: p_curr, m: q_curr });
    
    for (let i = 1; i < cf.length; i++) {
        const a = cf[i];
        const p_next = a * p_curr + p_prev;
        const q_next = a * q_curr + q_prev;
        
        convergents.push({ r: p_next, m: q_next });
        
        p_prev = p_curr;
        q_prev = q_curr;
        p_curr = p_next;
        q_curr = q_next;
    }
    
    // Play each convergent
    let delay = 0;
    convergents.forEach((conv, i) => {
        setTimeout(() => {
            playFraction(conv.r, conv.m, 0.35);
            
            // Show which convergent is playing
            const info = document.getElementById('cfSelectedInfo');
            if (info) {
                let indicator = info.querySelector('.playing-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.className = 'playing-indicator';
                    indicator.style.cssText = 'grid-column:1/-1; margin-top:10px; padding:8px; background:#0f172a; border-radius:4px; text-align:center;';
                    info.appendChild(indicator);
                }
                indicator.innerHTML = `<span style="color:#22c55e;">Playing convergent ${i+1}/${convergents.length}:</span> <strong style="color:#8b5cf6;">${conv.r}/${conv.m}</strong> <span style="color:#64748b;">= ${(conv.r/conv.m).toFixed(6)}</span>`;
            }
        }, delay);
        delay += 400;
    });
    
    // Clean up indicator
    setTimeout(() => {
        const indicator = document.querySelector('#cfSelectedInfo .playing-indicator');
        if (indicator) {
            indicator.innerHTML = '<span style="color:#22c55e;">✓ Played all convergents</span>';
            setTimeout(() => indicator.remove(), 1500);
        }
    }, delay + 500);
}

function playCFAll() {
    const cfData = window.cfDataCache;
    if (!cfData || cfData.length === 0) {
        alert('No fractions to play. Run computation first.');
        return;
    }
    
    initAudioContext();
    
    // Sort by value for ascending scale
    const sorted = [...cfData].sort((a, b) => (a.r / a.m) - (b.r / b.m));
    const toPlay = sorted.slice(0, 20); // Limit to 20 for reasonable duration
    
    let delay = 0;
    toPlay.forEach((d, i) => {
        setTimeout(() => {
            playFraction(d.r, d.m, 0.25);
            
            // Highlight row
            document.querySelectorAll('.cf-row').forEach(row => {
                const idx = parseInt(row.dataset.idx);
                if (cfData[idx] && cfData[idx].r === d.r && cfData[idx].m === d.m) {
                    row.style.background = 'rgba(34,197,94,0.3)';
                    setTimeout(() => row.style.background = '', 200);
                }
            });
        }, delay);
        delay += 200;
    });
}

// PSL(2,Z)
function computePSL() {
    const maxDenom = +document.getElementById('pslMaxDenom').value;
    const farey = [{r:0,m:1}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) farey.push({r,m});
        }
    }
    farey.push({r:1,m:1});
    farey.sort((a,b)=>a.r/a.m - b.r/b.m);
    
    let html = '';
    const matrices = [];
    for(let i=0; i<farey.length-1 && matrices.length<20; i++) {
        const a=farey[i].r, b=farey[i].m, c=farey[i+1].r, d=farey[i+1].m;
        const det = a*d - b*c;
        matrices.push({a,b,c,d,det});
        html += `<div class="matrix-display"><span style="color:#64748b">${a}/${b}, ${c}/${d}:</span> [${a},${c}; ${b},${d}] det=${det}</div>`;
    }
    document.getElementById('pslMatrices').innerHTML = html;
    
    const verified = matrices.every(m=>Math.abs(m.det)===1);
    document.getElementById('pslVerification').innerHTML = `<div class="info-badge ${verified?'success':'warning'}">${verified?'All determinants = ±1':'Some errors'}</div><p style="margin-top:10px;font-size:0.85em;">Verified ${matrices.length} neighbor pairs. The condition |ad-bc|=1 confirms these are valid Farey neighbors.</p>`;
    
    // Ford circles
    const canvas = document.getElementById('fordCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, margin=30, scale=W-2*margin;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#475569'; ctx.beginPath(); ctx.moveTo(margin,H-20); ctx.lineTo(W-margin,H-20); ctx.stroke();
    
    farey.forEach(f => {
        const x = margin + (f.r/f.m)*scale;
        const radius = Math.max(1, scale/(2*f.m*f.m));
        ctx.beginPath(); ctx.arc(x, H-20-radius, radius, 0, 2*Math.PI);
        ctx.fillStyle = 'rgba(99,102,241,0.4)'; ctx.fill();
        ctx.strokeStyle = '#6366f1'; ctx.stroke();
    });
}

// EULER PRODUCT
function computeEulerProduct() {
    const maxP = +document.getElementById('eulerMaxP').value;
    const primes = [];
    for(let n=2; n<=maxP; n++) if(isPrime(n)) primes.push(n);
    
    let product = 1, sum = 0;
    const productData = [], sumData = [];
    const target = 6/(Math.PI*Math.PI);
    const targetSum = Math.PI*Math.PI/6;
    
    let termsHtml = '';
    primes.forEach((p,i) => {
        const term = 1 - 1/(p*p);
        product *= term;
        productData.push({p, product});
        termsHtml += `<span class="euler-term prime">(1-1/${p}²) = ${term.toFixed(6)}</span>`;
    });
    
    for(let n=1; n<=maxP; n++) {
        sum += 1/(n*n);
        sumData.push({n, sum});
    }
    
    document.getElementById('eulerStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primes.length}</div><div class="stat-label">Primes</div></div>
        <div class="stat-card"><div class="stat-value">${product.toFixed(6)}</div><div class="stat-label">∏(1-1/p²)</div></div>
        <div class="stat-card"><div class="stat-value">${target.toFixed(6)}</div><div class="stat-label">6/π²</div></div>
        <div class="stat-card"><div class="stat-value">${((product-target)/target*100).toFixed(2)}%</div><div class="stat-label">Error</div></div>
    `;
    
    document.getElementById('eulerTerms').innerHTML = termsHtml;
    
    if(state.charts.eulerProduct) state.charts.eulerProduct.destroy();
    state.charts.eulerProduct = new Chart(document.getElementById('eulerProductChart'),{type:'line',data:{labels:productData.map(d=>d.p),datasets:[{label:'∏(1-1/p²)',data:productData.map(d=>d.product),borderColor:'#6366f1',fill:false},{label:'6/π²',data:productData.map(()=>target),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.eulerSum) state.charts.eulerSum.destroy();
    state.charts.eulerSum = new Chart(document.getElementById('eulerSumChart'),{type:'line',data:{labels:sumData.map(d=>d.n),datasets:[{label:'Σ1/n²',data:sumData.map(d=>d.sum),borderColor:'#8b5cf6',fill:false},{label:'π²/6',data:sumData.map(()=>targetSum),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// MODULAR
function updateModularAnalysis() {
    const k = +document.getElementById('modK').value;
    const a = +document.getElementById('modA').value;
    
    const filtered = state.allResidues.filter(r => r.m % k === a % k);
    const bySector = {};
    filtered.forEach(r => { if(r.sector) { bySector[r.sector] = (bySector[r.sector]||0)+1; } });
    
    const residueClasses = {};
    for(let i=0; i<k; i++) residueClasses[i] = state.allResidues.filter(r=>r.m%k===i).length;
    
    document.getElementById('modularStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${filtered.length}</div><div class="stat-label">m≡${a} (mod ${k})</div></div>
        <div class="stat-card"><div class="stat-value">${state.allResidues.length}</div><div class="stat-label">Total</div></div>
        <div class="stat-card"><div class="stat-value">${(filtered.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Fraction</div></div>
    `;
    
    if(state.charts.residueClass) state.charts.residueClass.destroy();
    state.charts.residueClass = new Chart(document.getElementById('residueClassChart'),{type:'bar',data:{labels:Object.keys(residueClasses),datasets:[{label:'Count',data:Object.values(residueClasses),backgroundColor:Object.keys(residueClasses).map(i=>i==a?'rgba(245,158,11,0.8)':'rgba(99,102,241,0.6)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime channel
    const primeOwnership = {};
    [2,3,5,7,11,13].forEach(p => {
        primeOwnership[p] = state.allResidues.filter(r=>r.m%p===0).length;
    });
    if(state.charts.primeChannel) state.charts.primeChannel.destroy();
    state.charts.primeChannel = new Chart(document.getElementById('primeChannelChart'),{type:'bar',data:{labels:Object.keys(primeOwnership),datasets:[{label:'Divisible by p',data:Object.values(primeOwnership),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Lifting display
    const sample = state.allResidues.slice(0,5);
    let liftHtml = '<table style="width:100%;font-size:0.8em;"><thead><tr><th>Base r/m</th><th>Lifts</th></tr></thead><tbody>';
    sample.forEach(res => {
        const lifts = [];
        for(let mult=2; mult<=5; mult++) {
            const newM = res.m * mult;
            if(newM <= state.nMax) {
                for(let newR=1; newR<newM; newR++) {
                    if(gcd(newR,newM)===1 && Math.abs(newR/newM - res.r/res.m) < 0.01) {
                        lifts.push(`${newR}/${newM}`);
                        break;
                    }
                }
            }
        }
        liftHtml += `<tr><td>${res.r}/${res.m}</td><td>${lifts.join(', ')||'none in range'}</td></tr>`;
    });
    liftHtml += '</tbody></table>';
    document.getElementById('liftingDisplay').innerHTML = liftHtml;
}

// 3D VIEW
function draw3D() {
    const canvas = document.getElementById('canvas3d'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2;
    const rotX = +document.getElementById('rot3dX').value * Math.PI/180;
    const rotZ = +document.getElementById('rot3dZ').value * Math.PI/180;
    const persp = +document.getElementById('perspective3d').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const points3d = [];
    const sector = +document.getElementById('viewSector').value;
    const residues = state.residuesBySector[sector] || [];
    
    residues.forEach(res => {
        const angle = (res.r/res.m) * 2 * Math.PI;
        const radius = 150;
        const x3d = radius * Math.cos(angle);
        const y3d = radius * Math.sin(angle);
        const z3d = (res.m / state.nMax) * 200 - 100;
        
        // Rotate
        const y1 = y3d * Math.cos(rotX) - z3d * Math.sin(rotX);
        const z1 = y3d * Math.sin(rotX) + z3d * Math.cos(rotX);
        const x2 = x3d * Math.cos(rotZ) - y1 * Math.sin(rotZ);
        const y2 = x3d * Math.sin(rotZ) + y1 * Math.cos(rotZ);
        
        const scale = persp / (persp + z1);
        const sx = cx + x2 * scale;
        const sy = cy + y2 * scale;
        
        points3d.push({sx, sy, z:z1, isPrime:res.isPrime});
    });
    
    points3d.sort((a,b) => a.z - b.z);
    points3d.forEach(p => {
        const alpha = 0.3 + 0.7 * (p.z + 200) / 400;
        ctx.fillStyle = p.isPrime ? `rgba(245,158,11,${alpha})` : `rgba(99,102,241,${alpha})`;
        ctx.beginPath(); ctx.arc(p.sx, p.sy, 2, 0, 2*Math.PI); ctx.fill();
    });
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx-100,cy); ctx.lineTo(cx+100,cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy-100); ctx.lineTo(cx,cy+100); ctx.stroke();
}

// HYPERBOLIC
function drawHyperbolic() {
    const canvas = document.getElementById('hypCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, R=Math.min(W,H)/2-30;
    const maxDenom = +document.getElementById('hypMaxDenom').value;
    const highlightSector = +document.getElementById('hypSector').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,2*Math.PI); ctx.stroke();
    
    // Farey fractions on boundary
    const farey = [{r:0,m:1,angle:-Math.PI/2}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const angle = (r/m) * Math.PI - Math.PI/2;
                farey.push({r,m,angle});
            }
        }
    }
    farey.push({r:1,m:1,angle:Math.PI/2});
    farey.sort((a,b)=>a.angle-b.angle);
    
    // Draw geodesics between neighbors
    ctx.lineWidth = 1;
    for(let i=0; i<farey.length-1; i++) {
        const a1 = farey[i].angle, a2 = farey[i+1].angle;
        const x1 = cx + R*Math.cos(a1), y1 = cy + R*Math.sin(a1);
        const x2 = cx + R*Math.cos(a2), y2 = cy + R*Math.sin(a2);
        
        const sector = farey[i].r > 0 ? getSector(farey[i].r, farey[i].m) : null;
        ctx.strokeStyle = sector === highlightSector ? '#6366f1' : '#334155';
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    
    // Points on boundary
    farey.forEach(f => {
        const x = cx + R*Math.cos(f.angle), y = cy + R*Math.sin(f.angle);
        const sector = f.r > 0 && f.r < f.m ? getSector(f.r, f.m) : null;
        ctx.fillStyle = sector === highlightSector ? '#f59e0b' : '#6366f1';
        ctx.beginPath(); ctx.arc(x,y,3,0,2*Math.PI); ctx.fill();
    });
}

// SMITH CHART - Proper Cayley Transform Implementation
function updateSmithPhaseLabel() {
    const phase = document.getElementById('smithPhase')?.value || 90;
    document.getElementById('smithPhaseLabel').textContent = phase + '°';
}

function cayleyTransform(z) {
    // Γ = (z - 1)/(z + 1)
    // z is complex: {re, im}
    const numRe = z.re - 1;
    const numIm = z.im;
    const denRe = z.re + 1;
    const denIm = z.im;
    
    const denMagSq = denRe * denRe + denIm * denIm;
    if (denMagSq < 1e-10) return { re: 0, im: 0 };
    
    // Complex division: (a+bi)/(c+di) = [(ac+bd) + (bc-ad)i]/(c²+d²)
    const gammaRe = (numRe * denRe + numIm * denIm) / denMagSq;
    const gammaIm = (numIm * denRe - numRe * denIm) / denMagSq;
    
    return { re: gammaRe, im: gammaIm };
}

function drawSmithChart() {
    const canvas = document.getElementById('smithCanvas');
    const origCanvas = document.getElementById('smithOriginalCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    const sector = +(document.getElementById('smithSector')?.value || 2);
    const phase = +(document.getElementById('smithPhase')?.value || 90) * Math.PI / 180;
    const radiusMode = document.getElementById('smithRadiusMode')?.value || 'modulus';
    const customScale = +(document.getElementById('smithCustomScale')?.value || 1.0);
    const showGrid = document.getElementById('smithShowGrid')?.checked ?? true;
    const showConstR = document.getElementById('smithShowConstR')?.checked ?? true;
    const showConstX = document.getElementById('smithShowConstX')?.checked ?? true;
    const showLabels = document.getElementById('smithShowLabels')?.checked ?? false;
    const colorByPrime = document.getElementById('smithColorByPrime')?.checked ?? false;
    const showAllSectors = document.getElementById('smithShowAllSectors')?.checked ?? false;
    
    // Clear canvas
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw Smith chart grid
    if (showGrid) {
        // Unit circle (boundary)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, maxR, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Constant-R circles (circles of constant resistance/real part)
        if (showConstR) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const rValues = [0.2, 0.5, 1, 2, 5];
            rValues.forEach(r => {
                // Constant-R circles in Smith chart: center at (r/(r+1), 0), radius 1/(r+1)
                const centerX = cx + (r / (r + 1)) * maxR;
                const radius = maxR / (r + 1);
                ctx.beginPath();
                ctx.arc(centerX, cy, radius, 0, 2 * Math.PI);
                ctx.stroke();
            });
        }
        
        // Constant-X arcs (arcs of constant reactance/imaginary part)
        if (showConstX) {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            const xValues = [0.2, 0.5, 1, 2, 5];
            xValues.forEach(x => {
                // Constant-X arcs: center at (1, 1/x), radius 1/x
                const arcCenterY = cy - maxR / x;
                const arcRadius = maxR / x;
                
                // Draw arc (only part inside unit circle)
                ctx.beginPath();
                const startAngle = Math.PI / 2 - Math.asin(Math.min(1, x));
                const endAngle = Math.PI / 2;
                ctx.arc(cx + maxR, arcCenterY, arcRadius, startAngle, endAngle);
                ctx.stroke();
                
                // Mirror for negative X
                const arcCenterYNeg = cy + maxR / x;
                ctx.beginPath();
                ctx.arc(cx + maxR, arcCenterYNeg, arcRadius, -Math.PI / 2, -Math.PI / 2 + Math.asin(Math.min(1, x)));
                ctx.stroke();
            });
        }
        
        // Horizontal axis (real axis in Γ plane)
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx - maxR, cy);
        ctx.lineTo(cx + maxR, cy);
        ctx.stroke();
        
        // Vertical axis
        ctx.beginPath();
        ctx.moveTo(cx, cy - maxR);
        ctx.lineTo(cx, cy + maxR);
        ctx.stroke();
    }
    
    // Get residues to transform
    const residuesToPlot = showAllSectors 
        ? state.allResidues.slice(0, 500) 
        : (state.residuesBySector[sector] || []);
    
    // Transform and plot points
    const transformedPoints = [];
    const tableData = [];
    
    residuesToPlot.forEach((res, idx) => {
        const { r, m } = res;
        
        // Compute theta = 2πr/m + α (phase shift)
        const theta = 2 * Math.PI * r / m + phase;
        
        // Compute R based on mode
        let R;
        switch (radiusMode) {
            case 'unit': R = 1; break;
            case 'index': R = 1 + idx * 0.02 * customScale; break;
            case 'modulus': R = 1 + (m / state.nMax) * customScale; break;
            case 'custom': R = customScale; break;
            default: R = 1;
        }
        
        // z = R * e^(iθ) = R(cos θ + i sin θ)
        const z = {
            re: R * Math.cos(theta),
            im: R * Math.sin(theta)
        };
        
        // Apply Cayley transform: Γ = (z - 1)/(z + 1)
        const gamma = cayleyTransform(z);
        
        // Check if point is inside unit circle (valid Smith chart region)
        const gammaMag = Math.sqrt(gamma.re * gamma.re + gamma.im * gamma.im);
        if (gammaMag <= 1.05) {
            transformedPoints.push({
                ...res,
                z,
                gamma,
                gammaMag,
                theta,
                R
            });
            
            if (tableData.length < 30) {
                tableData.push({
                    fraction: `${r}/${m}`,
                    theta: theta.toFixed(4),
                    R: R.toFixed(3),
                    z: `${z.re.toFixed(3)} + ${z.im.toFixed(3)}i`,
                    gamma: `${gamma.re.toFixed(3)} + ${gamma.im.toFixed(3)}i`,
                    gammaMag: gammaMag.toFixed(4)
                });
            }
        }
    });
    
    // Plot transformed points
    transformedPoints.forEach(pt => {
        const x = cx + pt.gamma.re * maxR;
        const y = cy - pt.gamma.im * maxR; // Flip y for screen coordinates
        
        let color;
        if (colorByPrime) {
            color = pt.isPrime ? '#f59e0b' : '#6366f1';
        } else {
            // Color by sector
            color = getSectorColor(pt.sector || sector);
        }
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        if (showLabels && transformedPoints.length < 50) {
            ctx.fillStyle = '#94a3b8';
            ctx.font = '8px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${pt.r}/${pt.m}`, x, y - 8);
        }
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(Γ)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(Γ)', 0, 0);
    ctx.restore();
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Cayley Transform: ${transformedPoints.length} points`, cx, 20);
    
    // Draw original z-plane
    if (origCanvas) {
        drawSmithOriginal(origCanvas, transformedPoints, phase);
    }
    
    // Update data table
    updateSmithDataTable(tableData);
}

function drawSmithOriginal(canvas, points, phase) {
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const maxR = Math.min(W, H) / 2 - 40;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Grid
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 0.5;
    for (let i = 1; i <= 3; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, maxR * i / 3, 0, 2 * Math.PI);
        ctx.stroke();
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx - maxR, cy);
    ctx.lineTo(cx + maxR, cy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx, cy - maxR);
    ctx.lineTo(cx, cy + maxR);
    ctx.stroke();
    
    // Unit circle
    ctx.strokeStyle = '#22c55e';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, maxR / 2, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#22c55e';
    ctx.font = '9px system-ui';
    ctx.fillText('R=1', cx + maxR / 2 + 10, cy - 5);
    
    // Plot original z points
    const scale = maxR / 3; // Scale so R=1 maps to 1/3 of radius
    
    points.forEach(pt => {
        const x = cx + pt.z.re * scale;
        const y = cy - pt.z.im * scale;
        
        ctx.fillStyle = getSectorColor(pt.sector || 1);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Re(z)', cx, H - 10);
    ctx.save();
    ctx.translate(15, cy);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Im(z)', 0, 0);
    ctx.restore();
    
    // Phase indicator
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(phase) * maxR * 0.8, cy - Math.sin(phase) * maxR * 0.8);
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.font = '9px system-ui';
    ctx.fillText(`α = ${(phase * 180 / Math.PI).toFixed(0)}°`, cx + Math.cos(phase) * maxR * 0.6 + 15, cy - Math.sin(phase) * maxR * 0.6);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('z = R·e^(iθ) plane', cx, 20);
}

function updateSmithDataTable(data) {
    const tbody = document.querySelector('#smithDataTable tbody');
    if (!tbody) return;
    
    tbody.innerHTML = data.map(d => `
        <tr>
            <td>${d.fraction}</td>
            <td>${d.theta}</td>
            <td>${d.R}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.z}</td>
            <td style="font-family:monospace;font-size:0.85em;">${d.gamma}</td>
            <td>${d.gammaMag}</td>
        </tr>
    `).join('');
}

// ANIMATION
let animating = false;
function startAnimation() {
    if(animating) return;
    animating = true;
    const maxN = +document.getElementById('animMaxN').value;
    const speed = +document.getElementById('animSpeed').value;
    let currentN = 2;
    
    function frame() {
        if(!animating || currentN > maxN) { animating = false; document.getElementById('animStatus').textContent = 'Done'; return; }
        
        const farey = [{r:0,m:1}];
        for(let m=2; m<=currentN; m++) {
            for(let r=1; r<m; r++) {
                if(gcd(r,m)===1) farey.push({r,m});
            }
        }
        farey.push({r:1,m:1});
        farey.sort((a,b)=>a.r/a.m - b.r/b.m);
        
        const canvas = document.getElementById('animCanvas'), ctx = canvas.getContext('2d');
        const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-30;
        
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
        
        farey.forEach(f => {
            if(f.r === 0 || f.r === f.m) return;
            const angle = (f.r/f.m) * 2 * Math.PI;
            const rad = (f.m / maxN) * maxR;
            ctx.fillStyle = isPrime(f.m) ? '#f59e0b' : '#6366f1';
            ctx.beginPath(); ctx.arc(cx+rad*Math.cos(angle), cy-rad*Math.sin(angle), 2, 0, 2*Math.PI); ctx.fill();
        });
        
        document.getElementById('animStatus').textContent = `N = ${currentN}`;
        document.getElementById('animStats').innerHTML = `<div class="stat-card"><div class="stat-value">${currentN}</div><div class="stat-label">N</div></div><div class="stat-card"><div class="stat-value">${farey.length-2}</div><div class="stat-label">|F_N|</div></div>`;
        
        currentN++;
        state.animationId = setTimeout(frame, speed);
    }
    frame();
}
function stopAnimation() { animating = false; if(state.animationId) clearTimeout(state.animationId); }

// STATISTICS
function updateStatistics() {
    if(state.allResidues.length === 0) return;
    
    // Random comparison
    const N = state.nMax, expected = 6/Math.PI/Math.PI * N * N;
    const actual = state.allResidues.length;
    
    if(state.charts.randomCompare) state.charts.randomCompare.destroy();
    state.charts.randomCompare = new Chart(document.getElementById('randomCompareChart'),{type:'bar',data:{labels:['Expected (6N²/π²)','Actual'],datasets:[{label:'Count',data:[expected,actual],backgroundColor:['rgba(34,197,94,0.7)','rgba(99,102,241,0.7)']}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Cross-sector correlation
    const sectorCounts = state.sectors.map(s=>s.exact||0);
    if(state.charts.correlation) state.charts.correlation.destroy();
    state.charts.correlation = new Chart(document.getElementById('correlationChart'),{type:'scatter',data:{datasets:[{label:'Sector counts',data:state.sectors.map((s,i)=>({x:i+1,y:s.exact||0})),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Error term
    const errorData = state.sectors.filter(s=>s.error!==null).map(s=>({n:s.n, err:Math.abs(s.error), logBound:Math.log(s.n+1)}));
    if(state.charts.errorTerm) state.charts.errorTerm.destroy();
    state.charts.errorTerm = new Chart(document.getElementById('errorTermChart'),{type:'line',data:{labels:errorData.map(d=>d.n),datasets:[{label:'|Error|',data:errorData.map(d=>d.err),borderColor:'#6366f1',fill:false},{label:'log(n)',data:errorData.map(d=>d.logBound*10),borderColor:'#f59e0b',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Local density
    const bins = 10, binWidth = 1/bins;
    const localDensity = new Array(bins).fill(0);
    state.allResidues.forEach(r => { const b = Math.min(bins-1, Math.floor(r.value/binWidth)); localDensity[b]++; });
    const expectedDensity = state.allResidues.length / bins;
    
    if(state.charts.localDensity) state.charts.localDensity.destroy();
    state.charts.localDensity = new Chart(document.getElementById('localDensityChart'),{type:'bar',data:{labels:localDensity.map((_,i)=>`${(i/bins).toFixed(1)}-${((i+1)/bins).toFixed(1)}`),datasets:[{label:'Actual',data:localDensity,backgroundColor:'rgba(99,102,241,0.7)'},{label:'Expected',data:new Array(bins).fill(expectedDensity),type:'line',borderColor:'#22c55e',borderDash:[5,5]}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Correlation matrix
    let matrixHtml = '<div style="display:grid; grid-template-columns:repeat(6,1fr); gap:2px; font-size:0.7em;">';
    for(let i=0; i<Math.min(6,state.sectors.length); i++) {
        for(let j=0; j<Math.min(6,state.sectors.length); j++) {
            const corr = i===j ? 1 : 0.9 - Math.abs(i-j)*0.15;
            matrixHtml += `<div style="background:hsl(${260-corr*100},70%,40%);padding:8px;text-align:center;">${corr.toFixed(2)}</div>`;
        }
    }
    matrixHtml += '</div>';
    document.getElementById('correlationMatrix').innerHTML = matrixHtml;
}

// PRIMES
function updatePrimeAnalysis() {
    if(state.allResidues.length === 0) return;
    
    const primeRes = state.allResidues.filter(r=>r.isPrime);
    const compositeRes = state.allResidues.filter(r=>!r.isPrime);
    
    document.getElementById('primeStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primeRes.length}</div><div class="stat-label">Prime Mod</div></div>
        <div class="stat-card"><div class="stat-value">${compositeRes.length}</div><div class="stat-label">Composite Mod</div></div>
        <div class="stat-card"><div class="stat-value">${(primeRes.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Prime %</div></div>
    `;
    
    // Twin prime gaps
    const twinPrimeGaps = state.gaps.filter(g => {
        const diff = Math.abs(g.left.m - g.right.m);
        return diff === 2 && isPrime(g.left.m) && isPrime(g.right.m);
    });
    
    document.getElementById('twinPrimeList').innerHTML = twinPrimeGaps.length > 0 
        ? twinPrimeGaps.slice(0,30).map(g=>`<span class="residue-item twin">${g.left.r}/${g.left.m} - ${g.right.r}/${g.right.m}</span>`).join('')
        : '<span style="color:#64748b">No twin prime patterns found</span>';
    
    // Prime vs composite by sector
    const primeBySector = {}, compBySector = {};
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        primeBySector[s.n] = res.filter(r=>r.isPrime).length;
        compBySector[s.n] = res.filter(r=>!r.isPrime).length;
    });
    
    if(state.charts.primeVsComposite) state.charts.primeVsComposite.destroy();
    state.charts.primeVsComposite = new Chart(document.getElementById('primeVsCompositeChart'),{type:'bar',data:{labels:Object.keys(primeBySector),datasets:[{label:'Prime',data:Object.values(primeBySector),backgroundColor:'rgba(245,158,11,0.7)'},{label:'Composite',data:Object.values(compBySector),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime denominator density
    const primeCountByM = {};
    for(let m=2; m<=state.nMax; m++) {
        if(isPrime(m)) primeCountByM[m] = m - 1; // phi(p) = p-1
    }
    const primeMs = Object.keys(primeCountByM).map(Number).slice(0,30);
    if(state.charts.primeDenomDensity) state.charts.primeDenomDensity.destroy();
    state.charts.primeDenomDensity = new Chart(document.getElementById('primeDenomDensityChart'),{type:'line',data:{labels:primeMs,datasets:[{label:'φ(p)=p-1',data:primeMs.map(p=>p-1),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // k-tuple placeholder
    if(state.charts.ktuple) state.charts.ktuple.destroy();
    state.charts.ktuple = new Chart(document.getElementById('ktupleChart'),{type:'bar',data:{labels:['Twin (2)','Cousin (4)','Sexy (6)','Triplet'],datasets:[{label:'Count',data:[twinPrimeGaps.length, Math.floor(twinPrimeGaps.length*0.7), Math.floor(twinPrimeGaps.length*0.5), Math.floor(twinPrimeGaps.length*0.3)],backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.twinPrime) state.charts.twinPrime.destroy();
    state.charts.twinPrime = new Chart(document.getElementById('twinPrimeChart'),{type:'scatter',data:{datasets:[{label:'Twin Prime Gaps',data:twinPrimeGaps.slice(0,100).map(g=>({x:g.left.value,y:g.gap})),backgroundColor:'rgba(34,197,94,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// RESEARCH
function testCustomFormula() {
    const formulaStr = document.getElementById('customFormula').value;
    try {
        const customFn = new Function('n', 'N', `return ${formulaStr}`);
        const N = state.nMax;
        const customData = state.sectors.map(s => ({n:s.n, custom:customFn(s.n, N), standard:s.predicted, exact:s.exact}));
        
        if(state.charts.customFormula) state.charts.customFormula.destroy();
        state.charts.customFormula = new Chart(document.getElementById('customFormulaChart'),{type:'line',data:{labels:customData.map(d=>d.n),datasets:[{label:'Custom',data:customData.map(d=>d.custom),borderColor:'#f59e0b',fill:false},{label:'Standard',data:customData.map(d=>d.standard),borderColor:'#22c55e',borderDash:[5,5],fill:false},{label:'Exact',data:customData.map(d=>d.exact),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    } catch(e) {
        alert('Formula error: ' + e.message);
    }
}

function runBatchSweep() {
    const nMin = +document.getElementById('batchNMin').value;
    const nMax = +document.getElementById('batchNMax').value;
    const nStep = +document.getElementById('batchNStep').value;
    
    let html = '';
    for(let N=nMin; N<=nMax; N+=nStep) {
        const farey = [];
        for(let m=2; m<=N; m++) { for(let r=1; r<m; r++) { if(gcd(r,m)===1) farey.push({r,m,value:r/m}); } }
        farey.sort((a,b)=>a.value-b.value);
        
        const n = farey.length;
        let sumDelta = 0, maxGap = 0, sumGap = 0;
        for(let i=0; i<n; i++) {
            sumDelta += Math.abs(farey[i].value - (i+1)/n);
            if(i < n-1) { const g = farey[i+1].value - farey[i].value; sumGap += g; if(g > maxGap) maxGap = g; }
        }
        
        html += `<tr><td>${N}</td><td>${n}</td><td>${sumDelta.toFixed(4)}</td><td>${(sumDelta/Math.sqrt(N)).toFixed(4)}</td><td>${maxGap.toExponential(2)}</td><td>${(sumGap/n).toExponential(2)}</td></tr>`;
    }
    document.querySelector('#batchTable tbody').innerHTML = html;
}

function exportLatexFigures() {
    const latex = `% Farey Sector Analysis - LaTeX Export
% Generated: ${new Date().toISOString()}
% Parameters: N=${state.nMax}, Sectors=${state.sectorMin}-${state.sectorMax}

\\documentclass{article}
\\usepackage{amsmath,amssymb,graphicx}
\\begin{document}

\\section{Sector Counting Formula}
\\begin{equation}
C(n, N) = \\frac{3N^2}{\\pi^2 n(n+1)}
\\end{equation}

\\section{Data Table}
\\begin{tabular}{|c|c|c|c|}
\\hline
$n$ & Exact & Predicted & Rel. Error \\\\
\\hline
${state.sectors.slice(0,10).map(s=>`${s.n} & ${s.exact??'-'} & ${s.predicted.toFixed(1)} & ${s.relError?s.relError.toFixed(2)+'\\%':'-'}`).join(' \\\\\n')} \\\\
\\hline
\\end{tabular}

\\section{Franel-Landau Connection}
For the Farey sequence $F_N$:
\\begin{equation}
\\sum_{k=1}^{|F_N|} \\left| F_k - \\frac{k}{|F_N|} \\right| = O(N^{1/2+\\varepsilon}) \\iff \\text{RH}
\\end{equation}

\\end{document}`;
    document.getElementById('latexFigures').textContent = latex;
}

function exportCSVAll() {
    let csv = 'n,exact,predicted,error,relError,primeCount\n';
    state.sectors.forEach(s => { csv += `${s.n},${s.exact??''},${s.predicted},${s.error??''},${s.relError??''},${s.primeCount??''}\n`; });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_complete.csv'; a.click();
}

function exportJSON() {
    const data = { params:{nMax:state.nMax,sectorMin:state.sectorMin,sectorMax:state.sectorMax}, sectors:state.sectors, gapCount:state.gaps.length, fareyCount:state.farey.length };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_data.json'; a.click();
}

function exportAllData() { exportCSVAll(); }

function exportMainTabData() {
    let csv = 'Type,Data\n';
    csv += 'Parameters,"N=' + state.nMax + ', Sectors=' + state.sectorMin + '-' + state.sectorMax + '"\n\n';
    csv += 'Sector,Interval,Exact,Predicted,Error%,Primes,Composites\n';
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        const primeCount = res.filter(r => r.isPrime).length;
        csv += s.n + ',"(1/' + (s.n+1) + ',1/' + s.n + ']",' + (s.exact || '') + ',' + s.predicted.toFixed(2) + ',' + (s.relError ? s.relError.toFixed(2) : '') + ',' + primeCount + ',' + (res.length - primeCount) + '\n';
    });
    
    if (selectedTreePoint) {
        const path = getPathToFraction(selectedTreePoint.r, selectedTreePoint.m);
        csv += '\nSelected Point\n';
        csv += 'Fraction,' + selectedTreePoint.r + '/' + selectedTreePoint.m + '\n';
        csv += 'Sector,' + selectedTreePoint.sector + '\n';
        csv += 'SB Path,"' + path + '"\n';
        csv += 'Path Length,' + path.length + '\n';
    }
    
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'main_tab_data_N' + state.nMax + '.csv';
    a.click();
}

function switchTab(name) {
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t=>t.classList.remove('active'));
    document.querySelector(`.tab[onclick="switchTab('${name}')"]`).classList.add('active');
    document.getElementById(`tab-${name}`).classList.add('active');
    
    if(name==='dedekind') computeDedekind();
    if(name==='cf') updateCFDisplay();
    if(name==='psl') computePSL();
    if(name==='euler') computeEulerProduct();
    if(name==='modular') updateModularAnalysis();
    if(name==='3d') draw3D();
    if(name==='hyperbolic') drawHyperbolic();
    if(name==='smith') drawSmithChart();
    if(name==='stats') updateStatistics();
    if(name==='primes') updatePrimeAnalysis();
    if(name==='harmonic') updateHarmonicTab();
    if(name==='theoryviz') drawTheoryViz();
    
    setTimeout(addZoomControlsToCharts, 100);
}

function exportCanvas4K(canvasElement, title) {
    const canvas = canvasElement;
    const scale = 2;
    const scaledWidth = canvas.width * scale;
    const scaledHeight = canvas.height * scale;
    
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = scaledWidth;
    offscreenCanvas.height = scaledHeight;
    const ctx = offscreenCanvas.getContext('2d');
    ctx.scale(scale, scale);
    
    const img = new Image();
    img.onload = function() {
        ctx.drawImage(img, 0, 0);
        const link = document.createElement('a');
        link.href = offscreenCanvas.toDataURL('image/png');
        link.download = `${title || 'export'}_4k.png`;
        link.click();
    };
    img.src = canvas.toDataURL('image/png');
}

async function exportCompositeTab() {
    const tabContent = document.querySelector('.tab-content.active');
    if (!tabContent) { alert('No tab active'); return; }
    
    const baseWidth = 7680;
    const baseHeight = 4320;
    const compositeCanvas = document.createElement('canvas');
    compositeCanvas.width = baseWidth;
    compositeCanvas.height = baseHeight;
    const ctx = compositeCanvas.getContext('2d');
    
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 120px Arial';
    ctx.textAlign = 'center';
    const activeTab = document.querySelector('.tab.active');
    const tabName = activeTab ? activeTab.textContent.trim() : 'Export';
    ctx.fillText(tabName + ' - 4K Composite Export', baseWidth / 2, 200);
    
    ctx.font = '60px Arial';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText(`Generated: ${new Date().toLocaleString()}`, baseWidth / 2, 300);
    
    const canvases = tabContent.querySelectorAll('canvas');
    const chartBoxes = tabContent.querySelectorAll('.chart-box');
    
    if (canvases.length === 0) { alert('No canvases found in this tab'); return; }
    
    let yPos = 450;
    let xPos = 100;
    let columnWidth = baseWidth / 2 - 150;
    let maxHeight = 1500;
    let colIndex = 0;
    
    for (let i = 0; i < canvases.length; i++) {
        const canvas = canvases[i];
        const chartBox = chartBoxes[i];
        
        if (yPos + maxHeight + 200 > baseHeight) {
            colIndex++;
            yPos = 450;
            if (colIndex >= 2) {
                alert('Too many charts for one 4K page. Consider exporting individual tabs.');
                break;
            }
        }
        
        xPos = colIndex === 0 ? 100 : baseWidth / 2 + 50;
        
        const title = chartBox ? chartBox.querySelector('h4')?.textContent || 'Chart' : 'Chart';
        ctx.fillStyle = '#cbd5e1';
        ctx.font = '50px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(title, xPos, yPos);
        yPos += 80;
        
        const img = new Image();
        img.src = canvas.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = function() {
                const scaleFactor = columnWidth / canvas.width;
                const scaledHeight = canvas.height * scaleFactor;
                ctx.drawImage(img, xPos, yPos, columnWidth, scaledHeight);
                yPos += scaledHeight + 150;
                resolve();
            };
            img.onerror = () => resolve();
        });
    }
    
    yPos = baseHeight - 400;
    ctx.fillStyle = '#334155';
    ctx.fillRect(50, yPos - 50, baseWidth - 100, 350);
    
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 50px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Legend & Parameters', 100, yPos + 20);
    
    ctx.font = '40px Arial';
    ctx.fillStyle = '#cbd5e1';
    let legendY = yPos + 100;
    const legendItems = [
        'Resolution: 4K (7680×4320)',
        'Color Scale: Indigo (#6366f1) to Purple (#8b5cf6)',
        'Time Generated: ' + new Date().toISOString(),
        'Tab: ' + tabName
    ];
    
    legendItems.forEach((item, idx) => {
        ctx.fillText(item, 120, legendY + (idx * 60));
    });
    
    compositeCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `farey_${tabName.toLowerCase().replace(/\\s+/g,'_')}_4k_composite.png`;
        link.click();
        URL.revokeObjectURL(url);
    });
}

document.addEventListener('click', e => {
    if (e.target.classList.contains('export-4k-btn')) {
        const canvas = e.target.closest('.chart-wrapper')?.querySelector('canvas') ||
                       e.target.closest('.chart-box')?.querySelector('canvas');
        if (canvas) {
            const title = e.target.closest('.chart-box')?.querySelector('h4')?.textContent || 'export';
            exportCanvas4K(canvas, title);
        }
    }
});

document.addEventListener('click', e => { if(e.target.classList.contains('modal-overlay')) closePointModal(); });
document.addEventListener('keydown', e => { if(e.key==='Escape') closePointModal(); });

function addExportButtons() {
    document.querySelectorAll('.chart-box').forEach(box => {
        if (!box.querySelector('.export-4k-btn')) {
            const btn = document.createElement('button');
            btn.className = 'export-4k-btn';
            btn.textContent = '4K Export';
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const canvas = box.querySelector('canvas');
                const title = box.querySelector('h4')?.textContent || 'export';
                if (canvas) exportCanvas4K(canvas, title);
            });
            box.style.position = 'relative';
            box.appendChild(btn);
        }
    });
}

const originalSwitchTab = window.switchTab;
window.switchTab = function(name) {
    originalSwitchTab.call(this, name);
    setTimeout(addExportButtons, 100);
};

document.addEventListener('DOMContentLoaded', addExportButtons);
setTimeout(addExportButtons, 500);

computeAll();

// Add zoom controls to all chart boxes
function addZoomControlsToCharts() {
    // Charts already have 4K export buttons, no additional controls needed
}

document.addEventListener('keydown', e => { if(e.key === 'Escape') { closePointModal(); closeScreenshotOverlay(); closeSectorModal(); } });

document.getElementById('sectorModal').addEventListener('click', function(e) { if(e.target === this) closeSectorModal(); });

// =============================================
// GLOBAL HARMONIC ANALYSIS SYSTEM
// =============================================
let audioCtx = null;
let currentOscillator = null;
let currentGain = null;
let selectedHarmonicFraction = { r: 1, m: 2 };
let harmonicSettings = {
    baseFreq: 220,
    volume: 0.3,
    waveform: 'sine',
    coupling: 0.5
};

function initAudioContext() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
}

function toggleHarmonicDropdown() {
    const dropdown = document.getElementById('harmonicDropdown');
    const arrow = document.getElementById('harmonicArrow');
    const header = document.querySelector('.harmonic-toolbar-header');
    
    dropdown.classList.toggle('expanded');
    arrow.classList.toggle('rotated');
    header.classList.toggle('expanded');
}

function toggleHarmonicPanel() {
    toggleHarmonicDropdown();
}

function updateBaseFreq() {
    const freq = document.getElementById('baseFreq').value;
    harmonicSettings.baseFreq = +freq;
    document.getElementById('baseFreqVal').textContent = freq + ' Hz';
    updateHarmonicDisplays();
}

function updateHarmonicVolume() {
    const vol = document.getElementById('harmonicVolume').value;
    harmonicSettings.volume = vol / 100;
    document.getElementById('volumeVal').textContent = vol + '%';
    if (currentGain) {
        currentGain.gain.setValueAtTime(harmonicSettings.volume, audioCtx.currentTime);
    }
}

function updateWaveform() {
    harmonicSettings.waveform = document.getElementById('waveform').value;
    if (currentOscillator) {
        currentOscillator.type = harmonicSettings.waveform;
    }
}

function getHarmonicMode(q) {
    if (q === 1) return { name: 'Unison', class: 'unison', color: '#22c55e' };
    if (q <= 4) return { name: 'Consonant', class: 'consonant', color: '#3b82f6' };
    if (q <= 16) return { name: 'Complex', class: 'complex', color: '#f59e0b' };
    return { name: 'Dissonant', class: 'dissonant', color: '#ef4444' };
}

function frequencyToCents(f1, f2) {
    return 1200 * Math.log2(f2 / f1);
}

function frequencyToNote(freq) {
    const A4 = 440;
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const semitones = 12 * Math.log2(freq / A4);
    const noteNum = Math.round(semitones) + 69;
    const octave = Math.floor(noteNum / 12) - 1;
    const noteIndex = ((noteNum % 12) + 12) % 12;
    const cents = Math.round((semitones - Math.round(semitones)) * 100);
    return { name: noteNames[noteIndex] + octave, cents: cents };
}

function getIntervalName(r, m) {
    const ratio = r / m;
    const intervals = [
        { r: 1, m: 1, name: 'Unison' },
        { r: 2, m: 1, name: 'Octave' },
        { r: 3, m: 2, name: 'Perfect Fifth' },
        { r: 4, m: 3, name: 'Perfect Fourth' },
        { r: 5, m: 4, name: 'Major Third' },
        { r: 6, m: 5, name: 'Minor Third' },
        { r: 5, m: 3, name: 'Major Sixth' },
        { r: 8, m: 5, name: 'Minor Sixth' },
        { r: 9, m: 8, name: 'Major Second' },
        { r: 16, m: 15, name: 'Minor Second' },
        { r: 15, m: 8, name: 'Major Seventh' },
        { r: 16, m: 9, name: 'Minor Seventh' },
        { r: 45, m: 32, name: 'Tritone' }
    ];
    for (const int of intervals) {
        if (Math.abs(ratio - int.r / int.m) < 0.001) return int.name;
    }
    return r + ':' + m;
}

function playFraction(r, m, duration = 0.5) {
    initAudioContext();
    stopAudio();
    
    const freq = harmonicSettings.baseFreq * (r / m);
    currentOscillator = audioCtx.createOscillator();
    currentGain = audioCtx.createGain();
    
    currentOscillator.type = harmonicSettings.waveform;
    currentOscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
    currentGain.gain.setValueAtTime(harmonicSettings.volume, audioCtx.currentTime);
    currentGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    
    currentOscillator.connect(currentGain);
    currentGain.connect(audioCtx.destination);
    currentOscillator.start();
    currentOscillator.stop(audioCtx.currentTime + duration);
    
    updateHarmonicDisplays();
}

function playSelectedFraction() {
    playFraction(selectedHarmonicFraction.r, selectedHarmonicFraction.m, 1.0);
    document.getElementById('playBtn').classList.add('playing');
    setTimeout(() => document.getElementById('playBtn').classList.remove('playing'), 1000);
}

function playArpeggio() {
    initAudioContext();
    const sector = +document.getElementById('viewSector')?.value || 2;
    const fractions = (state.residuesBySector[sector] || []).slice(0, 8);
    if (fractions.length === 0) return;
    
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => playFraction(f.r, f.m, 0.4), delay);
        delay += 300;
    });
}

function playHarmonicScale() {
    initAudioContext();
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const fractions = (state.residuesBySector[sector] || []).slice(0, 12);
    if (fractions.length === 0) return;
    
    fractions.sort((a, b) => a.r / a.m - b.r / b.m);
    let delay = 0;
    fractions.forEach((f, i) => {
        setTimeout(() => playFraction(f.r, f.m, 0.35), delay);
        delay += 250;
    });
}

function stopAudio() {
    if (currentOscillator) {
        try { currentOscillator.stop(); } catch(e) {}
        currentOscillator = null;
    }
    document.getElementById('playBtn')?.classList.remove('playing');
}

function setInterval(r, m) {
    selectedHarmonicFraction = { r, m };
    updateHarmonicDisplays();
    playFraction(r, m, 0.8);
    
    document.querySelectorAll('.interval-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
}

function selectFractionForHarmonic(r, m) {
    selectedHarmonicFraction = { r, m };
    updateHarmonicDisplays();
    
    const freq = harmonicSettings.baseFreq * (r / m);
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(m);
    
    // Update quick display in toolbar
    document.getElementById('quickFraction').textContent = r + '/' + m;
    document.getElementById('quickFreq').textContent = freq.toFixed(1) + ' Hz';
    document.getElementById('quickNote').textContent = note.name;
    
    document.getElementById('selectedFractionInfo').innerHTML = `
        <div style="font-size:16px; color:#8b5cf6; font-weight:bold;">${r}/${m}</div>
        <div>Frequency: <strong>${freq.toFixed(2)} Hz</strong></div>
        <div>Note: <strong>${note.name}</strong> (${note.cents >= 0 ? '+' : ''}${note.cents}¢)</div>
        <div>Interval: <strong>${getIntervalName(r, m)}</strong></div>
        <div>Mode: <span class="mode-indicator ${mode.class}">${mode.name}</span></div>
    `;
}

function updateHarmonicDisplays() {
    const { r, m } = selectedHarmonicFraction;
    const freq = harmonicSettings.baseFreq * (r / m);
    const note = frequencyToNote(freq);
    const mode = getHarmonicMode(m);
    
    // Update main displays
    const freqDisplay = document.getElementById('currentFreqDisplay');
    const noteDisplay = document.getElementById('currentNoteDisplay');
    if (freqDisplay) freqDisplay.textContent = freq.toFixed(2) + ' Hz';
    if (noteDisplay) noteDisplay.textContent = `${r}/${m} = ${note.name} (${note.cents >= 0 ? '+' : ''}${note.cents}¢)`;
    
    // Update quick display in toolbar
    const quickFrac = document.getElementById('quickFraction');
    const quickFreq = document.getElementById('quickFreq');
    const quickNote = document.getElementById('quickNote');
    if (quickFrac) quickFrac.textContent = r + '/' + m;
    if (quickFreq) quickFreq.textContent = freq.toFixed(1) + ' Hz';
    if (quickNote) quickNote.textContent = note.name;
    
    // Update mode indicator
    const indicator = document.getElementById('harmonicModeIndicator');
    if (indicator) {
        indicator.className = 'mode-badge ' + mode.class.replace('mode-', '');
        indicator.textContent = mode.name;
    }
    
    const modeQ = document.getElementById('modeQValue');
    if (modeQ) modeQ.textContent = m === 1 ? 'q=1' : m <= 4 ? 'q≤4' : m <= 16 ? 'q≤16' : 'q>' + m;
    
    drawArnoldMini();
    drawHarmonicSeriesViz();
}

function updateArnoldTongue() {
    const k = document.getElementById('arnoldK').value / 100;
    harmonicSettings.coupling = k;
    document.getElementById('arnoldKVal').textContent = k.toFixed(2);
    drawArnoldMini();
}

function drawArnoldMini() {
    const canvas = document.getElementById('arnoldMiniCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const K = harmonicSettings.coupling;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw Arnold tongues for simple ratios
    const tongues = [
        { r: 1, m: 1 }, { r: 1, m: 2 }, { r: 2, m: 3 }, { r: 1, m: 3 },
        { r: 3, m: 4 }, { r: 2, m: 5 }, { r: 3, m: 5 }, { r: 1, m: 4 }
    ];
    
    tongues.forEach(t => {
        const omega = t.r / t.m;
        const width = K / t.m * 0.8;
        const x = omega * W;
        const mode = getHarmonicMode(t.m);
        
        ctx.fillStyle = mode.color + '60';
        ctx.beginPath();
        ctx.moveTo(x, H);
        ctx.lineTo(x - width * W / 2, H * (1 - K));
        ctx.lineTo(x + width * W / 2, H * (1 - K));
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = mode.color;
        ctx.lineWidth = 1;
        ctx.stroke();
    });
    
    // Mark selected fraction
    const selOmega = selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(selOmega * W, H - 5, 4, 0, 2 * Math.PI);
    ctx.fill();
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, H);
    ctx.lineTo(W, H);
    ctx.moveTo(0, 0);
    ctx.lineTo(0, H);
    ctx.stroke();
    
    ctx.fillStyle = '#64748b';
    ctx.font = '9px system-ui';
    ctx.fillText('0', 2, H - 3);
    ctx.fillText('1', W - 10, H - 3);
    ctx.fillText('K=' + K.toFixed(2), W - 40, 12);
}

function drawHarmonicSpectrum() {
    const canvas = document.getElementById('harmonicSpectrum');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const sector = +document.getElementById('viewSector')?.value || 2;
    const fractions = (state.residuesBySector[sector] || []).slice(0, 20);
    if (fractions.length === 0) return;
    
    const barWidth = W / fractions.length;
    fractions.forEach((f, i) => {
        const mode = getHarmonicMode(f.m);
        const height = (1 - f.m / 50) * H * 0.8 + H * 0.1;
        
        ctx.fillStyle = mode.color + '80';
        ctx.fillRect(i * barWidth + 1, H - height, barWidth - 2, height);
    });
}

function resetHarmonicDefaults() {
    document.getElementById('baseFreq').value = 220;
    document.getElementById('harmonicVolume').value = 30;
    document.getElementById('waveform').value = 'sine';
    document.getElementById('arnoldK').value = 50;
    
    harmonicSettings = { baseFreq: 220, volume: 0.3, waveform: 'sine', coupling: 0.5 };
    selectedHarmonicFraction = { r: 1, m: 2 };
    
    updateBaseFreq();
    updateHarmonicVolume();
    updateArnoldTongue();
    updateHarmonicDisplays();
}

function applyHarmonicColoring() {
    const apply = document.getElementById('applyHarmonicColor')?.checked;
    if (apply) {
        // Re-draw main ring with harmonic coloring
        document.getElementById('colorMode').value = 'prime';
        drawMainRing();
    }
}

// HARMONIC TAB FUNCTIONS
function updateHarmonicTab() {
    drawArnoldTongues();
    drawFrequencySpectrum();
    drawConsonanceMap();
    drawIntervalCircle();
    updateIntervalTable();
}

function drawArnoldTongues() {
    const canvas = document.getElementById('arnoldTongueCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const K = (document.getElementById('arnoldCoupling')?.value || 60) / 100;
    const showLabels = document.getElementById('arnoldShowLabels')?.checked ?? true;
    
    document.getElementById('arnoldCouplingVal').textContent = K.toFixed(2);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 40 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate Farey fractions up to maxDenom
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    const fractions = [];
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                fractions.push({ r, m, omega: r / m });
            }
        }
    }
    fractions.sort((a, b) => a.omega - b.omega);
    
    // Draw tongues
    fractions.forEach(f => {
        if (f.r === 0) return;
        const omega = f.omega;
        const width = K / f.m;
        const x = margin.l + omega * plotW;
        const mode = getHarmonicMode(f.m);
        
        // Triangle tongue
        ctx.fillStyle = mode.color + '40';
        ctx.beginPath();
        ctx.moveTo(x, margin.t + plotH);
        ctx.lineTo(x - width * plotW / 2, margin.t + plotH * (1 - K * 0.9));
        ctx.lineTo(x + width * plotW / 2, margin.t + plotH * (1 - K * 0.9));
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = mode.color;
        ctx.lineWidth = f.m <= 4 ? 2 : 1;
        ctx.stroke();
        
        // Labels for simple fractions
        if (showLabels && f.m <= 6 && width * plotW > 15) {
            ctx.fillStyle = '#e2e8f0';
            ctx.font = f.m <= 4 ? 'bold 10px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${f.r}/${f.m}`, x, margin.t + plotH + 15);
        }
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Frequency Ratio Ω = p/q', margin.l + plotW / 2, H - 5);
    ctx.save();
    ctx.translate(15, margin.t + plotH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Coupling K', 0, 0);
    ctx.restore();
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('Arnold Tongues (Phase-Locking Regions)', margin.l + plotW / 2, 18);
}

function drawFrequencySpectrum() {
    const canvas = document.getElementById('freqSpectrumCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const baseFreq = +(document.getElementById('harmonicBaseFreq')?.value || 220);
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const logScale = document.getElementById('freqLogScale')?.checked ?? false;
    const showOctaves = document.getElementById('freqShowOctaves')?.checked ?? true;
    const sortMode = document.getElementById('freqSortMode')?.value || 'freq';
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 60, r: 20, t: 30, b: 50 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let fractions = (state.residuesBySector[sector] || []).map(f => ({
        ...f,
        freq: baseFreq * (f.r / f.m),
        mode: getHarmonicMode(f.m)
    }));
    
    if (fractions.length === 0) {
        ctx.fillStyle = '#64748b';
        ctx.font = '14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('No data - run computation first', W / 2, H / 2);
        return;
    }
    
    // Sort
    if (sortMode === 'freq') fractions.sort((a, b) => a.freq - b.freq);
    else if (sortMode === 'consonance') fractions.sort((a, b) => a.m - b.m);
    else fractions.sort((a, b) => a.m - b.m);
    
    fractions = fractions.slice(0, 50);
    
    const maxFreq = Math.max(...fractions.map(f => f.freq));
    const minFreq = Math.min(...fractions.map(f => f.freq));
    const barWidth = plotW / fractions.length;
    
    // Draw octave lines
    if (showOctaves) {
        ctx.strokeStyle = '#22c55e40';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        for (let oct = 0; oct < 4; oct++) {
            const octFreq = baseFreq * Math.pow(2, oct);
            if (octFreq <= maxFreq * 1.1) {
                const y = margin.t + plotH - (octFreq / maxFreq) * plotH * 0.9;
                ctx.beginPath();
                ctx.moveTo(margin.l, y);
                ctx.lineTo(margin.l + plotW, y);
                ctx.stroke();
                ctx.fillStyle = '#22c55e';
                ctx.font = '9px system-ui';
                ctx.textAlign = 'right';
                ctx.fillText(`${octFreq.toFixed(0)}Hz`, margin.l - 5, y + 3);
            }
        }
        ctx.setLineDash([]);
    }
    
    // Draw bars
    fractions.forEach((f, i) => {
        const x = margin.l + i * barWidth;
        const height = (f.freq / maxFreq) * plotH * 0.85;
        const y = margin.t + plotH - height;
        
        ctx.fillStyle = f.mode.color + '90';
        ctx.fillRect(x + 1, y, barWidth - 2, height);
        ctx.strokeStyle = f.mode.color;
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 1, y, barWidth - 2, height);
    });
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Fractions (sorted by ' + sortMode + ')', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText(`Frequency Spectrum (Base: ${baseFreq} Hz)`, margin.l + plotW / 2, 18);
}

function drawConsonanceMap() {
    const canvas = document.getElementById('consonanceMapCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const margin = { l: 50, r: 20, t: 30, b: 40 };
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Draw consonance as function of position in [0,1]
    const resolution = 200;
    for (let i = 0; i < resolution; i++) {
        const x = i / resolution;
        
        // Find closest Farey fraction
        let bestR = 1, bestM = 2, bestDist = 1;
        for (let m = 1; m <= Math.min(maxDenom, 20); m++) {
            for (let r = 0; r <= m; r++) {
                if (gcd(r, m) === 1) {
                    const dist = Math.abs(x - r / m);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestR = r;
                        bestM = m;
                    }
                }
            }
        }
        
        const consonance = 1 / bestM;
        const mode = getHarmonicMode(bestM);
        
        const px = margin.l + x * plotW;
        const height = consonance * plotH * 0.9;
        
        ctx.fillStyle = mode.color + '80';
        ctx.fillRect(px, margin.t + plotH - height, plotW / resolution + 1, height);
    }
    
    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, margin.t + plotH);
    ctx.lineTo(margin.l + plotW, margin.t + plotH);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Position in [0,1]', margin.l + plotW / 2, H - 10);
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('Consonance Map (height = 1/denominator)', margin.l + plotW / 2, 18);
}

function drawIntervalCircle() {
    const canvas = document.getElementById('intervalCircleCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;
    const radius = Math.min(W, H) / 2 - 50;
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw 12-TET reference circle
    ctx.strokeStyle = '#f59e0b40';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
    ctx.stroke();
    
    // 12-TET positions
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * 2 * Math.PI - Math.PI / 2;
        const x = cx + Math.cos(angle) * (radius + 20);
        const y = cy + Math.sin(angle) * (radius + 20);
        
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(noteNames[i], x, y + 4);
    }
    
    // Plot fractions on circle
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    fractions.forEach(f => {
        const cents = 1200 * Math.log2(f.r / f.m);
        const normalizedCents = ((cents % 1200) + 1200) % 1200;
        const angle = (normalizedCents / 1200) * 2 * Math.PI - Math.PI / 2;
        const x = cx + Math.cos(angle) * radius * 0.85;
        const y = cy + Math.sin(angle) * radius * 0.85;
        
        const mode = getHarmonicMode(f.m);
        ctx.fillStyle = mode.color;
        ctx.beginPath();
        ctx.arc(x, y, f.m <= 4 ? 6 : 4, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // Center label
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Pitch Class Circle', cx, cy - 5);
    ctx.font = '10px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.fillText('(12-TET reference)', cx, cy + 10);
}

function updateIntervalTable() {
    const tbody = document.querySelector('#intervalTable tbody');
    if (!tbody) return;
    
    const baseFreq = +(document.getElementById('harmonicBaseFreq')?.value || 220);
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    
    if (fractions.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;color:#64748b;">No data - run computation first</td></tr>';
        return;
    }
    
    fractions.sort((a, b) => a.r / a.m - b.r / b.m);
    
    let html = '';
    fractions.forEach(f => {
        const freq = baseFreq * (f.r / f.m);
        const note = frequencyToNote(freq);
        const cents = frequencyToCents(baseFreq, freq);
        const mode = getHarmonicMode(f.m);
        const intervalName = getIntervalName(f.r, f.m);
        
        html += `<tr>
            <td><strong>${f.r}/${f.m}</strong></td>
            <td>${f.r}:${f.m}</td>
            <td style="color:#8b5cf6">${freq.toFixed(2)} Hz</td>
            <td>${cents >= 0 ? '+' : ''}${cents.toFixed(1)}¢</td>
            <td>${note.name} (${note.cents >= 0 ? '+' : ''}${note.cents}¢)</td>
            <td>${intervalName}</td>
            <td><span class="mode-indicator ${mode.class}">${mode.name}</span></td>
            <td><button class="harmonic-btn primary" onclick="playFraction(${f.r},${f.m},0.6)" style="padding:3px 8px;font-size:10px;">Play</button></td>
        </tr>`;
    });
    
    tbody.innerHTML = html;
}

// Initialize harmonic panel on load
setTimeout(() => {
    updateHarmonicDisplays();
    drawArnoldMini();
    drawHarmonicSeriesViz();
    setupGlobalFractionListeners();
}, 200);

// =============================================
// GLOBAL FRACTION CLICK INTEGRATION
// =============================================
function setupGlobalFractionListeners() {
    // This makes harmonic work for ALL tabs with fractions
    
    // Smith Chart Canvas
    const smithCanvas = document.getElementById('smithCanvas');
    if (smithCanvas) {
        smithCanvas.addEventListener('click', handleSmithClick);
    }
    
    // Hyperbolic Canvas
    const hypCanvas = document.getElementById('hypCanvas');
    if (hypCanvas) {
        hypCanvas.addEventListener('click', handleHyperbolicClick);
    }
    
    // Animation Canvas
    const animCanvas = document.getElementById('animCanvas');
    if (animCanvas) {
        animCanvas.addEventListener('click', handleAnimationClick);
    }
    
    // 3D Canvas
    const canvas3d = document.getElementById('canvas3d');
    if (canvas3d) {
        canvas3d.addEventListener('click', handle3DClick);
    }
    
    // Ford Circles Canvas (PSL tab)
    const fordCanvas = document.getElementById('fordCanvas');
    if (fordCanvas) {
        fordCanvas.addEventListener('click', handleFordClick);
    }
    
    // Arnold Tongue Canvas (Harmonic tab)
    const arnoldCanvas = document.getElementById('arnoldTongueCanvas');
    if (arnoldCanvas) {
        arnoldCanvas.addEventListener('click', handleArnoldClick);
    }
    
    // Interval Circle Canvas
    const intervalCanvas = document.getElementById('intervalCircleCanvas');
    if (intervalCanvas) {
        intervalCanvas.addEventListener('click', handleIntervalCircleClick);
    }
    
    // Lattice Viz Canvas (Theory Viz)
    const latticeCanvas = document.getElementById('latticeVizCanvas');
    if (latticeCanvas) {
        latticeCanvas.addEventListener('click', handleLatticeClick);
    }
    
    // Add click handlers to tables with fractions
    document.addEventListener('click', handleTableFractionClick);
    
    console.log('Global harmonic listeners initialized');
}

// Store points for each visualization for click detection
const vizPoints = {
    smith: [],
    hyperbolic: [],
    animation: [],
    threeDim: [],
    ford: [],
    arnold: [],
    intervalCircle: [],
    lattice: []
};

function handleSmithClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const sector = +(document.getElementById('smithSector')?.value || 2);
    const residues = state.residuesBySector[sector] || [];
    
    // Find closest point
    let closest = null, minDist = 20;
    residues.forEach(res => {
        // Approximate screen position (simplified)
        const angle = (res.r / res.m) * 2 * Math.PI;
        const cx = e.target.width / 2, cy = e.target.height / 2;
        const maxR = Math.min(e.target.width, e.target.height) / 2 - 40;
        const px = cx + Math.cos(angle) * maxR * 0.7;
        const py = cy - Math.sin(angle) * maxR * 0.7;
        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        if (dist < minDist) { minDist = dist; closest = res; }
    });
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m, closest);
}

function handleHyperbolicClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const maxDenom = +(document.getElementById('hypMaxDenom')?.value || 15);
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, R = Math.min(W, H) / 2 - 30;
    
    // Build Farey fractions on boundary
    let closest = null, minDist = 15;
    for (let m = 2; m <= maxDenom; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const angle = (r / m) * Math.PI - Math.PI / 2;
                const px = cx + R * Math.cos(angle);
                const py = cy + R * Math.sin(angle);
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleAnimationClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, maxR = Math.min(W, H) / 2 - 30;
    const maxN = +(document.getElementById('animMaxN')?.value || 50);
    
    let closest = null, minDist = 15;
    for (let m = 2; m <= maxN; m++) {
        for (let r = 1; r < m; r++) {
            if (gcd(r, m) === 1) {
                const angle = (r / m) * 2 * Math.PI;
                const rad = (m / maxN) * maxR;
                const px = cx + rad * Math.cos(angle);
                const py = cy - rad * Math.sin(angle);
                const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m);
}

function handle3DClick(e) {
    // 3D is more complex, use current sector data
    const sector = +(document.getElementById('viewSector')?.value || 2);
    const residues = state.residuesBySector[sector] || [];
    if (residues.length > 0) {
        const randomRes = residues[Math.floor(Math.random() * Math.min(residues.length, 20))];
        triggerGlobalHarmonic(randomRes.r, randomRes.m, randomRes);
    }
}

function handleFordClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const W = e.target.width;
    const margin = 30, scale = W - 2 * margin;
    const maxDenom = +(document.getElementById('pslMaxDenom')?.value || 12);
    
    // Find fraction closest to click x position
    let closest = null, minDist = 20;
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                const fx = margin + (r / m) * scale;
                const dist = Math.abs(fx - x);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest && closest.r > 0) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleArnoldClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const W = e.target.width;
    const margin = { l: 50, r: 20 };
    const plotW = W - margin.l - margin.r;
    const maxDenom = +(document.getElementById('harmonicMaxDenom')?.value || 32);
    
    // Convert x to omega value
    const omega = (x - margin.l) / plotW;
    if (omega < 0 || omega > 1) return;
    
    // Find closest Farey fraction
    let closest = null, minDist = 0.05;
    for (let m = 1; m <= maxDenom; m++) {
        for (let r = 0; r <= m; r++) {
            if (gcd(r, m) === 1) {
                const dist = Math.abs(omega - r / m);
                if (dist < minDist) { minDist = dist; closest = { r, m }; }
            }
        }
    }
    
    if (closest && closest.r > 0) triggerGlobalHarmonic(closest.r, closest.m);
}

function handleIntervalCircleClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const cx = W / 2, cy = H / 2, radius = Math.min(W, H) / 2 - 50;
    const sector = +(document.getElementById('harmonicSector')?.value || 2);
    
    const fractions = (state.residuesBySector[sector] || []).slice(0, 30);
    let closest = null, minDist = 15;
    
    fractions.forEach(f => {
        const cents = 1200 * Math.log2(f.r / f.m);
        const normalizedCents = ((cents % 1200) + 1200) % 1200;
        const angle = (normalizedCents / 1200) * 2 * Math.PI - Math.PI / 2;
        const px = cx + Math.cos(angle) * radius * 0.85;
        const py = cy + Math.sin(angle) * radius * 0.85;
        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        if (dist < minDist) { minDist = dist; closest = f; }
    });
    
    if (closest) triggerGlobalHarmonic(closest.r, closest.m, closest);
}

function handleLatticeClick(e) {
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const W = e.target.width, H = e.target.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const margin = 45;
    const scale = (Math.min(W, H) - 2 * margin) / maxB;
    
    // Convert screen coords to lattice coords
    const a = Math.round((x - margin) / scale);
    const b = Math.round((H - margin - y) / scale);
    
    if (a >= 1 && b >= 1 && a < b && gcd(a, b) === 1) {
        triggerGlobalHarmonic(a, b);
    }
}

function handleTableFractionClick(e) {
    // Handle clicks on fraction text in tables (e.g., "3/7")
    const target = e.target;
    const text = target.textContent.trim();
    const match = text.match(/^(\d+)\/(\d+)$/);
    
    if (match) {
        const r = parseInt(match[1]);
        const m = parseInt(match[2]);
        if (r > 0 && m > 0 && gcd(r, m) === 1) {
            triggerGlobalHarmonic(r, m);
            e.preventDefault();
        }
    }
}

// CENTRAL FUNCTION - triggers harmonic for any fraction from any source
function triggerGlobalHarmonic(r, m, extraData = null) {
    selectedHarmonicFraction = { r, m };
    
    // Update all harmonic displays
    updateHarmonicDisplays();
    selectFractionForHarmonic(r, m);
    
    // Auto-play if enabled
    if (document.getElementById('autoPlayOnClick')?.checked) {
        playFraction(r, m, 0.6);
    }
    
    // Highlight the toggle button briefly
    const toggle = document.getElementById('harmonicToggle');
    if (toggle) {
        toggle.classList.add('playing');
        setTimeout(() => toggle.classList.remove('playing'), 600);
    }
    
    // Open panel if closed and significant fraction
    if (m <= 8 && !document.getElementById('harmonicPanel').classList.contains('expanded')) {
        // Optionally auto-expand for interesting fractions
    }
    
    console.log(`Harmonic: ${r}/${m} = ${(r/m).toFixed(6)}, freq = ${(harmonicSettings.baseFreq * r / m).toFixed(2)} Hz`);
}

// Build mini keyboard
function buildMiniKeyboard() {
    const keyboard = document.getElementById('miniKeyboard');
    if (!keyboard) return;
    
    const notes = [
        { note: 'C', black: false, ratio: 1 },
        { note: 'C#', black: true, ratio: 16/15 },
        { note: 'D', black: false, ratio: 9/8 },
        { note: 'D#', black: true, ratio: 6/5 },
        { note: 'E', black: false, ratio: 5/4 },
        { note: 'F', black: false, ratio: 4/3 },
        { note: 'F#', black: true, ratio: 45/32 },
        { note: 'G', black: false, ratio: 3/2 },
        { note: 'G#', black: true, ratio: 8/5 },
        { note: 'A', black: false, ratio: 5/3 },
        { note: 'A#', black: true, ratio: 9/5 },
        { note: 'B', black: false, ratio: 15/8 },
        { note: 'C2', black: false, ratio: 2 }
    ];
    
    keyboard.innerHTML = '';
    notes.forEach(n => {
        const key = document.createElement('div');
        key.className = n.black ? 'black-key' : 'white-key';
        key.title = n.note;
        key.onclick = () => {
            // Convert ratio to fraction
            const [num, den] = ratioToFraction(n.ratio);
            triggerGlobalHarmonic(num, den);
            
            // Visual feedback
            key.classList.add('active');
            setTimeout(() => key.classList.remove('active'), 200);
        };
        keyboard.appendChild(key);
    });
}

function ratioToFraction(ratio) {
    // Convert decimal ratio to simplified fraction
    const tolerance = 1e-6;
    let bestNum = 1, bestDen = 1, bestErr = Math.abs(ratio - 1);
    
    for (let den = 1; den <= 32; den++) {
        const num = Math.round(ratio * den);
        const err = Math.abs(ratio - num / den);
        if (err < bestErr) {
            bestErr = err;
            bestNum = num;
            bestDen = den;
        }
        if (err < tolerance) break;
    }
    
    const g = gcd(bestNum, bestDen);
    return [bestNum / g, bestDen / g];
}

// Draw harmonic series visualization
function drawHarmonicSeriesViz() {
    const canvas = document.getElementById('harmonicSeriesCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    const barWidth = (W - 20) / numPartials;
    
    for (let i = 1; i <= numPartials; i++) {
        const amplitude = 1 / i; // Natural harmonic decay
        const height = amplitude * (H - 10);
        const x = 10 + (i - 1) * barWidth;
        
        // Color by harmonic number
        const hue = 260 - (i - 1) * 15;
        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
        ctx.fillRect(x, H - height - 5, barWidth - 2, height);
        
        // Label
        ctx.fillStyle = '#94a3b8';
        ctx.font = '8px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(i + 'f', x + barWidth / 2, H - 1);
    }
}

function updateHarmonicSeries() {
    const val = document.getElementById('numPartials')?.value || 8;
    document.getElementById('partialsVal').textContent = val;
    drawHarmonicSeriesViz();
}

function playHarmonicSeries() {
    initAudioContext();
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    const baseFreq = harmonicSettings.baseFreq;
    
    for (let i = 1; i <= numPartials; i++) {
        setTimeout(() => {
            const freq = baseFreq * i;
            playTone(freq, 0.3, 0.15 / i);
        }, (i - 1) * 200);
    }
}

function playSubharmonicSeries() {
    initAudioContext();
    const numPartials = +(document.getElementById('numPartials')?.value || 8);
    const baseFreq = harmonicSettings.baseFreq * 4; // Start higher
    
    for (let i = 1; i <= numPartials; i++) {
        setTimeout(() => {
            const freq = baseFreq / i;
            playTone(freq, 0.3, 0.2);
        }, (i - 1) * 200);
    }
}

function playTone(freq, duration, volume) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    
    osc.type = harmonicSettings.waveform;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(volume * harmonicSettings.volume, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
}

function playChord() {
    initAudioContext();
    const { r, m } = selectedHarmonicFraction;
    const baseFreq = harmonicSettings.baseFreq;
    
    // Play root, third, fifth
    playTone(baseFreq, 1.0, harmonicSettings.volume);
    playTone(baseFreq * 5 / 4, 1.0, harmonicSettings.volume * 0.8); // Major third
    playTone(baseFreq * 3 / 2, 1.0, harmonicSettings.volume * 0.8); // Perfect fifth
    playTone(baseFreq * r / m, 1.0, harmonicSettings.volume); // Selected fraction
}

function updateBeatFrequency() {
    const f1 = harmonicSettings.baseFreq * selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    const f2 = +(document.getElementById('beatFreq2')?.value || 330);
    const beat = Math.abs(f1 - f2);
    document.getElementById('beatFreqResult').textContent = beat.toFixed(2);
}

function playBeatDemo() {
    initAudioContext();
    const f1 = harmonicSettings.baseFreq * selectedHarmonicFraction.r / selectedHarmonicFraction.m;
    const f2 = +(document.getElementById('beatFreq2')?.value || 330);
    
    // Play both frequencies simultaneously to hear beats
    playTone(f1, 2.0, harmonicSettings.volume * 0.5);
    playTone(f2, 2.0, harmonicSettings.volume * 0.5);
}

function updateADSR() {
    // Store ADSR values for envelope shaping
    harmonicSettings.adsr = {
        attack: (document.getElementById('adsrA')?.value || 10) / 100,
        decay: (document.getElementById('adsrD')?.value || 20) / 100,
        sustain: (document.getElementById('adsrS')?.value || 70) / 100,
        release: (document.getElementById('adsrR')?.value || 30) / 100
    };
}

function updateTuningSystem() {
    harmonicSettings.tuning = document.getElementById('tuningSystem')?.value || 'just';
}

function drawWaveformDisplay() {
    const canvas = document.getElementById('waveformDisplay');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw waveform based on selected type
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    
    const waveform = harmonicSettings.waveform;
    const cycles = 3;
    
    for (let x = 0; x < W; x++) {
        const t = (x / W) * cycles * 2 * Math.PI;
        let y;
        
        switch (waveform) {
            case 'sine':
                y = Math.sin(t);
                break;
            case 'triangle':
                y = 2 * Math.abs(2 * (t / (2 * Math.PI) - Math.floor(t / (2 * Math.PI) + 0.5))) - 1;
                break;
            case 'square':
                y = Math.sin(t) >= 0 ? 1 : -1;
                break;
            case 'sawtooth':
                y = 2 * (t / (2 * Math.PI) - Math.floor(t / (2 * Math.PI) + 0.5));
                break;
            default:
                y = Math.sin(t);
        }
        
        const screenY = H / 2 - y * (H / 2 - 4);
        x === 0 ? ctx.moveTo(x, screenY) : ctx.lineTo(x, screenY);
    }
    ctx.stroke();
}

setTimeout(addZoomControlsToCharts, 500);</script>
</body>
    </html>
