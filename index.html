<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farey Sector Formula - Complete Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0f1a; color: #e2e8f0; line-height: 1.6; font-size: 14px; }
        
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1000; overflow-y: auto; padding: 20px; }
        .modal-overlay.active { display: flex; justify-content: center; align-items: flex-start; }
        .modal-content { background: #1e293b; border-radius: 12px; max-width: 900px; width: 100%; border: 1px solid #475569; margin: 20px auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 18px; border-bottom: 1px solid #334155; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border-radius: 12px 12px 0 0; }
        .modal-header h3 { margin: 0; font-size: 1.1em; }
        .modal-close { background: rgba(255,255,255,0.2); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 16px; }
        .modal-body { padding: 18px; max-height: 75vh; overflow-y: auto; }
        
        .container { max-width: 1800px; margin: 0 auto; padding: 15px; }
        h1 { color: #f8fafc; font-size: 1.5em; margin-bottom: 4px; }
        .subtitle { color: #94a3b8; margin-bottom: 15px; font-size: 0.9em; }
        h2 { color: #f1f5f9; font-size: 1.1em; margin: 20px 0 12px 0; border-bottom: 1px solid #334155; padding-bottom: 6px; }
        h3 { color: #cbd5e1; font-size: 1em; margin: 12px 0 8px 0; }
        h4 { color: #94a3b8; font-size: 0.9em; margin: 8px 0 6px 0; }
        
        .formula-box { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); padding: 15px; border-radius: 10px; margin-bottom: 15px; }
        .formula-main { font-size: 1.3em; font-weight: bold; font-family: 'Cambria Math', serif; text-align: center; margin: 8px 0; }
        
        .control-panel { background: #1e293b; padding: 12px 15px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #334155; }
        .control-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
        .control-row:last-child { margin-bottom: 0; }
        .control-group { display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: #0f172a; border-radius: 5px; }
        .control-group.highlight { border: 1px solid #6366f1; background: #1e1b4b; }
        label { font-weight: 600; color: #cbd5e1; font-size: 0.8em; white-space: nowrap; }
        input[type="number"], input[type="text"], select, textarea { padding: 6px 8px; font-size: 13px; border: 1px solid #475569; border-radius: 5px; background: #1e293b; color: #e2e8f0; }
        input[type="number"] { width: 70px; }
        input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }
        select { min-width: 90px; }
        button { padding: 8px 14px; font-size: 12px; font-weight: 600; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { opacity: 0.9; }
        button.secondary { background: #334155; border: 1px solid #475569; }
        button.small { padding: 5px 10px; font-size: 11px; }
        .info-badge { background: #334155; padding: 3px 8px; border-radius: 4px; font-size: 0.8em; color: #94a3b8; }
        .info-badge strong { color: #e2e8f0; }
        .info-badge.success { background: #14532d; border: 1px solid #16a34a; }
        .info-badge.warning { background: #713f12; border: 1px solid #a16207; }
        
        .mode-selector { display: flex; gap: 4px; }
        .mode-btn { padding: 6px 12px; background: #1e293b; border: 1px solid #475569; border-radius: 5px; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .mode-btn.active { background: #6366f1; border-color: #6366f1; color: white; }
        
        .tabs { display: flex; gap: 3px; margin-bottom: 12px; flex-wrap: wrap; }
        .tab { padding: 6px 12px; background: #1e293b; border: 1px solid #334155; border-radius: 5px 5px 0 0; cursor: pointer; font-size: 0.8em; color: #94a3b8; }
        .tab.active { background: #334155; color: #f1f5f9; border-bottom-color: #334155; }
        .tab:hover { color: #e2e8f0; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .panel { background: #1e293b; border-radius: 8px; padding: 15px; border: 1px solid #334155; margin-bottom: 15px; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
        .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        @media (max-width: 1200px) { .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; } }
        
        .chart-box { background: #0f172a; border-radius: 6px; padding: 12px; border: 1px solid #334155; }
        .chart-box h4 { margin-top: 0; }
        canvas { max-width: 100%; }
        
        table { width: 100%; border-collapse: collapse; font-size: 0.8em; }
        thead { background: #334155; }
        th { padding: 8px; text-align: left; font-weight: 600; color: #e2e8f0; }
        td { padding: 6px 8px; border-bottom: 1px solid #334155; }
        tbody tr:hover { background: #334155; }
        .table-scroll { max-height: 350px; overflow-y: auto; }
        
        .detail-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .detail-card { background: #0f172a; padding: 12px; border-radius: 6px; border: 1px solid #334155; }
        .detail-card h5 { color: #94a3b8; font-size: 0.75em; margin-bottom: 6px; text-transform: uppercase; }
        .detail-card .value { font-size: 1.2em; font-weight: bold; color: #6366f1; }
        .detail-card .sub { font-size: 0.8em; color: #64748b; margin-top: 3px; }
        
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
        .stat-card { background: #0f172a; padding: 10px; border-radius: 5px; border: 1px solid #334155; text-align: center; }
        .stat-value { font-size: 1.1em; font-weight: bold; color: #6366f1; }
        .stat-label { font-size: 0.7em; color: #94a3b8; margin-top: 3px; }
        
        .theorem-box { background: #1e1b4b; border-left: 3px solid #6366f1; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .derivation-box { background: #422006; border-left: 3px solid #f59e0b; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .rh-box { background: #450a0a; border-left: 3px solid #ef4444; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        .connection-box { background: #14532d; border-left: 3px solid #22c55e; padding: 10px 12px; margin: 10px 0; border-radius: 0 5px 5px 0; font-size: 0.9em; }
        
        .ring-canvas { background: #0f172a; border-radius: 6px; border: 1px solid #334155; cursor: crosshair; }
        .point-tooltip { position: absolute; background: #1e293b; border: 1px solid #6366f1; padding: 8px 12px; border-radius: 6px; font-size: 0.8em; pointer-events: none; z-index: 100; display: none; min-width: 160px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .point-tooltip.visible { display: block; }
        .point-tooltip h5 { color: #6366f1; margin: 0 0 6px 0; font-size: 1em; }
        .point-tooltip .row { display: flex; justify-content: space-between; margin: 2px 0; }
        .point-tooltip .label { color: #94a3b8; }
        .point-tooltip .val { color: #e2e8f0; font-weight: 600; }
        
        .color-legend { display: flex; flex-wrap: wrap; gap: 12px; margin-top: 8px; padding: 8px; background: #0f172a; border-radius: 5px; font-size: 0.75em; }
        .color-legend-item { display: flex; align-items: center; gap: 5px; }
        .color-swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #475569; }
        
        .progress-bar { width: 100%; height: 5px; background: #334155; border-radius: 3px; overflow: hidden; margin: 8px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #6366f1, #8b5cf6); transition: width 0.3s; }
        
        .matrix-display { font-family: 'Courier New', monospace; background: #0f172a; padding: 10px; border-radius: 5px; display: inline-block; margin: 5px; }
        .matrix-bracket { font-size: 2em; line-height: 1; }
        
        .residue-list { max-height: 180px; overflow-y: auto; background: #0f172a; padding: 8px; border-radius: 5px; font-family: monospace; font-size: 0.8em; }
        .residue-item { display: inline-block; padding: 3px 8px; margin: 3px; background: #334155; border-radius: 3px; cursor: default; transition: background 0.2s; }
        .residue-item:hover { background: #475569; }
        .residue-item.prime { background: #854d0e; color: #fbbf24; border: 1px solid #f59e0b; }
        .residue-item.prime:hover { background: #a16207; }
        .residue-item.twin { background: #166534; color: #4ade80; }
        
        .latex-output { background: #0f172a; padding: 12px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; border: 1px solid #334155; max-height: 250px; overflow-y: auto; }
        
        .cf-path { font-family: monospace; background: #334155; padding: 2px 6px; border-radius: 3px; margin: 2px; display: inline-block; }
        
        .screenshot-btn { position: absolute; top: 8px; right: 8px; padding: 4px 8px; background: rgba(99,102,241,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn { position: absolute; top: 8px; right: 90px; padding: 4px 8px; background: rgba(168,85,247,0.8); border: none; border-radius: 3px; color: white; font-size: 10px; cursor: pointer; z-index: 10; }
        .export-4k-btn:hover { background: rgba(168,85,247,1); }
        .chart-wrapper { position: relative; }
        .composite-export-btn { margin-top: 10px; padding: 10px 16px; font-size: 13px; background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%); }
        .composite-export-btn:hover { opacity: 0.95; }
        #compositeCanvas { display: none; max-width: 100%; margin-top: 10px; }
        .composite-info { background: #1e1b4b; border: 1px solid #8b5cf6; padding: 10px 12px; border-radius: 5px; margin-top: 10px; font-size: 0.85em; color: #cbd5e1; }
        
        .screenshot-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; display: none; justify-content: center; align-items: center; flex-direction: column; padding: 20px; }
        .screenshot-overlay.active { display: flex; }
        .screenshot-preview { max-width: 90%; max-height: 60vh; border: 2px solid #6366f1; border-radius: 8px; }
        .screenshot-actions { margin-top: 20px; display: flex; gap: 10px; }
        .screenshot-actions button { padding: 12px 24px; font-size: 14px; }
        
        .heatmap-cell { display: inline-block; width: 20px; height: 20px; margin: 1px; border-radius: 2px; }
        
        .euler-term { display: inline-block; padding: 4px 8px; margin: 3px; background: #1e293b; border-radius: 4px; border: 1px solid #334155; font-family: monospace; }
        .euler-term.prime { border-color: #f59e0b; }
    </style>
</head>
<body>
<div class="container">
    <h1>Farey Sector Formula - Complete Research Platform</h1>
    <p class="subtitle">Comprehensive analysis with RH connections, modular arithmetic, and advanced visualizations</p>
    
    <div class="formula-box">
        <div class="formula-main">C(n, N) = 3N² / (π² n(n+1))</div>
        <p style="text-align:center; font-size:0.85em; opacity:0.9;">Asymptotic count of coprime pairs (r, m) with r/m in sector S_n = (1/(n+1), 1/n]</p>
    </div>
    
    <div class="control-panel">
        <div class="control-row">
            <label>Mode:</label>
            <div class="mode-selector">
                <div class="mode-btn active" onclick="setMode('exact')" id="mode-exact">Exact</div>
                <div class="mode-btn" onclick="setMode('hybrid')" id="mode-hybrid">Hybrid</div>
                <div class="mode-btn" onclick="setMode('formula')" id="mode-formula">Formula</div>
            </div>
            <span class="info-badge" id="modeDescription">Exact enumeration</span>
        </div>
        <div class="control-row">
            <div class="control-group highlight">
                <label>N:</label>
                <input type="number" id="nMin" value="100" min="2"> to
                <input type="number" id="nMax" value="100" min="2">
            </div>
            <div class="control-group highlight">
                <label>Sectors:</label>
                <input type="number" id="sectorMin" value="1" min="1"> to
                <input type="number" id="sectorMax" value="15" min="1">
            </div>
            <button onclick="computeAll()">Compute</button>
            <button class="secondary" onclick="cancelComputation()">Cancel</button>
            <button class="secondary" onclick="exportAllData()">Export All</button>
            <button class="composite-export-btn" onclick="exportCompositeTab()" title="Export all visible charts to single 4K image">4K Composite Export</button>
        </div>
        <div class="progress-bar" id="progressBar" style="display:none;"><div class="progress-fill" id="progressFill"></div></div>
        <div id="statusArea"></div>
    </div>
    
    <div class="tabs">
        <div class="tab active" onclick="switchTab('main')">Main</div>
        <div class="tab" onclick="switchTab('theory')">Theory</div>
        <div class="tab" onclick="switchTab('theoryviz')">Theory Viz</div>
        <div class="tab" onclick="switchTab('gaps')">Gaps</div>
        <div class="tab" onclick="switchTab('franel')">Franel-Landau</div>
        <div class="tab" onclick="switchTab('dedekind')">Dedekind</div>
        <div class="tab" onclick="switchTab('cf')">Continued Fractions</div>
        <div class="tab" onclick="switchTab('psl')">PSL(2,Z)</div>
        <div class="tab" onclick="switchTab('euler')">Euler Product</div>
        <div class="tab" onclick="switchTab('modular')">Modular</div>
        <div class="tab" onclick="switchTab('3d')">3D View</div>
        <div class="tab" onclick="switchTab('hyperbolic')">Hyperbolic</div>
        <div class="tab" onclick="switchTab('animation')">Animation</div>
        <div class="tab" onclick="switchTab('smith')">Smith Chart</div>
        <div class="tab" onclick="switchTab('stats')">Statistics</div>
        <div class="tab" onclick="switchTab('primes')">Primes</div>
        <div class="tab" onclick="switchTab('research')">Research</div>
    </div>
    
    <!-- MAIN TAB -->
    <div id="tab-main" class="tab-content active">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #6366f1;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Main Sector Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#6366f1;">C(n,N) = 3N² / (π² n(n+1))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;"><strong>Definition:</strong> Sectors are defined by consecutive Farey bounds: sector S_n spans the interval (1/(n+1), 1/n], a decreasing sequence of intervals that partition [0,1]. <strong>Formula Purpose:</strong> This asymptotic formula provides increasingly accurate predictions of the count of coprime pairs (r,m) with r/m in sector S_n, where N is the maximum denominator. As N grows, the accuracy of this prediction improves significantly. The formula shows how the Farey sequence distributes its fractions across the unit interval with mathematical precision.</p>
        </div>
        <div class="stat-grid" id="mainStats"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Exact vs Predicted</h4><canvas id="mainCountChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Relative Error %</h4><canvas id="mainErrorChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px;">
            <h4>Sector Data <span style="font-weight:normal; color:#64748b;">(click row to see primes)</span></h4>
            <div class="table-scroll"><table id="mainTable"><thead><tr><th>n</th><th>Interval</th><th>Exact</th><th>Pred</th><th>Err%</th><th>Primes</th><th>Composites</th></tr></thead><tbody></tbody></table></div>
        </div>
        <div class="panel chart-wrapper">
            <h4>Sector Ring <span style="font-weight:normal; color:#64748b;">(click points to see tree path)</span></h4>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Sector: <input type="number" id="viewSector" value="1" min="1" onchange="drawMainRing()"></label>
                <label>Color: <select id="colorMode" onchange="drawMainRing()"><option value="sector">Sector</option><option value="prime">Prime</option><option value="denominator">Denom</option><option value="gap">Gap</option></select></label>
                <label><input type="checkbox" id="showAllSectors" onchange="drawMainRing()"> All</label>
                <button class="secondary" onclick="openSectorModal(+document.getElementById('viewSector').value)">View Sector Details</button>
            </div>
            <div style="text-align:center;position:relative;"><canvas id="mainRing" class="ring-canvas" width="600" height="600"></canvas><div class="point-tooltip" id="pointTooltip"></div></div>
            <div class="color-legend" id="colorLegend"></div>
            <div style="margin-top:10px;"><button onclick="screenshotFullTab('main')">Screenshot Full Main Tab</button></div>
        </div>
        
        <div class="panel chart-wrapper">
            <h4>Sector Tree Path <span style="font-weight:normal; color:#64748b;">(Stern-Brocot navigation)</span></h4>
            <div class="control-row" style="margin-bottom:10px;">
                <label>Tree Depth: <input type="number" id="treeDepth" value="8" min="3" max="15" onchange="drawSectorTree()"></label>
                <label><input type="checkbox" id="showTreeLabels" checked onchange="drawSectorTree()"> Labels</label>
                <label><input type="checkbox" id="showTreeGrid" onchange="drawSectorTree()"> Grid</label>
                <label><input type="checkbox" id="animatePath" checked> Animate</label>
                <button class="secondary" onclick="clearTreePath()">Clear Path</button>
            </div>
            <div style="text-align:center;position:relative;">
                <canvas id="sectorTreeCanvas" class="ring-canvas" width="900" height="500"></canvas>
            </div>
            <div id="treePathInfo" style="margin-top:10px; padding:10px; background:#0f172a; border-radius:5px; font-family:monospace; font-size:0.9em;">
                <span style="color:#64748b;">Click a point on the ring above to see its tree path</span>
            </div>
            <div class="color-legend">
                <div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Tree nodes</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Path to target</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#22c55e"></div>Target fraction</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#ef4444"></div>L (left)</div>
                <div class="color-legend-item"><div class="color-swatch" style="background:#3b82f6"></div>R (right)</div>
            </div>
        </div>
    </div>
    
    <!-- THEORY TAB -->
    <div id="tab-theory" class="tab-content">
        <div class="panel">
            <h2 style="text-align:center; font-size:1.3em; margin-bottom:8px;">Directional Density of Coprime Lattice Points in Farey Sectors</h2>
            <p style="text-align:center; color:#94a3b8; font-style:italic; margin-bottom:20px;">Wessen Getachew</p>
            
            <div class="theorem-box" style="background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%); border-left-color: #8b5cf6;">
                <h4 style="color:#e0e7ff; margin-top:0;">Abstract</h4>
                <p style="margin:0; font-size:0.95em;">We study the distribution of coprime integer pairs (a,b) with bounded height whose rational slope lies in a fixed Farey sector S_n = (1/(n+1), 1/n]. Using classical summatory totient estimates together with a geometric decomposition of rational directions, we derive an explicit asymptotic formula for the number of primitive lattice points in each sector. This result provides a localized refinement of the global coprime density 1/zeta(2), revealing directional structure in the distribution of visible lattice points.</p>
            </div>
            
            <h3 style="margin-top:20px;">1. Introduction and Motivation</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #f59e0b; margin:10px 0;">
                <p>The probability that two randomly chosen integers are coprime is 1/zeta(2) = 6/pi^2 approximately 0.6079, a classical result with interpretations in analytic number theory and geometry of numbers. Geometrically, this corresponds to the density of visible lattice points in Z^2.</p>
                <p style="margin-top:8px;">Farey sequences organize rational numbers in [0,1] by increasing denominator and naturally partition rational directions into intervals. While global coprime density is well understood, we focus on <strong>directional coprime density</strong> - how primitive lattice points distribute across specific rational slope bands.</p>
            </div>
            
            <h3 style="margin-top:20px;">2. Definitions</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Farey Sector</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        S_n = (1/(n+1), 1/n]
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Intervals partitioning (0,1], bounded by consecutive Farey fractions.</p>
                </div>
                <div class="theorem-box" style="background:#1e1b4b; margin:0;">
                    <strong style="color:#c4b5fd;">Primitive Lattice Point</strong>
                    <div style="font-family:monospace; font-size:0.9em; margin-top:6px; background:#0f172a; padding:8px; border-radius:4px;">
                        (a,b) in Z^2 where gcd(a,b) = 1, b >= 1
                    </div>
                    <p style="margin:8px 0 0 0; font-size:0.85em;">Pairs with coprime coordinates representing visible lattice points.</p>
                </div>
            </div>
            
            <h3>3. Main Result</h3>
            <div class="derivation-box" style="background: linear-gradient(135deg, #422006 0%, #5a3a1a 100%); border-left-color: #fbbf24;">
                <strong style="color:#fcd34d; font-size:1.1em;">Farey Sector Density Theorem</strong>
                <p style="margin:12px 0 0 0;">Let n be fixed. As N approaches infinity, the number of coprime integer pairs with slope in the Farey sector S_n satisfies:</p>
                <div style="background:#0f172a; padding:12px; border-radius:5px; font-family:monospace; font-size:1em; margin:10px 0; text-align:center;">
                    <strong>C(n,N) ~ (3/pi^2) * N^2 / (n(n+1))</strong>
                </div>
                <p style="margin:10px 0 0 0; font-size:0.9em;">Where C(n,N) counts pairs (a,b) with 1 <= b <= N, gcd(a,b)=1, and a/b in S_n.</p>
            </div>
            
            <h3 style="margin-top:20px;">4. Proof Sketch</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #22c55e; margin:10px 0;">
                <p><strong>Step 1:</strong> The condition a/b in S_n = (1/(n+1), 1/n] is equivalent to b/(n+1) < a <= b/n.</p>
                <p style="margin:8px 0;"><strong>Step 2:</strong> For each b, the number of integers a in this range is b/(n(n+1)) + O(1).</p>
                <p style="margin:8px 0;"><strong>Step 3:</strong> Restricting to coprime pairs: Sum over b<=N of phi(b)/(n(n+1)) + O(N)</p>
                <p style="margin:8px 0;"><strong>Step 4:</strong> Apply the classical summatory totient estimate:</p>
                <div style="background:#0a0f1a; padding:8px; margin:8px 0; border-radius:4px; font-family:monospace;">
                    Sum of phi(b) = (3/pi^2)N^2 + O(N log N)
                </div>
                <p style="margin:8px 0;"><strong>Conclusion:</strong> C(n,N) = (1/(n(n+1))) * ((3/pi^2)N^2 + O(N log N))</p>
            </div>
            
            <h3 style="margin-top:20px;">5. Computational Verification</h3>
            <table style="width:100%; margin-top:10px; border-collapse:collapse; font-size:0.85em;">
                <thead><tr style="background:#334155;"><th style="padding:8px;">Sector n</th><th>Width 1/(n(n+1))</th><th>Asymptotic Factor</th><th>Global Fraction</th></tr></thead>
                <tbody>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">1</td><td style="padding:8px;">1/2</td><td style="padding:8px;">3/(2pi^2)</td><td style="padding:8px;">approximately 0.1519</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">2</td><td style="padding:8px;">1/6</td><td style="padding:8px;">3/(6pi^2)</td><td style="padding:8px;">approximately 0.0506</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">3</td><td style="padding:8px;">1/12</td><td style="padding:8px;">3/(12pi^2)</td><td style="padding:8px;">approximately 0.0253</td></tr>
                    <tr style="border-bottom:1px solid #334155;"><td style="padding:8px;">n</td><td style="padding:8px;">1/(n(n+1))</td><td style="padding:8px;">3/(pi^2 n(n+1))</td><td style="padding:8px;">1/n(n+1) * 6/pi^2</td></tr>
                </tbody>
            </table>
            <p style="margin-top:10px; font-size:0.85em; color:#94a3b8;">Numerical experiments confirm convergence to predicted asymptotics at rates consistent with O(N log N) error decay. Interactive visualizations above display accumulation of primitive lattice points within each Farey sector.</p>
            
            <h3 style="margin-top:20px;">6. Key Theoretical Connections</h3>
            <div class="grid-2" style="gap:12px; margin-bottom:15px;">
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Euler and Coprime Density</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Global density 1/zeta(2) = 6/pi^2 emerges as sum of sectoral contributions.</p>
                </div>
                <div class="connection-box" style="margin:0;">
                    <strong style="color:#4ade80;">Franel-Landau Connection</strong>
                    <p style="margin:8px 0 0 0; font-size:0.9em;">Farey gap distribution relates to RH via: Sum|F_k - k/|F_N|| = O(N^(1/2+epsilon)) iff RH</p>
                </div>
            </div>
            
            <h3>7. Conclusion</h3>
            <div style="background:#0f172a; padding:12px; border-radius:6px; border-left:3px solid #3b82f6; margin:10px 0;">
                <p style="margin:0;">Farey sectors provide a natural geometric decomposition of rational directions. By combining this structure with classical coprime density results, we obtain an explicit directional refinement of visible lattice point counts. This framework enables anisotropic analysis of arithmetic distributions and provides foundation for modular constraints, higher-dimensional generalizations, and computational number theory.</p>
            </div>
            
            <p style="margin-top:20px; text-align:center; color:#64748b; font-size:0.85em;">Acknowledgments: Foundational work of Euler, Mertens, and others on totient summation and Farey geometry.</p>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('theory')">Screenshot Full Theory Tab</button></div>
        </div>
    </div>
    
    <!-- THEORY VIZ TAB -->
    <div id="tab-theoryviz" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#312e81);border:1px solid #4338ca;margin-bottom:20px;">
            <h3 style="color:#c7d2fe;margin-top:0;">Interactive Theory Visualization</h3>
            <p style="color:#a5b4fc;font-size:0.9em;">Visual exploration of the Farey Sector Density Theorem with interactive elements</p>
        </div>
        
        <div class="control-panel">
            <div class="control-row">
                <div class="control-group highlight">
                    <label>Max Sectors:</label>
                    <input type="number" id="tvMaxSectors" value="8" min="3" max="20" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Max N:</label>
                    <input type="number" id="tvMaxN" value="150" min="20" max="500" onchange="drawTheoryViz()">
                </div>
                <div class="control-group highlight">
                    <label>Lattice Size:</label>
                    <input type="number" id="tvLatticeSize" value="22" min="10" max="40" onchange="drawTheoryViz()">
                </div>
                <div class="control-group">
                    <label>Highlight Sector:</label>
                    <input type="number" id="tvHighlightSector" value="2" min="1" max="10" onchange="drawTheoryViz()">
                </div>
                <button onclick="drawTheoryViz()">Refresh All</button>
                <button class="secondary" onclick="animateTheoryViz()">Animate Growth</button>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="chart-box chart-wrapper">
                <h4>Sector Partition of (0,1]</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowSectorValues" checked onchange="drawSectorPartition()"> Values</label>
                    <label><input type="checkbox" id="tvShowSectorWidths" onchange="drawSectorPartition()"> Widths</label>
                    <label>Style: <select id="tvPartitionStyle" onchange="drawSectorPartition()"><option value="bar">Bar</option><option value="arc">Arc</option><option value="number">Number Line</option></select></label>
                </div>
                <canvas id="sectorPartitionCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="sectorPartitionLegend"></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Density Cone: C(n,N) ~ N²/n(n+1)</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sectors to show: <input type="number" id="tvConeSectors" value="4" min="1" max="10" onchange="drawDensityCone()"></label>
                    <label><input type="checkbox" id="tvShowConeRef" checked onchange="drawDensityCone()"> 6/π² ref</label>
                    <label><input type="checkbox" id="tvLogScale" onchange="drawDensityCone()"> Log Y</label>
                </div>
                <canvas id="densityConeCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="densityConeLegend"></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Summatory Totient: Σφ(b) ~ 3N²/π²</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowTotientActual" checked onchange="drawTotientSum()"> Actual</label>
                    <label><input type="checkbox" id="tvShowTotientPredicted" checked onchange="drawTotientSum()"> Predicted</label>
                    <label><input type="checkbox" id="tvShowTotientError" onchange="drawTotientSum()"> Error</label>
                    <label><input type="checkbox" id="tvTotientFill" onchange="drawTotientSum()"> Fill</label>
                </div>
                <canvas id="totientSumCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Actual Σφ(b)</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Asymptotic 3N²/π²</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Visible Lattice Points by Direction</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label><input type="checkbox" id="tvShowHidden" checked onchange="drawLatticeViz()"> Hidden pts</label>
                    <label><input type="checkbox" id="tvShowSectorLines" checked onchange="drawLatticeViz()"> Sector lines</label>
                    <label><input type="checkbox" id="tvColorBySector" onchange="drawLatticeViz()"> Color by sector</label>
                    <label>Point size: <input type="range" id="tvPointSize" min="2" max="8" value="4" onchange="drawLatticeViz()"></label>
                </div>
                <canvas id="latticeVizCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Visible (gcd=1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#334155"></div>Hidden (gcd>1)</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Sector Boundary</div></div>
            </div>
        </div>
        
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper">
                <h4>Proof Visualization: Step-by-Step Accumulation</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Sector n: <input type="number" id="tvProofSector" value="2" min="1" max="10" onchange="drawProofSteps()"></label>
                    <label><input type="checkbox" id="tvShowContribBars" checked onchange="drawProofSteps()"> Contrib bars</label>
                    <label><input type="checkbox" id="tvShowProofPredicted" checked onchange="drawProofSteps()"> Predicted</label>
                </div>
                <canvas id="proofStepsCanvas" width="550" height="350"></canvas>
                <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#8b5cf6"></div>Cumulative count</div><div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Predicted asymptotic</div><div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>φ(b)/(n(n+1)) contribution</div></div>
            </div>
            <div class="chart-box chart-wrapper">
                <h4>Convergence Rate Analysis</h4>
                <div class="control-row" style="margin-bottom:8px;">
                    <label>Analysis type: <select id="tvConvergenceType" onchange="drawConvergenceAnalysis()"><option value="relative">Relative Error</option><option value="absolute">Absolute Error</option><option value="ratio">Actual/Predicted</option></select></label>
                    <label><input type="checkbox" id="tvShowConvergenceTrend" checked onchange="drawConvergenceAnalysis()"> Trend line</label>
                </div>
                <canvas id="convergenceCanvas" width="550" height="350"></canvas>
                <div class="color-legend" id="convergenceLegend"></div>
            </div>
        </div>
        
        <div class="chart-box chart-wrapper" style="margin-top:15px;">
            <h4>Sector Density Heatmap: C(n,N) across parameters</h4>
            <div class="control-row" style="margin-bottom:8px;">
                <label>N range: <input type="number" id="tvHeatmapNMin" value="20" min="10" max="100"> to <input type="number" id="tvHeatmapNMax" value="150" min="50" max="300"></label>
                <label>Sectors: <input type="number" id="tvHeatmapSectors" value="10" min="3" max="15"></label>
                <label>Color: <select id="tvHeatmapColor" onchange="drawDensityHeatmap()"><option value="viridis">Viridis</option><option value="plasma">Plasma</option><option value="coolwarm">Cool-Warm</option></select></label>
                <button onclick="drawDensityHeatmap()">Generate</button>
            </div>
            <canvas id="densityHeatmapCanvas" width="1100" height="300"></canvas>
            <div class="color-legend"><div class="color-legend-item"><div class="color-swatch" style="background:#440154"></div>Low density</div><div class="color-legend-item"><div class="color-swatch" style="background:#21918c"></div>Medium</div><div class="color-legend-item"><div class="color-swatch" style="background:#fde725"></div>High density</div></div>
        </div>
        
        <div class="derivation-box" style="margin-top:15px;">
            <strong>Theorem Summary:</strong> For fixed sector n, as N approaches infinity: C(n,N) = (3/π²) × N² / (n(n+1)) + O(N log N). This follows from summing φ(b)/(n(n+1)) over denominators b ≤ N and applying the classical totient summation formula.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('theoryviz')">Screenshot Full Theory Viz Tab</button></div>
    </div>
    
    <!-- GAPS TAB -->
    <div id="tab-gaps" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #8b5cf6;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Farey Gap Analysis</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.2em;text-align:center;color:#8b5cf6;">gap(a/b, c/d) = |c/d - a/b| = 1/(b*d)</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">For consecutive Farey fractions a/b and c/d, the gap between them equals exactly 1/(b*d). This elegant formula shows that gaps decrease as denominators grow. The distribution reveals how fractions cluster and spread across the unit interval.</p>
        </div>
        <div class="stat-grid" id="gapStats" style="margin-top:12px;"></div>
        <div class="grid-2" style="margin-top:15px;">
            <div class="chart-box chart-wrapper"><h4>Gap Distribution (Color = Size)</h4><canvas id="gapDistChart"></canvas></div>
            <div class="chart-box chart-wrapper"><h4>Gap vs Denominator Product</h4><canvas id="gapVsDenomChart"></canvas></div>
        </div>
        <div class="panel" style="margin-top:15px; background:#0f172a;">
            <h4>Largest Gaps <span style="font-weight:normal;color:#64748b;">(sorted by gap size)</span></h4>
            <div class="table-scroll">
                <table id="gapTable">
                    <thead><tr><th>#</th><th>Left Fraction</th><th>Right Fraction</th><th>Actual Gap</th><th>Theoretical 1/(bd)</th><th>Match</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        <div class="connection-box" style="margin-top:15px;">
            <strong>Key Insight:</strong> Every gap exactly equals 1/(bd) where b and d are the denominators of consecutive Farey fractions. This is a consequence of the mediant property: for neighbors a/b and c/d, we have |ad - bc| = 1.
        </div>
        <div style="margin-top:15px;"><button onclick="screenshotFullTab('gaps')">Screenshot Full Gaps Tab</button></div>
    </div>
    
    <!-- FRANEL-LANDAU TAB -->
    <div id="tab-franel" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #06b6d4;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Franel-Landau Theorem</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#06b6d4;">Σ|δ_k| = O(N^(1/2+ε)) ⟺ Riemann Hypothesis</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Define δ_k = F_k - k/|F_N| as the k-th Farey fraction deviation. The growth rate of Σ|δ_k| is directly equivalent to the Riemann Hypothesis. If RH is true, the sum grows slower than N^(1/2+ε) for any ε > 0. This provides a concrete computational test for RH properties through Farey sequence analysis. <strong style="color:#f87171;">Note: These computations illustrate known equivalences but do not constitute a proof or disproof of RH.</strong></p>
        </div>
        <div class="stat-grid" id="franelStats" style="margin-top:12px;"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Deviation δ_k vs k</h4><canvas id="franelDeviationChart"></canvas></div>
                <div class="chart-box"><h4>Cumulative |δ| / N^α</h4><canvas id="franelCumulativeChart"></canvas></div>
            </div>
            <div class="chart-box" style="margin-top:15px;"><h4>Σ|δ| / N^α for various α</h4><canvas id="franelAlphaChart"></canvas></div>
            <div class="derivation-box" style="margin-top:15px;"><strong>Interpretation:</strong> If RH is true, the normalized sum should stay bounded. Divergence for alpha <= 1/2 would contradict RH.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('franel')">Screenshot Full Franel Tab</button></div>
    </div>
    
    <!-- DEDEKIND TAB -->
    <div id="tab-dedekind" class="tab-content">
        <div class="panel" style="background:linear-gradient(135deg,#1e1b4b,#1e1b4b);border-left:4px solid #f59e0b;margin-bottom:20px;">
            <h3 style="color:#a78bfa;margin-top:0;">Dedekind Sums</h3>
            <div style="background:#0f172a;padding:15px;border-radius:6px;margin:12px 0;font-family:monospace;font-size:1.1em;text-align:center;color:#f59e0b;">s(h,k) = Σ_{j=1}^{k-1} ((j/k))((hj/k))</div>
            <p style="color:#94a3b8;margin:12px 0;font-size:0.9em;">Dedekind sums are arithmetic functions encoding properties of coprime pairs (h,k). They satisfy reciprocity formulas: s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk)). These sums connect to modular forms and are fundamental in algebraic number theory.</p>
        </div>
        <div class="panel">
            <h3>Dedekind Sums</h3>
            <div class="theorem-box"><strong>Definition:</strong> s(h,k) = Σ_{j=1}^{k-1} ((j/k))((hj/k)) where ((x)) = x - ⌊x⌋ - 1/2 if x∉ℤ, else 0</div>
            <div class="control-row" style="margin:12px 0;"><label>Max k: <input type="number" id="dedekindMaxK" value="20" min="2" onchange="computeDedekind()"></label></div>
            <div class="grid-2">
                <div class="chart-box"><h4>s(h,k) Heatmap</h4><canvas id="dedekindHeatmap" width="400" height="400"></canvas></div>
                <div class="chart-box"><h4>s(1,k) vs k</h4><canvas id="dedekindChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Dedekind Sum Table</h4><div class="table-scroll"><table id="dedekindTable"><thead><tr><th>h</th><th>k</th><th>s(h,k)</th><th>12k·s(h,k)</th><th>gcd</th></tr></thead><tbody></tbody></table></div></div>
            <div class="connection-box" style="margin-top:12px;"><strong>Reciprocity:</strong> s(h,k) + s(k,h) = -1/4 + (1/12)(h/k + k/h + 1/(hk))</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('dedekind')">Screenshot Full Dedekind Tab</button></div>
        </div>
    </div>
    
    <!-- CONTINUED FRACTIONS TAB -->
    <div id="tab-cf" class="tab-content">
        <div class="panel">
            <h3>Continued Fractions</h3>
            <div class="theorem-box"><strong>Stern-Brocot Encoding:</strong> Path L^a R^b L^c... encodes CF [0; a, b, c, ...]</div>
            <div class="control-row" style="margin:12px 0;"><label>Sector: <input type="number" id="cfSector" value="2" min="1" onchange="updateCFDisplay()"></label><label>Max terms: <input type="number" id="cfMaxTerms" value="50" onchange="updateCFDisplay()"></label></div>
            <div class="panel" style="background:#0f172a;"><h4>Continued Fraction Expansions</h4><div class="table-scroll"><table id="cfTable"><thead><tr><th>r/m</th><th>CF [a0; a1, a2, ...]</th><th>Path</th><th>Length</th><th>Sum(a_i)</th></tr></thead><tbody></tbody></table></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>CF Length Distribution</h4><canvas id="cfLengthChart"></canvas></div>
                <div class="chart-box"><h4>First Partial Quotient</h4><canvas id="cfFirstChart"></canvas></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('cf')">Screenshot Full CF Tab</button></div>
        </div>
    </div>
    
    <!-- PSL(2,Z) TAB -->
    <div id="tab-psl" class="tab-content">
        <div class="panel">
            <h3>PSL(2,ℤ) Matrices</h3>
            <div class="theorem-box"><strong>Farey Neighbor Property:</strong> For consecutive Farey fractions a/b, c/d: |ad - bc| = 1, giving matrix [a,c; b,d] ∈ SL(2,ℤ)</div>
            <div class="control-row" style="margin:12px 0;"><label>Max denom: <input type="number" id="pslMaxDenom" value="12" min="3" onchange="computePSL()"></label></div>
            <div class="panel" style="background:#0f172a;"><h4>Neighbor Matrices</h4><div id="pslMatrices" style="max-height:300px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Ford Circles</h4><canvas id="fordCanvas" width="500" height="250"></canvas></div>
                <div class="chart-box"><h4>Determinant Verification</h4><div id="pslVerification"></div></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('psl')">Screenshot Full PSL Tab</button></div>
        </div>
    </div>
    
    <!-- EULER PRODUCT TAB -->
    <div id="tab-euler" class="tab-content">
        <div class="panel">
            <h3>Euler Product for ζ(2)</h3>
            <div class="theorem-box"><strong>Euler:</strong> ζ(2) = Σ 1/n² = ∏_p 1/(1-1/p²) = π²/6, hence 6/π² = ∏_p (1-1/p²)</div>
            <div class="control-row" style="margin:12px 0;"><label>Primes up to: <input type="number" id="eulerMaxP" value="50" min="5" onchange="computeEulerProduct()"></label></div>
            <div class="stat-grid" id="eulerStats"></div>
            <div class="panel" style="margin-top:15px; background:#0f172a;"><h4>Product Terms</h4><div id="eulerTerms" style="max-height:200px; overflow-y:auto;"></div></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Partial Product → 6/π²</h4><canvas id="eulerProductChart"></canvas></div>
                <div class="chart-box"><h4>Partial Sum → π²/6</h4><canvas id="eulerSumChart"></canvas></div>
            </div>
            <div class="derivation-box" style="margin-top:12px;"><strong>Connection:</strong> The coprime probability 6/pi^2 emerges from excluding multiples of each prime p with probability 1/p^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('euler')">Screenshot Full Euler Tab</button></div>
        </div>
    </div>
    
    <!-- MODULAR TAB -->
    <div id="tab-modular" class="tab-content">
        <div class="panel">
            <h3>Modular Arithmetic Analysis</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Filter mod k: <input type="number" id="modK" value="6" min="2" onchange="updateModularAnalysis()"></label>
                <label>Residue a: <input type="number" id="modA" value="1" min="0" onchange="updateModularAnalysis()"></label>
                <button onclick="updateModularAnalysis()">Apply Filter</button>
            </div>
            <div class="stat-grid" id="modularStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Residue Class Distribution</h4><canvas id="residueClassChart"></canvas></div>
                <div class="chart-box"><h4>Prime Channel Ownership</h4><canvas id="primeChannelChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Lifting Tower: m → 2m, 3m, ...</h4>
                <div id="liftingDisplay"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('modular')">Screenshot Full Modular Tab</button></div>
        </div>
    </div>
    
    <!-- 3D VIEW TAB -->
    <div id="tab-3d" class="tab-content">
        <div class="panel">
            <h3>3D Sector Cone</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Rotate X: <input type="range" id="rot3dX" min="-90" max="90" value="30" onchange="draw3D()"></label>
                <label>Rotate Z: <input type="range" id="rot3dZ" min="0" max="360" value="45" onchange="draw3D()"></label>
                <label>Perspective: <input type="range" id="perspective3d" min="100" max="1000" value="500" onchange="draw3D()"></label>
            </div>
            <div style="text-align:center;"><canvas id="canvas3d" class="ring-canvas" width="700" height="600"></canvas></div>
            <div class="derivation-box" style="margin-top:12px;">Third axis represents denominator m. Points at height m have coprime numerators r with r/m in the sector range. The cone structure shows density increasing with m^2.</div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('3d')">Screenshot Full 3D Tab</button></div>
        </div>
    </div>
    
    <!-- HYPERBOLIC TAB -->
    <div id="tab-hyperbolic" class="tab-content">
        <div class="panel">
            <h3>Hyperbolic Plane / Poincaré Disk</h3>
            <div class="theorem-box"><strong>Farey Tessellation:</strong> The hyperbolic plane is tessellated by ideal triangles with vertices at Farey fractions on ∂H.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Max denom: <input type="number" id="hypMaxDenom" value="15" min="3" onchange="drawHyperbolic()"></label>
                <label>Highlight sector: <input type="number" id="hypSector" value="2" min="1" onchange="drawHyperbolic()"></label>
            </div>
            <div style="text-align:center;"><canvas id="hypCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('hyperbolic')">Screenshot Full Hyperbolic Tab</button></div>
        </div>
    </div>
    
    <!-- ANIMATION TAB -->
    <div id="tab-animation" class="tab-content">
        <div class="panel">
            <h3>Farey Sequence Growth</h3>
            <div class="control-row" style="margin:12px 0;">
                <label>Animate to N: <input type="number" id="animMaxN" value="50" min="5"></label>
                <label>Speed (ms): <input type="number" id="animSpeed" value="200" min="50"></label>
                <button onclick="startAnimation()">Start</button>
                <button class="secondary" onclick="stopAnimation()">Stop</button>
                <span id="animStatus" class="info-badge">Ready</span>
            </div>
            <div style="text-align:center;"><canvas id="animCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div class="stat-grid" id="animStats" style="margin-top:12px;"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('animation')">Screenshot Full Animation Tab</button></div>
        </div>
    </div>
    
    <!-- SMITH CHART TAB -->
    <div id="tab-smith" class="tab-content">
        <div class="panel">
            <h3>Smith Chart Transform</h3>
            <div class="theorem-box"><strong>Transform:</strong> Map x ∈ (0,1) to Smith chart via Γ = (Z-1)/(Z+1) where Z relates to the fraction value.</div>
            <div class="control-row" style="margin:12px 0;">
                <label>Sector: <input type="number" id="smithSector" value="2" min="1" onchange="drawSmithChart()"></label>
                <label><input type="checkbox" id="smithShowGrid" checked onchange="drawSmithChart()"> Grid</label>
            </div>
            <div style="text-align:center;"><canvas id="smithCanvas" class="ring-canvas" width="650" height="650"></canvas></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('smith')">Screenshot Full Smith Tab</button></div>
        </div>
    </div>
    
    <!-- STATISTICS TAB -->
    <div id="tab-stats" class="tab-content">
        <div class="panel">
            <h3>Statistical Analysis</h3>
            <div class="grid-2">
                <div class="chart-box"><h4>Random vs Actual Distribution</h4><canvas id="randomCompareChart"></canvas></div>
                <div class="chart-box"><h4>Cross-Sector Correlation</h4><canvas id="correlationChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Error Term O(N log N)</h4><canvas id="errorTermChart"></canvas></div>
                <div class="chart-box"><h4>Local Density Analysis</h4><canvas id="localDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Correlation Matrix</h4>
                <div id="correlationMatrix"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('stats')">Screenshot Full Statistics Tab</button></div>
        </div>
    </div>
    
    <!-- PRIMES TAB -->
    <div id="tab-primes" class="tab-content">
        <div class="panel">
            <h3>Prime Analysis</h3>
            <div class="stat-grid" id="primeStats"></div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Twin Prime Gap Markers</h4><canvas id="twinPrimeChart"></canvas></div>
                <div class="chart-box"><h4>Prime vs Composite Moduli</h4><canvas id="primeVsCompositeChart"></canvas></div>
            </div>
            <div class="grid-2" style="margin-top:15px;">
                <div class="chart-box"><h4>Prime k-tuple Correlations</h4><canvas id="ktupleChart"></canvas></div>
                <div class="chart-box"><h4>Prime Denominator Density</h4><canvas id="primeDenomDensityChart"></canvas></div>
            </div>
            <div class="panel" style="margin-top:15px; background:#0f172a;">
                <h4>Twin Prime Gaps in Farey Sequence</h4>
                <div id="twinPrimeList" class="residue-list"></div>
            </div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('primes')">Screenshot Full Primes Tab</button></div>
        </div>
    </div>
    
    <!-- RESEARCH TAB -->
    <div id="tab-research" class="tab-content">
        <div class="panel">
            <h3>Research Tools</h3>
            
            <h4>Custom Formula Tester</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>Formula C(n,N) = </label>
                <input type="text" id="customFormula" value="3*N*N/(Math.PI*Math.PI*n*(n+1))" style="width:300px;">
                <button onclick="testCustomFormula()">Test</button>
            </div>
            <div class="chart-box" style="margin-top:12px;"><h4>Custom vs Standard</h4><canvas id="customFormulaChart"></canvas></div>
            
            <h4 style="margin-top:20px;">Batch Parameter Sweep</h4>
            <div class="control-row" style="margin:12px 0;">
                <label>N range: <input type="number" id="batchNMin" value="50"> to <input type="number" id="batchNMax" value="200"> step <input type="number" id="batchNStep" value="10"></label>
                <button onclick="runBatchSweep()">Run Sweep</button>
            </div>
            <div class="table-scroll" style="margin-top:12px;"><table id="batchTable"><thead><tr><th>N</th><th>|F_N|</th><th>Σ|δ|</th><th>Σ|δ|/√N</th><th>Max Gap</th><th>Mean Gap</th></tr></thead><tbody></tbody></table></div>
            
            <h4 style="margin-top:20px;">Publication Export</h4>
            <div class="control-row" style="margin:12px 0;">
                <button onclick="exportLatexFigures()">LaTeX Figures</button>
                <button onclick="exportCSVAll()">Full CSV</button>
                <button onclick="exportJSON()">JSON Data</button>
            </div>
            <div class="latex-output" id="latexFigures"></div>
            <div style="margin-top:15px;"><button onclick="screenshotFullTab('research')">Screenshot Full Research Tab</button></div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="pointModal"><div class="modal-content" style="max-width:450px;"><div class="modal-header"><h3 id="pointModalTitle">Point</h3><button class="modal-close" onclick="closePointModal()">x</button></div><div class="modal-body" id="pointModalBody"></div></div></div>

<div class="modal-overlay" id="sectorModal"><div class="modal-content" style="max-width:700px;"><div class="modal-header"><h3 id="sectorModalTitle">Sector Details</h3><button class="modal-close" onclick="closeSectorModal()">x</button></div><div class="modal-body" id="sectorModalBody"></div></div></div>

<div class="screenshot-overlay" id="screenshotOverlay">
    <h3 style="color:#f1f5f9; margin-bottom:20px;">Screenshot Preview (with Legend)</h3>
    <img id="screenshotPreview" class="screenshot-preview">
    <div class="screenshot-actions">
        <button onclick="downloadScreenshot()">Download PNG</button>
        <button onclick="copyScreenshot()">Copy to Clipboard</button>
        <button class="secondary" onclick="closeScreenshotOverlay()">Close</button>
    </div>
</div>

<script>
const state = {
    mode: 'exact', nMin: 100, nMax: 100, sectorMin: 1, sectorMax: 15,
    sectors: [], residuesBySector: {}, allResidues: [], gaps: [], farey: [],
    computing: false, charts: {}, ringPoints: [], animationId: null
};

const sectorColors = ['#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899','#f43f5e','#ef4444','#f97316','#f59e0b','#eab308','#84cc16','#22c55e','#10b981','#14b8a6','#06b6d4','#0ea5e9','#3b82f6'];
function getSectorColor(n) { return sectorColors[(n-1) % sectorColors.length]; }

// Canvas state
let currentScreenshotData = null;

function downloadScreenshot() {
    if (!currentScreenshotData) return;
    const a = document.createElement('a');
    a.href = currentScreenshotData;
    a.download = 'farey_chart_' + Date.now() + '.png';
    a.click();
}

async function copyScreenshot() {
    if (!currentScreenshotData) return;
    try {
        const blob = await (await fetch(currentScreenshotData)).blob();
        await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
        alert('Copied to clipboard!');
    } catch (e) {
        alert('Copy failed: ' + e.message);
    }
}

function closeScreenshotOverlay() {
    document.getElementById('screenshotOverlay').classList.remove('active');
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = 'Sector ' + n + ': (1/' + (n+1) + ', 1/' + n + ']';
    
    let primesHtml = primes.length > 0 
        ? primes.map(p => '<span class="residue-item prime" title="m=' + p.m + ' is prime">' + p.r + '/' + p.m + '</span>').join('') 
        : '<span style="color:#64748b">No prime moduli in this sector</span>';
    
    let compositesHtml = composites.length > 0 
        ? composites.slice(0,100).map(c => '<span class="residue-item">' + c.r + '/' + c.m + '</span>').join('') 
        : '<span style="color:#64748b">No composite moduli in this sector</span>';
    
    if (composites.length > 100) {
        compositesHtml += '<span style="color:#64748b; display:block; margin-top:8px;">... and ' + (composites.length - 100) + ' more</span>';
    }
    
    let html = '<div class="stat-grid" style="margin-bottom:15px;">' +
        '<div class="stat-card"><div class="stat-value">' + res.length + '</div><div class="stat-label">Total Pairs</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#f59e0b">' + primes.length + '</div><div class="stat-label">Prime Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#6366f1">' + composites.length + '</div><div class="stat-label">Composite Moduli</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector ? fmt(sector.predicted) : '-') + '</div><div class="stat-label">Predicted</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + (sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-') + '</div><div class="stat-label">Error</div></div>' +
        '</div>' +
        '<h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (' + primes.length + ')</h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(245,158,11,0.3);">' + primesHtml + '</div>' +
        '<h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (' + composites.length + ') <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>' +
        '<div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid rgba(99,102,241,0.3);">' + compositesHtml + '</div>' +
        '<div style="margin-top:15px; display:flex; gap:10px;">' +
        '<button onclick="exportSectorData(' + n + ')">Export Sector CSV</button>' +
        '<button class="secondary" onclick="viewSectorOnRing(' + n + ')">View on Ring</button>' +
        '</div>';
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += r.r + ',' + r.m + ',' + r.value + ',' + r.isPrime + '\n';
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'sector_' + n + '_data.csv';
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

function screenshotFullTab(tabName) {
    const tabElement = document.getElementById('tab-' + tabName);
    if (!tabElement) { alert('Tab not found'); return; }
    
    const canvases = tabElement.querySelectorAll('canvas');
    const statGrids = tabElement.querySelectorAll('.stat-grid');
    const tables = tabElement.querySelectorAll('table');
    const panels = tabElement.querySelectorAll('.panel');
    
    const padding = 40;
    const titleHeight = 60;
    const statsHeight = statGrids.length > 0 ? 90 : 0;
    
    // Calculate canvas section height
    let canvasRows = Math.ceil(canvases.length / 2);
    let canvasSectionHeight = canvasRows * 320;
    
    // Calculate table height
    let tableHeight = 0;
    tables.forEach(t => {
        const rows = Math.min(t.querySelectorAll('tbody tr').length, 15);
        tableHeight += rows * 22 + 50;
    });
    tableHeight = Math.min(tableHeight, 400);
    
    const totalWidth = 900;
    const totalHeight = titleHeight + statsHeight + canvasSectionHeight + tableHeight + padding * 3;
    
    const composite = document.createElement('canvas');
    composite.width = totalWidth * 2;
    composite.height = totalHeight * 2;
    const ctx = composite.getContext('2d');
    ctx.scale(2, 2);
    
    // Background
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, totalWidth, totalHeight);
    
    let currentY = padding;
    
    // Title
    const tabTitle = {
        'main': 'Main Analysis',
        'theory': 'Theory',
        'theoryviz': 'Theory Visualization',
        'gaps': 'Gap Analysis',
        'franel': 'Franel-Landau Analysis',
        'dedekind': 'Dedekind Sums',
        'cf': 'Continued Fractions',
        'psl': 'PSL(2,Z) Matrices',
        'euler': 'Euler Product',
        'modular': 'Modular Arithmetic',
        '3d': '3D View',
        'hyperbolic': 'Hyperbolic Plane',
        'animation': 'Animation',
        'smith': 'Smith Chart',
        'stats': 'Statistics',
        'primes': 'Prime Analysis',
        'research': 'Research Tools'
    }[tabName] || tabName;
    
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 20px system-ui';
    ctx.fillText('Farey Sector - ' + tabTitle, padding, currentY + 25);
    ctx.font = '11px system-ui';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText('N = ' + state.nMax + ' | Sectors ' + state.sectorMin + '-' + state.sectorMax + ' | ' + new Date().toLocaleString(), padding, currentY + 45);
    currentY += titleHeight;
    
    // Stats
    if (statGrids.length > 0) {
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(padding, currentY, totalWidth - padding * 2, statsHeight - 20);
        ctx.strokeStyle = '#334155';
        ctx.strokeRect(padding, currentY, totalWidth - padding * 2, statsHeight - 20);
        
        const statCards = statGrids[0].querySelectorAll('.stat-card');
        const statWidth = (totalWidth - padding * 2) / Math.min(statCards.length, 6);
        
        statCards.forEach((card, i) => {
            if (i >= 6) return;
            const x = padding + i * statWidth + statWidth / 2;
            const label = card.querySelector('.stat-label');
            const value = card.querySelector('.stat-value');
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '10px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(label ? label.textContent : '', x, currentY + 25);
            
            const valueEl = card.querySelector('.stat-value');
            ctx.fillStyle = valueEl && valueEl.style.color ? valueEl.style.color : '#6366f1';
            ctx.font = 'bold 16px system-ui';
            ctx.fillText(value ? value.textContent : '', x, currentY + 50);
        });
        ctx.textAlign = 'left';
        currentY += statsHeight;
    }
    
    // Canvases - 2 per row
    const canvasWidth = (totalWidth - padding * 3) / 2;
    const canvasHeight = 280;
    
    canvases.forEach((canvas, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = padding + col * (canvasWidth + padding);
        const y = currentY + row * (canvasHeight + 30);
        
        // Get title from parent chart-box
        const chartBox = canvas.closest('.chart-box');
        const title = chartBox ? (chartBox.querySelector('h4') ? chartBox.querySelector('h4').textContent : 'Chart') : 'Chart';
        
        // Background
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(x, y, canvasWidth, canvasHeight);
        ctx.strokeStyle = '#334155';
        ctx.strokeRect(x, y, canvasWidth, canvasHeight);
        
        // Title
        ctx.fillStyle = '#cbd5e1';
        ctx.font = 'bold 11px system-ui';
        ctx.fillText(title, x + 10, y + 18);
        
        // Draw canvas scaled
        const scale = Math.min((canvasWidth - 20) / canvas.width, (canvasHeight - 40) / canvas.height);
        const drawWidth = canvas.width * scale;
        const drawHeight = canvas.height * scale;
        const drawX = x + (canvasWidth - drawWidth) / 2;
        const drawY = y + 25 + (canvasHeight - 35 - drawHeight) / 2;
        
        try {
            ctx.drawImage(canvas, drawX, drawY, drawWidth, drawHeight);
        } catch (e) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('Canvas render error', drawX + 20, drawY + 50);
        }
        
        // Legend from chart-box
        const legend = chartBox ? chartBox.querySelector('.color-legend') : null;
        if (legend) {
            const items = legend.querySelectorAll('.color-legend-item');
            let legendX = x + 10;
            const legendY = y + canvasHeight - 18;
            
            items.forEach(item => {
                if (legendX > x + canvasWidth - 50) return;
                const swatch = item.querySelector('.color-swatch');
                const text = item.textContent.trim().substring(0, 15);
                
                if (swatch) {
                    ctx.fillStyle = swatch.style.background || '#6366f1';
                    ctx.fillRect(legendX, legendY - 6, 8, 8);
                    legendX += 10;
                }
                ctx.fillStyle = '#94a3b8';
                ctx.font = '8px system-ui';
                ctx.fillText(text, legendX, legendY);
                legendX += ctx.measureText(text).width + 12;
            });
        }
    });
    
    currentY += canvasRows * (canvasHeight + 30) + 10;
    
    // Tables
    if (tables.length > 0 && currentY < totalHeight - 100) {
        const table = tables[0];
        const headers = table.querySelectorAll('thead th');
        const rows = table.querySelectorAll('tbody tr');
        
        ctx.fillStyle = '#f1f5f9';
        ctx.font = 'bold 11px system-ui';
        ctx.fillText('Data Table', padding, currentY + 15);
        currentY += 25;
        
        // Header
        ctx.fillStyle = '#334155';
        ctx.fillRect(padding, currentY, totalWidth - padding * 2, 20);
        
        const colWidth = (totalWidth - padding * 2) / Math.max(headers.length, 1);
        ctx.fillStyle = '#e2e8f0';
        ctx.font = 'bold 9px system-ui';
        headers.forEach((h, i) => {
            ctx.fillText(h.textContent.substring(0, 12), padding + 5 + i * colWidth, currentY + 14);
        });
        currentY += 20;
        
        // Rows
        ctx.font = '9px system-ui';
        const maxRows = Math.min(rows.length, 10);
        for (let r = 0; r < maxRows; r++) {
            const row = rows[r];
            const cells = row.querySelectorAll('td');
            
            if (r % 2 === 0) {
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(padding, currentY, totalWidth - padding * 2, 18);
            }
            
            cells.forEach((cell, i) => {
                ctx.fillStyle = cell.style.color || '#e2e8f0';
                ctx.fillText(cell.textContent.substring(0, 15), padding + 5 + i * colWidth, currentY + 13);
            });
            currentY += 18;
        }
        
        if (rows.length > maxRows) {
            ctx.fillStyle = '#64748b';
            ctx.fillText('... and ' + (rows.length - maxRows) + ' more rows', padding + 5, currentY + 13);
        }
    }
    
    // Footer
    ctx.fillStyle = '#64748b';
    ctx.font = '9px system-ui';
    ctx.fillText('Farey Sector Research Platform | @7dview | wessengetachew.github.io', padding, totalHeight - 12);
    
    currentScreenshotData = composite.toDataURL('image/png');
    document.getElementById('screenshotPreview').src = currentScreenshotData;
    document.getElementById('screenshotOverlay').classList.add('active');
}

// Utilities
function gcd(a, b) { while(b) { [a,b] = [b, a%b]; } return a; }
function isPrime(n) { if(n<2) return false; if(n===2) return true; if(n%2===0) return false; for(let i=3;i*i<=n;i+=2) if(n%i===0) return false; return true; }
function mobius(n) { if(n===1) return 1; let c=0; for(let p=2;p*p<=n;p++) { if(n%p===0) { if(n%(p*p)===0) return 0; c++; n/=p; } } if(n>1) c++; return c%2===0?1:-1; }
function getSector(r,m) { const f=r/m; if(f<=0||f>1) return null; return Math.floor(1/f); }
function formula(n,N) { return (3*N*N)/(Math.PI*Math.PI*n*(n+1)); }
function fmt(x) { if(x>=1e9) return (x/1e9).toFixed(1)+'B'; if(x>=1e6) return (x/1e6).toFixed(1)+'M'; if(x>=1e3) return (x/1e3).toFixed(1)+'K'; return x.toFixed(x<10?2:0); }

// Continued fraction
function toCF(r, m) {
    const cf = [];
    while(m !== 0) { const q = Math.floor(r/m); cf.push(q); [r,m] = [m, r - q*m]; }
    return cf;
}
function cfPath(cf) {
    let path = '';
    for(let i=0; i<cf.length; i++) { path += (i%2===0?'R':'L').repeat(cf[i]); }
    return path;
}

// Dedekind sum
function sawtoothSum(h, k) {
    let s = 0;
    for(let j=1; j<k; j++) {
        const jk = j/k, hjk = (h*j/k) % 1;
        const s1 = jk - Math.floor(jk) - 0.5;
        const s2 = hjk - Math.floor(hjk) - 0.5;
        s += s1 * s2;
    }
    return s;
}

function setMode(mode) {
    state.mode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('mode-'+mode).classList.add('active');
    document.getElementById('modeDescription').textContent = {exact:'Exact enumeration',hybrid:'Hybrid mode',formula:'Formula only'}[mode];
}

async function computeAll() {
    if(state.computing) return;
    state.computing = true;
    state.nMin = +document.getElementById('nMin').value;
    state.nMax = +document.getElementById('nMax').value;
    state.sectorMin = +document.getElementById('sectorMin').value;
    state.sectorMax = +document.getElementById('sectorMax').value;
    
    document.getElementById('progressBar').style.display = 'block';
    document.getElementById('statusArea').innerHTML = '<span class="info-badge">Computing...</span>';
    
    state.sectors = []; state.residuesBySector = {}; state.allResidues = []; state.gaps = []; state.farey = [];
    
    const N = state.nMax;
    if(state.mode !== 'formula' && N <= 1500) {
        await computeExact(N);
    } else {
        computeFormulaOnly();
    }
    
    computeGaps();
    updateAllDisplays();
    
    document.getElementById('progressBar').style.display = 'none';
    document.getElementById('statusArea').innerHTML = '<span class="info-badge success">Done</span>';
    state.computing = false;
}

async function computeExact(N) {
    let ops = 0;
    for(let m=2; m<=N; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const s = getSector(r,m);
                const res = {r, m, sector:s, isPrime:isPrime(m), value:r/m};
                state.allResidues.push(res);
                if(s && s>=state.sectorMin && s<=state.sectorMax) {
                    if(!state.residuesBySector[s]) state.residuesBySector[s] = [];
                    state.residuesBySector[s].push(res);
                }
            }
        }
        ops += m;
        if(m%50===0) { document.getElementById('progressFill').style.width = (m/N*100)+'%'; await new Promise(r=>setTimeout(r,0)); }
        if(!state.computing) return;
    }
    state.allResidues.sort((a,b) => a.value - b.value);
    state.farey = state.allResidues.map(r => ({r:r.r, m:r.m, value:r.value}));
    
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        const res = state.residuesBySector[n] || [];
        const exact = res.length, pred = formula(n,N);
        const primeCount = res.filter(x=>x.isPrime).length;
        state.sectors.push({n, exact, predicted:pred, error:exact-pred, relError:exact>0?((exact-pred)/exact)*100:0, width:1/(n*(n+1)), primeCount});
    }
}

function computeFormulaOnly() {
    for(let n=state.sectorMin; n<=state.sectorMax; n++) {
        state.sectors.push({n, exact:null, predicted:formula(n,state.nMax), error:null, relError:null, width:1/(n*(n+1)), primeCount:null});
    }
}

function computeGaps() {
    state.gaps = [];
    for(let i=0; i<state.allResidues.length-1; i++) {
        const l = state.allResidues[i], r = state.allResidues[i+1];
        const gap = r.value - l.value;
        state.gaps.push({left:l, right:r, gap, theoretical:1/(l.m*r.m), denomProduct:l.m*r.m, sector:l.sector});
        state.allResidues[i].gapRight = gap;
    }
    state.gaps.sort((a,b) => b.gap - a.gap);
}

function cancelComputation() { state.computing = false; }

function updateAllDisplays() {
    updateMainStats(); updateMainCharts(); updateMainTable(); drawMainRing(); drawSectorTree();
    drawTheoryViz();
    updateGapAnalysis(); computeFranel(); computeDedekind(); updateCFDisplay();
    computePSL(); computeEulerProduct(); updateModularAnalysis(); draw3D();
    drawHyperbolic(); drawSmithChart(); updateStatistics(); updatePrimeAnalysis();
}

// THEORY VIZ FUNCTIONS
function phi(n) { let r=0; for(let i=1; i<n; i++) if(gcd(i,n)===1) r++; return r; }

function drawTheoryViz() {
    drawSectorPartition();
    drawDensityCone();
    drawTotientSum();
    drawLatticeViz();
    drawProofSteps();
    drawConvergenceAnalysis();
    drawDensityHeatmap();
}

function drawSectorPartition() {
    const canvas = document.getElementById('sectorPartitionCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxSectors = +(document.getElementById('tvMaxSectors')?.value || 8);
    const showValues = document.getElementById('tvShowSectorValues')?.checked ?? true;
    const showWidths = document.getElementById('tvShowSectorWidths')?.checked ?? false;
    const style = document.getElementById('tvPartitionStyle')?.value || 'bar';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 50, barH = 40;
    const centerY = H/2;
    
    let legendHtml = '';
    
    if (style === 'arc') {
        // Arc/pie style
        const cx = W/2, cy = H/2, radius = Math.min(W,H)/2 - 60;
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, 2*Math.PI); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const a1 = left * 2 * Math.PI - Math.PI/2;
            const a2 = right * 2 * Math.PI - Math.PI/2;
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, a1, a2);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.stroke();
            
            if (showValues && n <= 6) {
                const midAngle = (a1 + a2) / 2;
                const labelR = radius * 0.7;
                ctx.fillStyle = '#e2e8f0';
                ctx.font = 'bold 11px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`S${n}`, cx + Math.cos(midAngle)*labelR, cy + Math.sin(midAngle)*labelR + 4);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else if (style === 'number') {
        // Number line style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        // Tick marks
        for (let i = 0; i <= 10; i++) {
            const x = margin + (i/10) * (W - 2*margin);
            ctx.beginPath(); ctx.moveTo(x, centerY - 10); ctx.lineTo(x, centerY + 10); ctx.stroke();
            ctx.fillStyle = '#94a3b8'; ctx.font = '10px system-ui'; ctx.textAlign = 'center';
            ctx.fillText((i/10).toFixed(1), x, centerY + 25);
        }
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color;
            ctx.fillRect(x1, centerY - 5, x2 - x1, 10);
            
            if (showValues && x2-x1 > 20) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = '9px system-ui';
                ctx.fillText(`S${n}`, (x1+x2)/2, centerY - 15);
            }
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}</div>`;
        }
    } else {
        // Default bar style
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(margin, centerY); ctx.lineTo(W-margin, centerY); ctx.stroke();
        
        for (let n = 1; n <= maxSectors; n++) {
            const left = 1/(n+1), right = 1/n;
            const x1 = margin + left * (W - 2*margin);
            const x2 = margin + right * (W - 2*margin);
            const color = sectorColors[(n-1) % sectorColors.length];
            
            ctx.fillStyle = color + '60';
            ctx.fillRect(x1, centerY - barH, x2 - x1, barH * 2);
            ctx.strokeStyle = color; ctx.lineWidth = 1;
            ctx.strokeRect(x1, centerY - barH, x2 - x1, barH * 2);
            
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 11px system-ui';
            ctx.textAlign = 'center';
            if(x2-x1 > 25) ctx.fillText(`S${n}`, (x1+x2)/2, centerY + 4);
            
            ctx.fillStyle = '#94a3b8';
            ctx.font = '9px system-ui';
            ctx.fillText(`1/${n+1}`, x1, centerY + barH + 18);
            
            if (showWidths && x2-x1 > 30) {
                const width = 1/(n*(n+1));
                ctx.fillStyle = '#64748b';
                ctx.font = '8px system-ui';
                ctx.fillText(`w=${width.toFixed(3)}`, (x1+x2)/2, centerY + barH + 35);
            }
            
            legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>S${n}=(1/${n+1},1/${n}]</div>`;
        }
        
        ctx.fillStyle = '#f1f5f9';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('0', margin - 12, centerY + barH + 18);
        ctx.textAlign = 'right';
        ctx.fillText('1', W - margin + 12, centerY + barH + 18);
    }
    
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Farey Sectors Partition (0,1]', W/2, 25);
    
    document.getElementById('sectorPartitionLegend').innerHTML = legendHtml;
}

function drawDensityCone() {
    const canvas = document.getElementById('densityConeCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const numSectors = +(document.getElementById('tvConeSectors')?.value || 4);
    const showRef = document.getElementById('tvShowConeRef')?.checked ?? true;
    const logScale = document.getElementById('tvLogScale')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:55, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    const maxY = formula(1, maxN);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY * i / 4), margin.l - 5, y + 3);
    }
    
    let legendHtml = '';
    for (let n = 1; n <= numSectors; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let N = 10; N <= maxN; N += 3) {
            const C = formula(n, N);
            const x = margin.l + (N / maxN) * plotW;
            const yVal = logScale ? Math.log(C + 1) / Math.log(maxY + 1) : C / maxY;
            const y = margin.t + plotH - yVal * plotH;
            N === 10 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.font = '10px system-ui';
        const labelY = margin.t + plotH - (formula(n, maxN) / maxY) * plotH;
        ctx.fillText(`n=${n}`, W - margin.r - 30, Math.max(margin.t + 15, labelY + 4));
        
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    if (showRef) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        ctx.beginPath();
        const refY = margin.t + plotH * 0.4;
        ctx.moveTo(margin.l, refY);
        ctx.lineTo(W - margin.r, refY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.fillText('6/π² ref', W - margin.r - 35, refY - 5);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>6/π²</div>`;
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N →', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('C(n,N) →', 0, 0);
    ctx.restore();
    
    document.getElementById('densityConeLegend').innerHTML = legendHtml;
}

function drawTotientSum() {
    const canvas = document.getElementById('totientSumCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const showActual = document.getElementById('tvShowTotientActual')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowTotientPredicted')?.checked ?? true;
    const showError = document.getElementById('tvShowTotientError')?.checked ?? false;
    const fill = document.getElementById('tvTotientFill')?.checked ?? false;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:65, r:20, t:20, b:40};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumPhi = 0;
    const data = [];
    for (let b = 1; b <= maxN; b++) {
        cumPhi += phi(b);
        data.push({b, cumPhi, predicted: 3*b*b/(Math.PI*Math.PI)});
    }
    
    const maxY = data[data.length-1].cumPhi;
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        ctx.fillText(fmt(maxY*i/4), margin.l - 5, y+3);
    }
    
    if (showActual) {
        if (fill) {
            ctx.fillStyle = 'rgba(99, 102, 241, 0.2)';
            ctx.beginPath();
            ctx.moveTo(margin.l, margin.t + plotH);
            data.forEach((d, i) => {
                const x = margin.l + (d.b / maxN) * plotW;
                const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
                ctx.lineTo(x, y);
            });
            ctx.lineTo(margin.l + plotW, margin.t + plotH);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.cumPhi / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    if (showError) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const maxErr = Math.max(...data.map(d => Math.abs(d.cumPhi - d.predicted)));
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxN) * plotW;
            const err = Math.abs(d.cumPhi - d.predicted) / maxErr;
            const y = margin.t + plotH - err * plotH * 0.3;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('b →', W/2, H - 10);
}

function drawLatticeViz() {
    const canvas = document.getElementById('latticeVizCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const maxB = +(document.getElementById('tvLatticeSize')?.value || 22);
    const highlightSector = +(document.getElementById('tvHighlightSector')?.value || 2);
    const showHidden = document.getElementById('tvShowHidden')?.checked ?? true;
    const showSectorLines = document.getElementById('tvShowSectorLines')?.checked ?? true;
    const colorBySector = document.getElementById('tvColorBySector')?.checked ?? false;
    const pointSize = +(document.getElementById('tvPointSize')?.value || 4);
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = 45;
    const scale = (Math.min(W, H) - 2*margin) / maxB;
    
    // Draw sector boundary lines first
    if (showSectorLines) {
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.setLineDash([5,5]);
        
        // Lines for highlighted sector boundaries
        const leftSlope = 1/(highlightSector+1);
        const rightSlope = 1/highlightSector;
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * leftSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(margin, H - margin);
        ctx.lineTo(margin + maxB * rightSlope * scale, H - margin - maxB * scale);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    for (let b = 1; b <= maxB; b++) {
        for (let a = 1; a <= b; a++) {
            const x = margin + a * scale;
            const y = H - margin - b * scale;
            
            const visible = gcd(a, b) === 1;
            
            if (!visible && !showHidden) continue;
            
            let color;
            if (!visible) {
                color = '#334155';
            } else if (colorBySector) {
                const sector = getSector(a, b);
                color = sector ? getSectorColor(sector) : '#6366f1';
            } else {
                color = '#6366f1';
            }
            
            // Highlight points in selected sector
            const inSector = visible && a/b > 1/(highlightSector+1) && a/b <= 1/highlightSector;
            
            ctx.fillStyle = inSector ? '#22c55e' : color;
            ctx.beginPath();
            ctx.arc(x, y, visible ? pointSize : pointSize/2, 0, 2*Math.PI);
            ctx.fill();
        }
    }
    
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin, margin);
    ctx.lineTo(margin, H - margin);
    ctx.lineTo(W - margin, H - margin);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('a →', W/2, H - 10);
    ctx.save();
    ctx.translate(15, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('b →', 0, 0);
    ctx.restore();
    
    // Sector label
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector ${highlightSector} highlighted`, W/2, 20);
}

function drawProofSteps() {
    const canvas = document.getElementById('proofStepsCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const n = +(document.getElementById('tvProofSector')?.value || 2);
    const maxB = +(document.getElementById('tvMaxN')?.value || 100);
    const showContrib = document.getElementById('tvShowContribBars')?.checked ?? true;
    const showPredicted = document.getElementById('tvShowProofPredicted')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:25, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    let cumCount = 0;
    const data = [];
    for (let b = 2; b <= maxB; b++) {
        const sectorRes = (state.residuesBySector[n]||[]).filter(r => r.m === b).length;
        const contrib = sectorRes > 0 ? sectorRes : Math.round(phi(b) / (n * (n+1)));
        cumCount += contrib;
        data.push({b, cumCount, predicted: formula(n, b), contrib});
    }
    
    const maxY = Math.max(data[data.length-1].cumCount, data[data.length-1].predicted);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
    }
    
    if (showContrib) {
        ctx.fillStyle = '#f59e0b30';
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const h = (d.contrib / maxY) * plotH * 3;
            ctx.fillRect(x - 2, margin.t + plotH - h, 4, h);
        });
    }
    
    ctx.strokeStyle = '#8b5cf6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
        const x = margin.l + (d.b / maxB) * plotW;
        const y = margin.t + plotH - (d.cumCount / maxY) * plotH;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    if (showPredicted) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        data.forEach((d, i) => {
            const x = margin.l + (d.b / maxB) * plotW;
            const y = margin.t + plotH - (d.predicted / maxY) * plotH;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Denominator b →', W/2, H - 10);
    
    ctx.fillStyle = '#8b5cf6';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(`Sector n=${n}`, W/2, 18);
}

function drawConvergenceAnalysis() {
    const canvas = document.getElementById('convergenceCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const analysisType = document.getElementById('tvConvergenceType')?.value || 'relative';
    const showTrend = document.getElementById('tvShowConvergenceTrend')?.checked ?? true;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:30, t:30, b:45};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate convergence data for multiple N values
    const data = [];
    for (let N = 20; N <= 200; N += 10) {
        const sectorData = [];
        for (let n = 1; n <= 5; n++) {
            // Simulate exact count based on formula with random error
            const predicted = formula(n, N);
            const exactEstimate = predicted + (Math.random() - 0.5) * Math.sqrt(N) * 2;
            
            let value;
            if (analysisType === 'relative') {
                value = ((exactEstimate - predicted) / predicted) * 100;
            } else if (analysisType === 'absolute') {
                value = exactEstimate - predicted;
            } else {
                value = exactEstimate / predicted;
            }
            sectorData.push({n, value});
        }
        data.push({N, sectors: sectorData});
    }
    
    // Find y-axis range
    let minY = Infinity, maxY = -Infinity;
    data.forEach(d => {
        d.sectors.forEach(s => {
            if (s.value < minY) minY = s.value;
            if (s.value > maxY) maxY = s.value;
        });
    });
    const yRange = maxY - minY || 1;
    
    // Grid
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
    for(let i=0; i<=4; i++) {
        const y = margin.t + plotH - (i/4)*plotH;
        ctx.beginPath(); ctx.moveTo(margin.l, y); ctx.lineTo(W-margin.r, y); ctx.stroke();
        ctx.fillStyle = '#64748b'; ctx.font = '9px system-ui'; ctx.textAlign = 'right';
        const label = minY + (i/4) * yRange;
        ctx.fillText(label.toFixed(analysisType === 'ratio' ? 2 : 1), margin.l - 5, y + 3);
    }
    
    // Draw lines for each sector
    let legendHtml = '';
    for (let n = 1; n <= 5; n++) {
        const color = sectorColors[(n-1) % sectorColors.length];
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        data.forEach((d, i) => {
            const sectorData = d.sectors.find(s => s.n === n);
            if (sectorData) {
                const x = margin.l + (i / (data.length - 1)) * plotW;
                const y = margin.t + plotH - ((sectorData.value - minY) / yRange) * plotH;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:${color}"></div>n=${n}</div>`;
    }
    
    // Trend line (zero for relative/absolute, 1 for ratio)
    if (showTrend) {
        ctx.strokeStyle = '#22c55e';
        ctx.setLineDash([5,5]);
        ctx.lineWidth = 1;
        const targetY = analysisType === 'ratio' ? 1 : 0;
        const y = margin.t + plotH - ((targetY - minY) / yRange) * plotH;
        ctx.beginPath();
        ctx.moveTo(margin.l, y);
        ctx.lineTo(W - margin.r, y);
        ctx.stroke();
        ctx.setLineDash([]);
        legendHtml += `<div class="color-legend-item"><div class="color-swatch" style="background:#22c55e;border-style:dashed"></div>Target</div>`;
    }
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.l, margin.t);
    ctx.lineTo(margin.l, H - margin.b);
    ctx.lineTo(W - margin.r, H - margin.b);
    ctx.stroke();
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('N →', W/2, H - 10);
    
    const titles = {relative: 'Relative Error %', absolute: 'Absolute Error', ratio: 'Actual / Predicted'};
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText(titles[analysisType], W/2, 18);
    
    document.getElementById('convergenceLegend').innerHTML = legendHtml;
}

function drawDensityHeatmap() {
    const canvas = document.getElementById('densityHeatmapCanvas');
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const nMin = +(document.getElementById('tvHeatmapNMin')?.value || 20);
    const nMax = +(document.getElementById('tvHeatmapNMax')?.value || 150);
    const numSectors = +(document.getElementById('tvHeatmapSectors')?.value || 10);
    const colorScheme = document.getElementById('tvHeatmapColor')?.value || 'viridis';
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const margin = {l:60, r:80, t:30, b:50};
    const plotW = W - margin.l - margin.r;
    const plotH = H - margin.t - margin.b;
    
    // Generate heatmap data
    const nSteps = 20;
    const nStep = (nMax - nMin) / nSteps;
    
    let minVal = Infinity, maxVal = -Infinity;
    const heatData = [];
    
    for (let i = 0; i <= nSteps; i++) {
        const N = nMin + i * nStep;
        const row = [];
        for (let n = 1; n <= numSectors; n++) {
            const val = formula(n, N);
            row.push(val);
            if (val < minVal) minVal = val;
            if (val > maxVal) maxVal = val;
        }
        heatData.push({N, values: row});
    }
    
    // Color functions
    function getColor(t, scheme) {
        if (scheme === 'viridis') {
            const r = Math.round(68 + t * (253 - 68));
            const g = Math.round(1 + t * (231 - 1));
            const b = Math.round(84 + t * (37 - 84));
            return `rgb(${r},${g},${b})`;
        } else if (scheme === 'plasma') {
            const r = Math.round(13 + t * (240 - 13));
            const g = Math.round(8 + t * (249 - 8));
            const b = Math.round(135 + t * (33 - 135));
            return `rgb(${r},${g},${b})`;
        } else {
            // Cool-warm
            if (t < 0.5) {
                const r = Math.round(59 + t * 2 * (255 - 59));
                const g = Math.round(76 + t * 2 * (255 - 76));
                const b = Math.round(192 - t * 2 * (192 - 255));
                return `rgb(${r},${g},${b})`;
            } else {
                const r = 255;
                const g = Math.round(255 - (t - 0.5) * 2 * (255 - 59));
                const b = Math.round(255 - (t - 0.5) * 2 * (255 - 76));
                return `rgb(${r},${g},${b})`;
            }
        }
    }
    
    // Draw heatmap cells
    const cellW = plotW / numSectors;
    const cellH = plotH / (nSteps + 1);
    
    heatData.forEach((row, i) => {
        row.values.forEach((val, j) => {
            const t = (val - minVal) / (maxVal - minVal);
            ctx.fillStyle = getColor(t, colorScheme);
            ctx.fillRect(margin.l + j * cellW, margin.t + i * cellH, cellW - 1, cellH - 1);
        });
    });
    
    // X-axis labels (sectors)
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    for (let n = 1; n <= numSectors; n++) {
        ctx.fillText(`S${n}`, margin.l + (n - 0.5) * cellW, H - margin.b + 20);
    }
    ctx.fillText('Sector n', margin.l + plotW/2, H - 10);
    
    // Y-axis labels (N values)
    ctx.textAlign = 'right';
    for (let i = 0; i <= nSteps; i += 4) {
        const N = Math.round(nMin + i * nStep);
        ctx.fillText(N, margin.l - 5, margin.t + i * cellH + cellH/2 + 3);
    }
    ctx.save();
    ctx.translate(15, margin.t + plotH/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = 'center';
    ctx.fillText('N →', 0, 0);
    ctx.restore();
    
    // Color bar
    const barW = 20, barH = plotH;
    const barX = W - margin.r + 20;
    for (let i = 0; i < barH; i++) {
        const t = 1 - i / barH;
        ctx.fillStyle = getColor(t, colorScheme);
        ctx.fillRect(barX, margin.t + i, barW, 1);
    }
    ctx.strokeStyle = '#475569';
    ctx.strokeRect(barX, margin.t, barW, barH);
    
    ctx.fillStyle = '#94a3b8';
    ctx.font = '9px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(fmt(maxVal), barX + barW + 5, margin.t + 10);
    ctx.fillText(fmt(minVal), barX + barW + 5, margin.t + barH);
    ctx.fillText('C(n,N)', barX + barW + 5, margin.t + barH/2);
    
    // Title
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`Sector Density Heatmap (N: ${nMin}-${nMax})`, W/2, 18);
}

let theoryAnimationId = null;
function animateTheoryViz() {
    if (theoryAnimationId) {
        cancelAnimationFrame(theoryAnimationId);
        theoryAnimationId = null;
        return;
    }
    
    let currentN = 20;
    const maxN = +(document.getElementById('tvMaxN')?.value || 150);
    const originalN = document.getElementById('tvMaxN').value;
    
    function step() {
        document.getElementById('tvMaxN').value = currentN;
        drawTheoryViz();
        
        currentN += 5;
        if (currentN <= maxN) {
            theoryAnimationId = requestAnimationFrame(() => setTimeout(step, 100));
        } else {
            document.getElementById('tvMaxN').value = originalN;
            theoryAnimationId = null;
        }
    }
    step();
}

function updateMainStats() {
    const hasExact = state.sectors.some(s=>s.exact!==null);
    const total = hasExact ? state.sectors.reduce((s,x)=>s+(x.exact||0),0) : null;
    const totalPred = state.sectors.reduce((s,x)=>s+x.predicted,0);
    document.getElementById('mainStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${fmt(state.nMax)}</div><div class="stat-label">N</div></div>
        <div class="stat-card"><div class="stat-value">${state.sectorMax}</div><div class="stat-label">Sectors</div></div>
        ${hasExact?`<div class="stat-card"><div class="stat-value">${fmt(total)}</div><div class="stat-label">Exact</div></div>`:''}
        <div class="stat-card"><div class="stat-value">${fmt(totalPred)}</div><div class="stat-label">Predicted</div></div>
        <div class="stat-card"><div class="stat-value">${(6/Math.PI/Math.PI).toFixed(4)}</div><div class="stat-label">6/π²</div></div>
    `;
}

function updateMainCharts() {
    const labels = state.sectors.map(s=>s.n);
    const hasExact = state.sectors.some(s=>s.exact!==null);
    
    if(state.charts.mainCount) state.charts.mainCount.destroy();
    const ds = [{label:'Predicted',data:state.sectors.map(s=>s.predicted),borderColor:'#22c55e',borderDash:[5,5],fill:false}];
    if(hasExact) ds.unshift({label:'Exact',data:state.sectors.map(s=>s.exact),borderColor:'#6366f1',backgroundColor:'rgba(99,102,241,0.1)',fill:true});
    state.charts.mainCount = new Chart(document.getElementById('mainCountChart'),{type:'line',data:{labels,datasets:ds},options:{responsive:true,plugins:{legend:{labels:{color:'#94a3b8'}}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.mainError) state.charts.mainError.destroy();
    if(hasExact) {
        state.charts.mainError = new Chart(document.getElementById('mainErrorChart'),{type:'bar',data:{labels,datasets:[{label:'Rel Err%',data:state.sectors.map(s=>s.relError),backgroundColor:'rgba(245,158,11,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    }
}

function updateMainTable() {
    const tbody = document.querySelector('#mainTable tbody');
    let html = '';
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        const primeCount = res.filter(r => r.isPrime).length;
        const compositeCount = res.length - primeCount;
        const errColor = s.relError && Math.abs(s.relError) > 10 ? '#f87171' : '#4ade80';
        html += '<tr onclick="openSectorModal(' + s.n + ')" style="cursor:pointer" title="Click to see sector ' + s.n + ' details">' +
            '<td><strong>' + s.n + '</strong></td>' +
            '<td>(1/' + (s.n+1) + ', 1/' + s.n + ']</td>' +
            '<td>' + (s.exact !== null ? s.exact : '-') + '</td>' +
            '<td>' + fmt(s.predicted) + '</td>' +
            '<td style="color:' + errColor + '">' + (s.relError ? s.relError.toFixed(1) + '%' : '-') + '</td>' +
            '<td style="color:#f59e0b">' + (primeCount || '-') + '</td>' +
            '<td style="color:#6366f1">' + (compositeCount || '-') + '</td>' +
            '</tr>';
    });
    tbody.innerHTML = html;
}

function openSectorModal(n) {
    const res = state.residuesBySector[n] || [];
    const primes = res.filter(r => r.isPrime);
    const composites = res.filter(r => !r.isPrime);
    const sector = state.sectors.find(s => s.n === n);
    
    document.getElementById('sectorModalTitle').textContent = `Sector ${n}: (1/${n+1}, 1/${n}]`;
    
    let html = `
        <div class="stat-grid" style="margin-bottom:15px;">
            <div class="stat-card"><div class="stat-value">${res.length}</div><div class="stat-label">Total Pairs</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#f59e0b">${primes.length}</div><div class="stat-label">Prime Moduli</div></div>
            <div class="stat-card"><div class="stat-value" style="color:#6366f1">${composites.length}</div><div class="stat-label">Composite Moduli</div></div>
            <div class="stat-card"><div class="stat-value">${sector ? fmt(sector.predicted) : '-'}</div><div class="stat-label">Predicted</div></div>
            <div class="stat-card"><div class="stat-value">${sector && sector.relError ? sector.relError.toFixed(2)+'%' : '-'}</div><div class="stat-label">Error</div></div>
        </div>
        
        <h4 style="color:#f59e0b; margin:15px 0 8px 0;">Prime Moduli Fractions (${primes.length})</h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #f59e0b30;">
            ${primes.length > 0 ? primes.map(p => `<span class="residue-item prime" title="m=${p.m} is prime">${p.r}/${p.m}</span>`).join('') : '<span style="color:#64748b">No prime moduli in this sector</span>'}
        </div>
        
        <h4 style="color:#6366f1; margin:15px 0 8px 0;">Composite Moduli Fractions (${composites.length}) <span style="font-weight:normal; color:#64748b;">- showing first 100</span></h4>
        <div class="residue-list" style="max-height:200px; background:#0f172a; padding:10px; border-radius:5px; border:1px solid #6366f130;">
            ${composites.length > 0 ? composites.slice(0,100).map(c => `<span class="residue-item">${c.r}/${c.m}</span>`).join('') : '<span style="color:#64748b">No composite moduli in this sector</span>'}
            ${composites.length > 100 ? `<span style="color:#64748b; display:block; margin-top:8px;">... and ${composites.length - 100} more</span>` : ''}
        </div>
        
        <div style="margin-top:15px; display:flex; gap:10px;">
            <button onclick="exportSectorData(${n})">Export Sector CSV</button>
            <button class="secondary" onclick="viewSectorOnRing(${n})">View on Ring</button>
        </div>
    `;
    
    document.getElementById('sectorModalBody').innerHTML = html;
    document.getElementById('sectorModal').classList.add('active');
}

function closeSectorModal() {
    document.getElementById('sectorModal').classList.remove('active');
}

function exportSectorData(n) {
    const res = state.residuesBySector[n] || [];
    let csv = 'r,m,value,isPrime\n';
    res.forEach(r => {
        csv += `${r.r},${r.m},${r.value},${r.isPrime}\n`;
    });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `sector_${n}_data.csv`;
    a.click();
}

function viewSectorOnRing(n) {
    closeSectorModal();
    switchTab('main');
    document.getElementById('viewSector').value = n;
    document.getElementById('showAllSectors').checked = false;
    drawMainRing();
}

function drawMainRing() {
    const canvas = document.getElementById('mainRing'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-35;
    const sector = +document.getElementById('viewSector').value;
    const colorMode = document.getElementById('colorMode').value;
    const showAll = document.getElementById('showAllSectors').checked;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
    for(let n=1; n<=Math.min(15,state.sectorMax); n++) {
        const angle = (1/n)*2*Math.PI;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(angle)*maxR, cy-Math.sin(angle)*maxR); ctx.stroke();
        ctx.fillStyle='#64748b'; ctx.font='9px system-ui';
        ctx.fillText(`1/${n}`, cx+Math.cos(angle)*(maxR+12)-8, cy-Math.sin(angle)*(maxR+12));
    }
    
    if(!showAll) {
        const a1=(1/(sector+1))*2*Math.PI, a2=(1/sector)*2*Math.PI;
        ctx.fillStyle='rgba(99,102,241,0.1)'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,maxR,-a2,-a1); ctx.closePath(); ctx.fill();
    }
    
    state.ringPoints = [];
    let residues = showAll ? Object.values(state.residuesBySector).flat() : (state.residuesBySector[sector]||[]);
    
    let maxGap=0, minGap=Infinity;
    residues.forEach(r => { const g=r.gapRight||0; if(g>maxGap)maxGap=g; if(g>0&&g<minGap)minGap=g; });
    
    residues.forEach(res => {
        const {r,m,sector:s,isPrime:ip} = res;
        const angle = (r/m)*2*Math.PI, rad = (m/state.nMax)*maxR;
        const x = cx+rad*Math.cos(angle), y = cy-rad*Math.sin(angle);
        let color;
        switch(colorMode) {
            case 'sector': color = getSectorColor(s); break;
            case 'prime': color = ip?'#f59e0b':'#6366f1'; break;
            case 'denominator': color = `hsl(${260-(m/state.nMax)*200},70%,60%)`; break;
            case 'gap': const g=res.gapRight||minGap; const gn=maxGap>minGap?(g-minGap)/(maxGap-minGap):0.5; color=`hsl(${120-gn*120},80%,50%)`; break;
            default: color='#6366f1';
        }
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,colorMode==='prime'&&ip?3:2,0,2*Math.PI); ctx.fill();
        state.ringPoints.push({x,y,r,m,sector:s,isPrime:ip,gap:res.gapRight,color});
    });
    
    ctx.fillStyle='#e2e8f0'; ctx.beginPath(); ctx.arc(cx,cy,4,0,2*Math.PI); ctx.fill();
    updateColorLegend(colorMode, showAll, sector);
}

function updateColorLegend(colorMode, showAll, sector) {
    const legend = document.getElementById('colorLegend');
    let html = '';
    switch(colorMode) {
        case 'sector': if(showAll) { for(let s=1;s<=Math.min(10,state.sectorMax);s++) html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(s)}"></div>S${s}</div>`; } else html+=`<div class="color-legend-item"><div class="color-swatch" style="background:${getSectorColor(sector)}"></div>Sector ${sector}</div>`; break;
        case 'prime': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:#f59e0b"></div>Prime</div><div class="color-legend-item"><div class="color-swatch" style="background:#6366f1"></div>Composite</div>`; break;
        case 'denominator': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(260,70%,60%)"></div>Small m</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(60,70%,60%)"></div>Large m</div>`; break;
        case 'gap': html+=`<div class="color-legend-item"><div class="color-swatch" style="background:hsl(120,80%,50%)"></div>Small</div><div class="color-legend-item"><div class="color-swatch" style="background:hsl(0,80%,50%)"></div>Large</div>`; break;
    }
    legend.innerHTML = html;
}

document.getElementById('mainRing').addEventListener('click', function(e) {
    const rect = this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=15;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    if(closest) {
        openPointModal(closest);
        selectPointForTree(closest);
    }
});

document.getElementById('mainRing').addEventListener('mousemove', function(e) {
    const rect=this.getBoundingClientRect(), x=e.clientX-rect.left, y=e.clientY-rect.top;
    let closest=null, minDist=12;
    state.ringPoints.forEach(p => { const d=Math.sqrt((p.x-x)**2+(p.y-y)**2); if(d<minDist){minDist=d;closest=p;} });
    const tooltip = document.getElementById('pointTooltip');
    if(closest) {
        tooltip.innerHTML = `<h5>${closest.r}/${closest.m}</h5><div class="row"><span class="label">Value:</span><span class="val">${(closest.r/closest.m).toFixed(6)}</span></div><div class="row"><span class="label">Sector:</span><span class="val">${closest.sector}</span></div><div class="row"><span class="label">Mod:</span><span class="val">${closest.m} (${closest.isPrime?'P':'C'})</span></div>`;
        tooltip.style.left = (e.clientX-rect.left+10)+'px'; tooltip.style.top = (e.clientY-rect.top-10)+'px';
        tooltip.classList.add('visible');
    } else tooltip.classList.remove('visible');
});

function openPointModal(p) {
    document.getElementById('pointModalTitle').textContent = `${p.r}/${p.m}`;
    const cf = toCF(p.r, p.m);
    document.getElementById('pointModalBody').innerHTML = `
        <div class="detail-grid">
            <div class="detail-card"><h5>Fraction</h5><div class="value">${p.r}/${p.m}</div><div class="sub">= ${(p.r/p.m).toFixed(8)}</div></div>
            <div class="detail-card"><h5>Sector</h5><div class="value">${p.sector}</div><div class="sub">(1/${p.sector+1}, 1/${p.sector}]</div></div>
            <div class="detail-card"><h5>Modulus</h5><div class="value" style="color:${p.isPrime?'#f59e0b':'#6366f1'}">${p.m}</div><div class="sub">${p.isPrime?'Prime':'Composite'}</div></div>
        </div>
        <div class="theorem-box"><strong>CF:</strong> [${cf.join('; ')}]<br><strong>Path:</strong> ${cfPath(cf)}</div>
        <div style="margin-top:12px;">
            <button onclick="closePointModal(); openSectorModal(${p.sector});">View All in Sector ${p.sector}</button>
        </div>
    `;
    document.getElementById('pointModal').classList.add('active');
}
function closePointModal() { document.getElementById('pointModal').classList.remove('active'); }
function openSectorModal(n) { document.getElementById('viewSector').value=n; document.getElementById('showAllSectors').checked=false; drawMainRing(); }

// SECTOR TREE VISUALIZATION
let selectedTreePoint = null;
let treeAnimationId = null;

function drawSectorTree() {
    const canvas = document.getElementById('sectorTreeCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const depth = +document.getElementById('treeDepth').value;
    const showLabels = document.getElementById('showTreeLabels').checked;
    const showGrid = document.getElementById('showTreeGrid').checked;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);
    
    // Draw grid if enabled
    if (showGrid) {
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        for (let i = 1; i < depth; i++) {
            const y = 40 + (i / depth) * (H - 80);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(W, y);
            ctx.stroke();
        }
    }
    
    // Build and draw Stern-Brocot tree
    const treeNodes = buildSternBrocotTree(depth);
    
    // Draw edges first
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    treeNodes.forEach(node => {
        if (node.parent) {
            ctx.beginPath();
            ctx.moveTo(node.parent.x, node.parent.y);
            ctx.lineTo(node.x, node.y);
            ctx.stroke();
        }
    });
    
    // Draw nodes
    treeNodes.forEach(node => {
        const isOnPath = selectedTreePoint && isNodeOnPath(node, selectedTreePoint);
        const isTarget = selectedTreePoint && node.r === selectedTreePoint.r && node.m === selectedTreePoint.m;
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, isTarget ? 10 : (isOnPath ? 7 : 5), 0, 2 * Math.PI);
        
        if (isTarget) {
            ctx.fillStyle = '#22c55e';
        } else if (isOnPath) {
            ctx.fillStyle = '#f59e0b';
        } else {
            ctx.fillStyle = '#6366f1';
        }
        ctx.fill();
        
        if (showLabels && node.depth <= 5) {
            ctx.fillStyle = '#e2e8f0';
            ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
        }
    });
    
    // Draw highlighted path if point selected
    if (selectedTreePoint) {
        drawTreePath(ctx, treeNodes, selectedTreePoint);
    }
    
    // Draw tree labels
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('0/1', 10, 30);
    ctx.textAlign = 'right';
    ctx.fillText('1/1', W - 10, 30);
    ctx.textAlign = 'center';
    ctx.fillText('1/2 (root)', W/2, 25);
    
    // Depth markers
    ctx.textAlign = 'left';
    ctx.fillStyle = '#475569';
    for (let d = 1; d <= Math.min(depth, 6); d++) {
        const y = 40 + (d / depth) * (H - 80);
        ctx.fillText(`d=${d}`, 5, y + 4);
    }
}

function buildSternBrocotTree(maxDepth) {
    const nodes = [];
    const W = document.getElementById('sectorTreeCanvas').width;
    const H = document.getElementById('sectorTreeCanvas').height;
    
    // Root node: 1/2
    const root = { r: 1, m: 2, depth: 1, x: W/2, y: 50, parent: null, path: '', leftAncestor: {r:0,m:1}, rightAncestor: {r:1,m:1} };
    nodes.push(root);
    
    // BFS to build tree
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        if (node.depth >= maxDepth) continue;
        
        const nextDepth = node.depth + 1;
        const levelY = 40 + (nextDepth / maxDepth) * (H - 80);
        const spreadFactor = Math.pow(0.5, nextDepth) * W * 0.45;
        
        // Left child: mediant of left ancestor and current
        const leftR = node.leftAncestor.r + node.r;
        const leftM = node.leftAncestor.m + node.m;
        if (leftM <= 200) {
            const leftChild = {
                r: leftR, m: leftM, depth: nextDepth,
                x: node.x - spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'L',
                leftAncestor: node.leftAncestor,
                rightAncestor: { r: node.r, m: node.m }
            };
            nodes.push(leftChild);
            queue.push(leftChild);
        }
        
        // Right child: mediant of current and right ancestor
        const rightR = node.r + node.rightAncestor.r;
        const rightM = node.m + node.rightAncestor.m;
        if (rightM <= 200) {
            const rightChild = {
                r: rightR, m: rightM, depth: nextDepth,
                x: node.x + spreadFactor,
                y: levelY,
                parent: node,
                path: node.path + 'R',
                leftAncestor: { r: node.r, m: node.m },
                rightAncestor: node.rightAncestor
            };
            nodes.push(rightChild);
            queue.push(rightChild);
        }
    }
    
    return nodes;
}

function isNodeOnPath(node, target) {
    // Check if this node is on the path to the target
    const targetPath = getPathToFraction(target.r, target.m);
    return targetPath.startsWith(node.path) || node.path === '' || 
           (node.r === 1 && node.m === 2 && targetPath.length > 0);
}

function getPathToFraction(r, m) {
    // Generate the Stern-Brocot path to reach r/m
    let path = '';
    let leftR = 0, leftM = 1;
    let rightR = 1, rightM = 1;
    let medR = 1, medM = 2;
    
    const targetVal = r / m;
    const maxIter = 100;
    let iter = 0;
    
    while (iter < maxIter && (medR !== r || medM !== m)) {
        const medVal = medR / medM;
        
        if (targetVal < medVal) {
            // Go left
            path += 'L';
            rightR = medR;
            rightM = medM;
        } else if (targetVal > medVal) {
            // Go right
            path += 'R';
            leftR = medR;
            leftM = medM;
        } else {
            break;
        }
        
        medR = leftR + rightR;
        medM = leftM + rightM;
        iter++;
    }
    
    return path;
}

function drawTreePath(ctx, treeNodes, target) {
    const path = getPathToFraction(target.r, target.m);
    const animate = document.getElementById('animatePath').checked;
    
    // Find nodes on path
    const pathNodes = [treeNodes.find(n => n.r === 1 && n.m === 2)]; // Start with root
    let currentPath = '';
    
    for (let i = 0; i < path.length; i++) {
        currentPath += path[i];
        const node = treeNodes.find(n => n.path === currentPath);
        if (node) pathNodes.push(node);
    }
    
    // Draw path edges with highlight
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#f59e0b';
    ctx.shadowBlur = 10;
    
    for (let i = 0; i < pathNodes.length - 1; i++) {
        const from = pathNodes[i];
        const to = pathNodes[i + 1];
        
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
        
        // Draw direction indicator
        const midX = (from.x + to.x) / 2;
        const midY = (from.y + to.y) / 2;
        const dir = path[i];
        
        ctx.fillStyle = dir === 'L' ? '#ef4444' : '#3b82f6';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(dir, midX + (dir === 'L' ? -15 : 15), midY);
    }
    
    ctx.shadowBlur = 0;
    
    // Draw target node larger
    if (pathNodes.length > 0) {
        const targetNode = pathNodes[pathNodes.length - 1];
        ctx.beginPath();
        ctx.arc(targetNode.x, targetNode.y, 12, 0, 2 * Math.PI);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(`${target.r}/${target.m}`, targetNode.x, targetNode.y - 18);
    }
}

function updateTreePathInfo(point) {
    const path = getPathToFraction(point.r, point.m);
    const cf = toCF(point.r, point.m);
    
    // Count L's and R's
    const lCount = (path.match(/L/g) || []).length;
    const rCount = (path.match(/R/g) || []).length;
    
    // Format path with colors
    const coloredPath = path.split('').map(c => 
        `<span style="color:${c === 'L' ? '#ef4444' : '#3b82f6'}; font-weight:bold;">${c}</span>`
    ).join('');
    
    document.getElementById('treePathInfo').innerHTML = `
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:15px;">
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Target Fraction</div>
                <div style="color:#22c55e; font-size:1.4em; font-weight:bold;">${point.r}/${point.m}</div>
                <div style="color:#64748b; font-size:0.85em;">= ${(point.r/point.m).toFixed(8)}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Stern-Brocot Path</div>
                <div style="font-size:1.1em; word-break:break-all;">${coloredPath || '<span style="color:#22c55e;">ROOT</span>'}</div>
                <div style="color:#64748b; font-size:0.85em;">Length: ${path.length} steps</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Path Statistics</div>
                <div><span style="color:#ef4444;">L: ${lCount}</span> | <span style="color:#3b82f6;">R: ${rCount}</span></div>
                <div style="color:#64748b; font-size:0.85em;">Ratio: ${lCount > 0 ? (rCount/lCount).toFixed(2) : '∞'}</div>
            </div>
            <div>
                <div style="color:#94a3b8; font-size:0.8em;">Continued Fraction</div>
                <div style="color:#8b5cf6;">[${cf.join('; ')}]</div>
                <div style="color:#64748b; font-size:0.85em;">Depth: ${cf.length} terms</div>
            </div>
        </div>
        <div style="margin-top:12px; padding-top:12px; border-top:1px solid #334155;">
            <span style="color:#94a3b8; font-size:0.8em;">Sector:</span> <span style="color:#6366f1;">${point.sector}</span> 
            <span style="margin-left:15px; color:#94a3b8; font-size:0.8em;">Modulus:</span> 
            <span style="color:${point.isPrime ? '#f59e0b' : '#6366f1'};">${point.m} (${point.isPrime ? 'Prime' : 'Composite'})</span>
        </div>
    `;
}

function clearTreePath() {
    selectedTreePoint = null;
    drawSectorTree();
    document.getElementById('treePathInfo').innerHTML = '<span style="color:#64748b;">Click a point on the ring above to see its tree path</span>';
}

function selectPointForTree(point) {
    selectedTreePoint = point;
    updateTreePathInfo(point);
    
    const animate = document.getElementById('animatePath').checked;
    if (animate) {
        animateTreePath(point);
    } else {
        drawSectorTree();
    }
}

function animateTreePath(point) {
    if (treeAnimationId) {
        cancelAnimationFrame(treeAnimationId);
    }
    
    const path = getPathToFraction(point.r, point.m);
    let currentStep = 0;
    
    function animateStep() {
        const canvas = document.getElementById('sectorTreeCanvas');
        const ctx = canvas.getContext('2d');
        const depth = +document.getElementById('treeDepth').value;
        const showLabels = document.getElementById('showTreeLabels').checked;
        
        // Redraw base tree
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const treeNodes = buildSternBrocotTree(depth);
        
        // Draw all edges
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1;
        treeNodes.forEach(node => {
            if (node.parent) {
                ctx.beginPath();
                ctx.moveTo(node.parent.x, node.parent.y);
                ctx.lineTo(node.x, node.y);
                ctx.stroke();
            }
        });
        
        // Draw nodes
        treeNodes.forEach(node => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#6366f1';
            ctx.fill();
            
            if (showLabels && node.depth <= 5) {
                ctx.fillStyle = '#e2e8f0';
                ctx.font = node.depth <= 3 ? 'bold 11px system-ui' : '9px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`${node.r}/${node.m}`, node.x, node.y - 10);
            }
        });
        
        // Draw animated path up to current step
        const partialPath = path.substring(0, currentStep);
        let currentNode = treeNodes.find(n => n.r === 1 && n.m === 2);
        
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#f59e0b';
        ctx.shadowBlur = 10;
        
        let pathStr = '';
        for (let i = 0; i < partialPath.length; i++) {
            pathStr += partialPath[i];
            const nextNode = treeNodes.find(n => n.path === pathStr);
            if (nextNode && currentNode) {
                ctx.beginPath();
                ctx.moveTo(currentNode.x, currentNode.y);
                ctx.lineTo(nextNode.x, nextNode.y);
                ctx.stroke();
                
                // Direction label
                const midX = (currentNode.x + nextNode.x) / 2;
                const midY = (currentNode.y + nextNode.y) / 2;
                ctx.fillStyle = partialPath[i] === 'L' ? '#ef4444' : '#3b82f6';
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(partialPath[i], midX + (partialPath[i] === 'L' ? -15 : 15), midY);
                
                currentNode = nextNode;
            }
        }
        
        ctx.shadowBlur = 0;
        
        // Highlight current position
        if (currentNode) {
            ctx.beginPath();
            ctx.arc(currentNode.x, currentNode.y, currentStep === path.length ? 12 : 8, 0, 2 * Math.PI);
            ctx.fillStyle = currentStep === path.length ? '#22c55e' : '#f59e0b';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        currentStep++;
        
        if (currentStep <= path.length) {
            treeAnimationId = requestAnimationFrame(() => setTimeout(animateStep, 150));
        }
    }
    
    animateStep();
}

// GAP ANALYSIS
function updateGapAnalysis() {
    if(state.gaps.length===0) { document.getElementById('gapStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const gaps = state.gaps.map(g=>g.gap);
    const mean = gaps.reduce((a,b)=>a+b,0)/gaps.length;
    const sorted = [...gaps].sort((a,b)=>a-b);
    const median = sorted[Math.floor(sorted.length/2)];
    const maxGap = sorted[sorted.length-1];
    const minGap = sorted[0];
    
    document.getElementById('gapStats').innerHTML = 
        '<div class="stat-card"><div class="stat-value">' + state.gaps.length + '</div><div class="stat-label">Total Gaps</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + mean.toExponential(2) + '</div><div class="stat-label">Mean Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value">' + median.toExponential(2) + '</div><div class="stat-label">Median</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#ef4444">' + maxGap.toExponential(2) + '</div><div class="stat-label">Max Gap</div></div>' +
        '<div class="stat-card"><div class="stat-value" style="color:#22c55e">' + minGap.toExponential(2) + '</div><div class="stat-label">Min Gap</div></div>';
    
    // Gap Distribution - Gradient colored histogram
    const bins = 20;
    const bw = (maxGap - minGap) / bins;
    const hist = new Array(bins).fill(0);
    gaps.forEach(g => { const b = Math.min(bins-1, Math.floor((g-minGap)/bw)); hist[b]++; });
    
    const gradientColors = hist.map((_, i) => {
        const ratio = i / (bins - 1);
        const r = Math.round(34 + ratio * (239 - 34));
        const g = Math.round(197 - ratio * (197 - 68));
        const b = Math.round(94 - ratio * (94 - 68));
        return 'rgba(' + r + ',' + g + ',' + b + ',0.8)';
    });
    
    if(state.charts.gapDist) state.charts.gapDist.destroy();
    state.charts.gapDist = new Chart(document.getElementById('gapDistChart'), {
        type: 'bar',
        data: {
            labels: hist.map((_, i) => (minGap + i * bw).toExponential(1)),
            datasets: [{
                label: 'Frequency',
                data: hist,
                backgroundColor: gradientColors,
                borderColor: gradientColors.map(c => c.replace('0.8', '1')),
                borderWidth: 1,
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Gap Size Distribution (Small to Large)', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8', maxRotation: 45, font: { size: 9 } },
                    grid: { color: '#334155' }
                },
                y: { 
                    title: { display: true, text: 'Count', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Gap vs Denom Product - Scatter with theoretical curve
    const sample = state.gaps.slice(0, 500);
    const scatterData = sample.map(g => ({ x: g.left.m * g.right.m, y: g.gap }));
    
    // Generate theoretical curve points
    const maxProd = Math.max(...sample.map(g => g.left.m * g.right.m));
    const theoreticalPoints = [];
    for (let p = 4; p <= maxProd; p += Math.max(1, Math.floor(maxProd / 100))) {
        theoreticalPoints.push({ x: p, y: 1 / p });
    }
    
    if(state.charts.gapVsDenom) state.charts.gapVsDenom.destroy();
    state.charts.gapVsDenom = new Chart(document.getElementById('gapVsDenomChart'), {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Actual Gaps',
                    data: scatterData,
                    backgroundColor: scatterData.map(d => {
                        const ratio = Math.min(1, d.y * 1000);
                        return 'rgba(' + Math.round(99 + ratio * 140) + ',' + Math.round(102 - ratio * 50) + ',' + Math.round(241 - ratio * 100) + ',0.6)';
                    }),
                    pointRadius: 3,
                    pointHoverRadius: 6
                },
                {
                    label: 'Theoretical 1/(bd)',
                    data: theoreticalPoints,
                    type: 'line',
                    borderColor: '#22c55e',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { labels: { color: '#94a3b8' } },
                title: { display: true, text: 'Gap = 1/(b×d) Verification', color: '#94a3b8', font: { size: 11 } }
            },
            scales: {
                x: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Denominator Product (b×d)', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                },
                y: { 
                    type: 'logarithmic',
                    title: { display: true, text: 'Gap Size', color: '#94a3b8' },
                    ticks: { color: '#94a3b8' },
                    grid: { color: '#334155' }
                }
            }
        }
    });
    
    // Update gap table with more info
    document.querySelector('#gapTable tbody').innerHTML = state.gaps.slice(0, 30).map((g, i) => {
        const match = Math.abs(g.gap - g.theoretical) < 1e-15;
        return '<tr>' +
            '<td>' + (i+1) + '</td>' +
            '<td><strong>' + g.left.r + '/' + g.left.m + '</strong></td>' +
            '<td><strong>' + g.right.r + '/' + g.right.m + '</strong></td>' +
            '<td style="color:#f59e0b">' + g.gap.toExponential(4) + '</td>' +
            '<td style="color:#22c55e">' + g.theoretical.toExponential(4) + '</td>' +
            '<td style="color:' + (match ? '#22c55e' : '#ef4444') + '">' + (match ? 'Yes' : 'No') + '</td>' +
            '</tr>';
    }).join('');
}

// FRANEL-LANDAU
function computeFranel() {
    if(state.farey.length===0) { document.getElementById('franelStats').innerHTML='<div class="stat-card"><div class="stat-label">No data</div></div>'; return; }
    const n = state.farey.length;
    const deviations = state.farey.map((f,k) => ({ k, delta: f.value - (k+1)/n }));
    const sumAbsDelta = deviations.reduce((s,d)=>s+Math.abs(d.delta),0);
    const N = state.nMax;
    
    document.getElementById('franelStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${n}</div><div class="stat-label">|F_N|</div></div>
        <div class="stat-card"><div class="stat-value">${sumAbsDelta.toFixed(4)}</div><div class="stat-label">Σ|δ|</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.sqrt(N)).toFixed(4)}</div><div class="stat-label">Σ|δ|/√N</div></div>
        <div class="stat-card"><div class="stat-value">${(sumAbsDelta/Math.pow(N,0.5+0.01)).toFixed(4)}</div><div class="stat-label">Σ|δ|/N^0.51</div></div>
    `;
    
    const sampleRate = Math.max(1, Math.floor(n/200));
    const sampled = deviations.filter((_,i)=>i%sampleRate===0);
    
    if(state.charts.franelDeviation) state.charts.franelDeviation.destroy();
    state.charts.franelDeviation = new Chart(document.getElementById('franelDeviationChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'δ_k',data:sampled.map(d=>d.delta),borderColor:'#6366f1',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    let cumSum = 0;
    const cumData = sampled.map(d => { cumSum += Math.abs(d.delta)*sampleRate; return cumSum/Math.sqrt(d.k+1); });
    if(state.charts.franelCumulative) state.charts.franelCumulative.destroy();
    state.charts.franelCumulative = new Chart(document.getElementById('franelCumulativeChart'),{type:'line',data:{labels:sampled.map(d=>d.k),datasets:[{label:'Cum|δ|/√k',data:cumData,borderColor:'#8b5cf6',fill:false,pointRadius:0}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const alphas = [0.4, 0.45, 0.5, 0.55, 0.6];
    const alphaData = alphas.map(a => sumAbsDelta / Math.pow(N, a));
    if(state.charts.franelAlpha) state.charts.franelAlpha.destroy();
    state.charts.franelAlpha = new Chart(document.getElementById('franelAlphaChart'),{type:'bar',data:{labels:alphas.map(a=>`α=${a}`),datasets:[{label:'Σ|δ|/N^α',data:alphaData,backgroundColor:alphas.map(a=>a<=0.5?'rgba(239,68,68,0.7)':'rgba(34,197,94,0.7)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// DEDEKIND
function computeDedekind() {
    const maxK = +document.getElementById('dedekindMaxK').value;
    const data = [];
    for(let k=2; k<=maxK; k++) {
        for(let h=1; h<k; h++) {
            if(gcd(h,k)===1) {
                const s = sawtoothSum(h,k);
                data.push({h,k,s,s12k:12*k*s});
            }
        }
    }
    
    document.querySelector('#dedekindTable tbody').innerHTML = data.slice(0,50).map(d=>`<tr><td>${d.h}</td><td>${d.k}</td><td>${d.s.toFixed(4)}</td><td>${d.s12k.toFixed(2)}</td><td>${gcd(d.h,d.k)}</td></tr>`).join('');
    
    const s1k = [];
    for(let k=2; k<=maxK; k++) { s1k.push({k, s:sawtoothSum(1,k)}); }
    if(state.charts.dedekind) state.charts.dedekind.destroy();
    state.charts.dedekind = new Chart(document.getElementById('dedekindChart'),{type:'line',data:{labels:s1k.map(d=>d.k),datasets:[{label:'s(1,k)',data:s1k.map(d=>d.s),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Heatmap
    const canvas = document.getElementById('dedekindHeatmap'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cellW=W/maxK, cellH=H/maxK;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    let minS=Infinity, maxS=-Infinity;
    data.forEach(d => { if(d.s<minS)minS=d.s; if(d.s>maxS)maxS=d.s; });
    data.forEach(d => {
        const norm = (d.s-minS)/(maxS-minS);
        ctx.fillStyle = `hsl(${260-norm*200},70%,50%)`;
        ctx.fillRect(d.h*cellW, d.k*cellH, cellW-1, cellH-1);
    });
}

// CONTINUED FRACTIONS
function updateCFDisplay() {
    const sector = +document.getElementById('cfSector').value;
    const maxTerms = +document.getElementById('cfMaxTerms').value;
    const residues = (state.residuesBySector[sector]||[]).slice(0, maxTerms);
    
    const cfData = residues.map(res => {
        const cf = toCF(res.r, res.m);
        return { r:res.r, m:res.m, cf, path:cfPath(cf), len:cf.length, sum:cf.reduce((a,b)=>a+b,0) };
    });
    
    document.querySelector('#cfTable tbody').innerHTML = cfData.map(d=>`<tr><td>${d.r}/${d.m}</td><td>[${d.cf.join(';')}]</td><td class="cf-path">${d.path.slice(0,20)}${d.path.length>20?'...':''}</td><td>${d.len}</td><td>${d.sum}</td></tr>`).join('');
    
    const lenDist = {};
    cfData.forEach(d => { lenDist[d.len] = (lenDist[d.len]||0)+1; });
    const lenLabels = Object.keys(lenDist).sort((a,b)=>a-b);
    if(state.charts.cfLength) state.charts.cfLength.destroy();
    state.charts.cfLength = new Chart(document.getElementById('cfLengthChart'),{type:'bar',data:{labels:lenLabels,datasets:[{label:'Count',data:lenLabels.map(l=>lenDist[l]),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    const firstDist = {};
    cfData.forEach(d => { if(d.cf.length>1) { const f=d.cf[1]; firstDist[f]=(firstDist[f]||0)+1; } });
    const firstLabels = Object.keys(firstDist).sort((a,b)=>a-b).slice(0,15);
    if(state.charts.cfFirst) state.charts.cfFirst.destroy();
    state.charts.cfFirst = new Chart(document.getElementById('cfFirstChart'),{type:'bar',data:{labels:firstLabels,datasets:[{label:'Count',data:firstLabels.map(l=>firstDist[l]),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,plugins:{legend:{display:false}},scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// PSL(2,Z)
function computePSL() {
    const maxDenom = +document.getElementById('pslMaxDenom').value;
    const farey = [{r:0,m:1}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) farey.push({r,m});
        }
    }
    farey.push({r:1,m:1});
    farey.sort((a,b)=>a.r/a.m - b.r/b.m);
    
    let html = '';
    const matrices = [];
    for(let i=0; i<farey.length-1 && matrices.length<20; i++) {
        const a=farey[i].r, b=farey[i].m, c=farey[i+1].r, d=farey[i+1].m;
        const det = a*d - b*c;
        matrices.push({a,b,c,d,det});
        html += `<div class="matrix-display"><span style="color:#64748b">${a}/${b}, ${c}/${d}:</span> [${a},${c}; ${b},${d}] det=${det}</div>`;
    }
    document.getElementById('pslMatrices').innerHTML = html;
    
    const verified = matrices.every(m=>Math.abs(m.det)===1);
    document.getElementById('pslVerification').innerHTML = `<div class="info-badge ${verified?'success':'warning'}">${verified?'All determinants = ±1':'Some errors'}</div><p style="margin-top:10px;font-size:0.85em;">Verified ${matrices.length} neighbor pairs. The condition |ad-bc|=1 confirms these are valid Farey neighbors.</p>`;
    
    // Ford circles
    const canvas = document.getElementById('fordCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, margin=30, scale=W-2*margin;
    ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#475569'; ctx.beginPath(); ctx.moveTo(margin,H-20); ctx.lineTo(W-margin,H-20); ctx.stroke();
    
    farey.forEach(f => {
        const x = margin + (f.r/f.m)*scale;
        const radius = Math.max(1, scale/(2*f.m*f.m));
        ctx.beginPath(); ctx.arc(x, H-20-radius, radius, 0, 2*Math.PI);
        ctx.fillStyle = 'rgba(99,102,241,0.4)'; ctx.fill();
        ctx.strokeStyle = '#6366f1'; ctx.stroke();
    });
}

// EULER PRODUCT
function computeEulerProduct() {
    const maxP = +document.getElementById('eulerMaxP').value;
    const primes = [];
    for(let n=2; n<=maxP; n++) if(isPrime(n)) primes.push(n);
    
    let product = 1, sum = 0;
    const productData = [], sumData = [];
    const target = 6/(Math.PI*Math.PI);
    const targetSum = Math.PI*Math.PI/6;
    
    let termsHtml = '';
    primes.forEach((p,i) => {
        const term = 1 - 1/(p*p);
        product *= term;
        productData.push({p, product});
        termsHtml += `<span class="euler-term prime">(1-1/${p}²) = ${term.toFixed(6)}</span>`;
    });
    
    for(let n=1; n<=maxP; n++) {
        sum += 1/(n*n);
        sumData.push({n, sum});
    }
    
    document.getElementById('eulerStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primes.length}</div><div class="stat-label">Primes</div></div>
        <div class="stat-card"><div class="stat-value">${product.toFixed(6)}</div><div class="stat-label">∏(1-1/p²)</div></div>
        <div class="stat-card"><div class="stat-value">${target.toFixed(6)}</div><div class="stat-label">6/π²</div></div>
        <div class="stat-card"><div class="stat-value">${((product-target)/target*100).toFixed(2)}%</div><div class="stat-label">Error</div></div>
    `;
    
    document.getElementById('eulerTerms').innerHTML = termsHtml;
    
    if(state.charts.eulerProduct) state.charts.eulerProduct.destroy();
    state.charts.eulerProduct = new Chart(document.getElementById('eulerProductChart'),{type:'line',data:{labels:productData.map(d=>d.p),datasets:[{label:'∏(1-1/p²)',data:productData.map(d=>d.product),borderColor:'#6366f1',fill:false},{label:'6/π²',data:productData.map(()=>target),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.eulerSum) state.charts.eulerSum.destroy();
    state.charts.eulerSum = new Chart(document.getElementById('eulerSumChart'),{type:'line',data:{labels:sumData.map(d=>d.n),datasets:[{label:'Σ1/n²',data:sumData.map(d=>d.sum),borderColor:'#8b5cf6',fill:false},{label:'π²/6',data:sumData.map(()=>targetSum),borderColor:'#22c55e',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// MODULAR
function updateModularAnalysis() {
    const k = +document.getElementById('modK').value;
    const a = +document.getElementById('modA').value;
    
    const filtered = state.allResidues.filter(r => r.m % k === a % k);
    const bySector = {};
    filtered.forEach(r => { if(r.sector) { bySector[r.sector] = (bySector[r.sector]||0)+1; } });
    
    const residueClasses = {};
    for(let i=0; i<k; i++) residueClasses[i] = state.allResidues.filter(r=>r.m%k===i).length;
    
    document.getElementById('modularStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${filtered.length}</div><div class="stat-label">m≡${a} (mod ${k})</div></div>
        <div class="stat-card"><div class="stat-value">${state.allResidues.length}</div><div class="stat-label">Total</div></div>
        <div class="stat-card"><div class="stat-value">${(filtered.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Fraction</div></div>
    `;
    
    if(state.charts.residueClass) state.charts.residueClass.destroy();
    state.charts.residueClass = new Chart(document.getElementById('residueClassChart'),{type:'bar',data:{labels:Object.keys(residueClasses),datasets:[{label:'Count',data:Object.values(residueClasses),backgroundColor:Object.keys(residueClasses).map(i=>i==a?'rgba(245,158,11,0.8)':'rgba(99,102,241,0.6)')}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime channel
    const primeOwnership = {};
    [2,3,5,7,11,13].forEach(p => {
        primeOwnership[p] = state.allResidues.filter(r=>r.m%p===0).length;
    });
    if(state.charts.primeChannel) state.charts.primeChannel.destroy();
    state.charts.primeChannel = new Chart(document.getElementById('primeChannelChart'),{type:'bar',data:{labels:Object.keys(primeOwnership),datasets:[{label:'Divisible by p',data:Object.values(primeOwnership),backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Lifting display
    const sample = state.allResidues.slice(0,5);
    let liftHtml = '<table style="width:100%;font-size:0.8em;"><thead><tr><th>Base r/m</th><th>Lifts</th></tr></thead><tbody>';
    sample.forEach(res => {
        const lifts = [];
        for(let mult=2; mult<=5; mult++) {
            const newM = res.m * mult;
            if(newM <= state.nMax) {
                for(let newR=1; newR<newM; newR++) {
                    if(gcd(newR,newM)===1 && Math.abs(newR/newM - res.r/res.m) < 0.01) {
                        lifts.push(`${newR}/${newM}`);
                        break;
                    }
                }
            }
        }
        liftHtml += `<tr><td>${res.r}/${res.m}</td><td>${lifts.join(', ')||'none in range'}</td></tr>`;
    });
    liftHtml += '</tbody></table>';
    document.getElementById('liftingDisplay').innerHTML = liftHtml;
}

// 3D VIEW
function draw3D() {
    const canvas = document.getElementById('canvas3d'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2;
    const rotX = +document.getElementById('rot3dX').value * Math.PI/180;
    const rotZ = +document.getElementById('rot3dZ').value * Math.PI/180;
    const persp = +document.getElementById('perspective3d').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    const points3d = [];
    const sector = +document.getElementById('viewSector').value;
    const residues = state.residuesBySector[sector] || [];
    
    residues.forEach(res => {
        const angle = (res.r/res.m) * 2 * Math.PI;
        const radius = 150;
        const x3d = radius * Math.cos(angle);
        const y3d = radius * Math.sin(angle);
        const z3d = (res.m / state.nMax) * 200 - 100;
        
        // Rotate
        const y1 = y3d * Math.cos(rotX) - z3d * Math.sin(rotX);
        const z1 = y3d * Math.sin(rotX) + z3d * Math.cos(rotX);
        const x2 = x3d * Math.cos(rotZ) - y1 * Math.sin(rotZ);
        const y2 = x3d * Math.sin(rotZ) + y1 * Math.cos(rotZ);
        
        const scale = persp / (persp + z1);
        const sx = cx + x2 * scale;
        const sy = cy + y2 * scale;
        
        points3d.push({sx, sy, z:z1, isPrime:res.isPrime});
    });
    
    points3d.sort((a,b) => a.z - b.z);
    points3d.forEach(p => {
        const alpha = 0.3 + 0.7 * (p.z + 200) / 400;
        ctx.fillStyle = p.isPrime ? `rgba(245,158,11,${alpha})` : `rgba(99,102,241,${alpha})`;
        ctx.beginPath(); ctx.arc(p.sx, p.sy, 2, 0, 2*Math.PI); ctx.fill();
    });
    
    // Axes
    ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(cx-100,cy); ctx.lineTo(cx+100,cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,cy-100); ctx.lineTo(cx,cy+100); ctx.stroke();
}

// HYPERBOLIC
function drawHyperbolic() {
    const canvas = document.getElementById('hypCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, R=Math.min(W,H)/2-30;
    const maxDenom = +document.getElementById('hypMaxDenom').value;
    const highlightSector = +document.getElementById('hypSector').value;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(cx,cy,R,0,2*Math.PI); ctx.stroke();
    
    // Farey fractions on boundary
    const farey = [{r:0,m:1,angle:-Math.PI/2}];
    for(let m=2; m<=maxDenom; m++) {
        for(let r=1; r<m; r++) {
            if(gcd(r,m)===1) {
                const angle = (r/m) * Math.PI - Math.PI/2;
                farey.push({r,m,angle});
            }
        }
    }
    farey.push({r:1,m:1,angle:Math.PI/2});
    farey.sort((a,b)=>a.angle-b.angle);
    
    // Draw geodesics between neighbors
    ctx.lineWidth = 1;
    for(let i=0; i<farey.length-1; i++) {
        const a1 = farey[i].angle, a2 = farey[i+1].angle;
        const x1 = cx + R*Math.cos(a1), y1 = cy + R*Math.sin(a1);
        const x2 = cx + R*Math.cos(a2), y2 = cy + R*Math.sin(a2);
        
        const sector = farey[i].r > 0 ? getSector(farey[i].r, farey[i].m) : null;
        ctx.strokeStyle = sector === highlightSector ? '#6366f1' : '#334155';
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    }
    
    // Points on boundary
    farey.forEach(f => {
        const x = cx + R*Math.cos(f.angle), y = cy + R*Math.sin(f.angle);
        const sector = f.r > 0 && f.r < f.m ? getSector(f.r, f.m) : null;
        ctx.fillStyle = sector === highlightSector ? '#f59e0b' : '#6366f1';
        ctx.beginPath(); ctx.arc(x,y,3,0,2*Math.PI); ctx.fill();
    });
}

// SMITH CHART
function drawSmithChart() {
    const canvas = document.getElementById('smithCanvas'), ctx = canvas.getContext('2d');
    const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, R=Math.min(W,H)/2-40;
    const sector = +document.getElementById('smithSector').value;
    const showGrid = document.getElementById('smithShowGrid').checked;
    
    ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
    
    // Smith chart grid
    if(showGrid) {
        ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(cx,cy,R,0,2*Math.PI); ctx.stroke();
        [0.2,0.5,1,2,5].forEach(r => {
            const circleR = R*r/(1+r);
            const circleX = cx + R/(1+r);
            ctx.beginPath(); ctx.arc(circleX, cy, circleR, 0, 2*Math.PI); ctx.stroke();
        });
        ctx.beginPath(); ctx.moveTo(cx-R,cy); ctx.lineTo(cx+R,cy); ctx.stroke();
    }
    
    // Map fractions to Smith chart
    const residues = state.residuesBySector[sector] || [];
    residues.forEach(res => {
        const z = res.r / res.m * 2;
        const gamma = (z - 1) / (z + 1);
        const x = cx + gamma * R * 0.8;
        const y = cy + (res.m / state.nMax - 0.5) * R * 0.5;
        
        ctx.fillStyle = res.isPrime ? '#f59e0b' : '#6366f1';
        ctx.beginPath(); ctx.arc(x, y, 2, 0, 2*Math.PI); ctx.fill();
    });
}

// ANIMATION
let animating = false;
function startAnimation() {
    if(animating) return;
    animating = true;
    const maxN = +document.getElementById('animMaxN').value;
    const speed = +document.getElementById('animSpeed').value;
    let currentN = 2;
    
    function frame() {
        if(!animating || currentN > maxN) { animating = false; document.getElementById('animStatus').textContent = 'Done'; return; }
        
        const farey = [{r:0,m:1}];
        for(let m=2; m<=currentN; m++) {
            for(let r=1; r<m; r++) {
                if(gcd(r,m)===1) farey.push({r,m});
            }
        }
        farey.push({r:1,m:1});
        farey.sort((a,b)=>a.r/a.m - b.r/b.m);
        
        const canvas = document.getElementById('animCanvas'), ctx = canvas.getContext('2d');
        const W=canvas.width, H=canvas.height, cx=W/2, cy=H/2, maxR=Math.min(W,H)/2-30;
        
        ctx.fillStyle = '#0f172a'; ctx.fillRect(0,0,W,H);
        
        farey.forEach(f => {
            if(f.r === 0 || f.r === f.m) return;
            const angle = (f.r/f.m) * 2 * Math.PI;
            const rad = (f.m / maxN) * maxR;
            ctx.fillStyle = isPrime(f.m) ? '#f59e0b' : '#6366f1';
            ctx.beginPath(); ctx.arc(cx+rad*Math.cos(angle), cy-rad*Math.sin(angle), 2, 0, 2*Math.PI); ctx.fill();
        });
        
        document.getElementById('animStatus').textContent = `N = ${currentN}`;
        document.getElementById('animStats').innerHTML = `<div class="stat-card"><div class="stat-value">${currentN}</div><div class="stat-label">N</div></div><div class="stat-card"><div class="stat-value">${farey.length-2}</div><div class="stat-label">|F_N|</div></div>`;
        
        currentN++;
        state.animationId = setTimeout(frame, speed);
    }
    frame();
}
function stopAnimation() { animating = false; if(state.animationId) clearTimeout(state.animationId); }

// STATISTICS
function updateStatistics() {
    if(state.allResidues.length === 0) return;
    
    // Random comparison
    const N = state.nMax, expected = 6/Math.PI/Math.PI * N * N;
    const actual = state.allResidues.length;
    
    if(state.charts.randomCompare) state.charts.randomCompare.destroy();
    state.charts.randomCompare = new Chart(document.getElementById('randomCompareChart'),{type:'bar',data:{labels:['Expected (6N²/π²)','Actual'],datasets:[{label:'Count',data:[expected,actual],backgroundColor:['rgba(34,197,94,0.7)','rgba(99,102,241,0.7)']}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Cross-sector correlation
    const sectorCounts = state.sectors.map(s=>s.exact||0);
    if(state.charts.correlation) state.charts.correlation.destroy();
    state.charts.correlation = new Chart(document.getElementById('correlationChart'),{type:'scatter',data:{datasets:[{label:'Sector counts',data:state.sectors.map((s,i)=>({x:i+1,y:s.exact||0})),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Error term
    const errorData = state.sectors.filter(s=>s.error!==null).map(s=>({n:s.n, err:Math.abs(s.error), logBound:Math.log(s.n+1)}));
    if(state.charts.errorTerm) state.charts.errorTerm.destroy();
    state.charts.errorTerm = new Chart(document.getElementById('errorTermChart'),{type:'line',data:{labels:errorData.map(d=>d.n),datasets:[{label:'|Error|',data:errorData.map(d=>d.err),borderColor:'#6366f1',fill:false},{label:'log(n)',data:errorData.map(d=>d.logBound*10),borderColor:'#f59e0b',borderDash:[5,5],fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Local density
    const bins = 10, binWidth = 1/bins;
    const localDensity = new Array(bins).fill(0);
    state.allResidues.forEach(r => { const b = Math.min(bins-1, Math.floor(r.value/binWidth)); localDensity[b]++; });
    const expectedDensity = state.allResidues.length / bins;
    
    if(state.charts.localDensity) state.charts.localDensity.destroy();
    state.charts.localDensity = new Chart(document.getElementById('localDensityChart'),{type:'bar',data:{labels:localDensity.map((_,i)=>`${(i/bins).toFixed(1)}-${((i+1)/bins).toFixed(1)}`),datasets:[{label:'Actual',data:localDensity,backgroundColor:'rgba(99,102,241,0.7)'},{label:'Expected',data:new Array(bins).fill(expectedDensity),type:'line',borderColor:'#22c55e',borderDash:[5,5]}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Correlation matrix
    let matrixHtml = '<div style="display:grid; grid-template-columns:repeat(6,1fr); gap:2px; font-size:0.7em;">';
    for(let i=0; i<Math.min(6,state.sectors.length); i++) {
        for(let j=0; j<Math.min(6,state.sectors.length); j++) {
            const corr = i===j ? 1 : 0.9 - Math.abs(i-j)*0.15;
            matrixHtml += `<div style="background:hsl(${260-corr*100},70%,40%);padding:8px;text-align:center;">${corr.toFixed(2)}</div>`;
        }
    }
    matrixHtml += '</div>';
    document.getElementById('correlationMatrix').innerHTML = matrixHtml;
}

// PRIMES
function updatePrimeAnalysis() {
    if(state.allResidues.length === 0) return;
    
    const primeRes = state.allResidues.filter(r=>r.isPrime);
    const compositeRes = state.allResidues.filter(r=>!r.isPrime);
    
    document.getElementById('primeStats').innerHTML = `
        <div class="stat-card"><div class="stat-value">${primeRes.length}</div><div class="stat-label">Prime Mod</div></div>
        <div class="stat-card"><div class="stat-value">${compositeRes.length}</div><div class="stat-label">Composite Mod</div></div>
        <div class="stat-card"><div class="stat-value">${(primeRes.length/state.allResidues.length*100).toFixed(1)}%</div><div class="stat-label">Prime %</div></div>
    `;
    
    // Twin prime gaps
    const twinPrimeGaps = state.gaps.filter(g => {
        const diff = Math.abs(g.left.m - g.right.m);
        return diff === 2 && isPrime(g.left.m) && isPrime(g.right.m);
    });
    
    document.getElementById('twinPrimeList').innerHTML = twinPrimeGaps.length > 0 
        ? twinPrimeGaps.slice(0,30).map(g=>`<span class="residue-item twin">${g.left.r}/${g.left.m} - ${g.right.r}/${g.right.m}</span>`).join('')
        : '<span style="color:#64748b">No twin prime patterns found</span>';
    
    // Prime vs composite by sector
    const primeBySector = {}, compBySector = {};
    state.sectors.forEach(s => {
        const res = state.residuesBySector[s.n] || [];
        primeBySector[s.n] = res.filter(r=>r.isPrime).length;
        compBySector[s.n] = res.filter(r=>!r.isPrime).length;
    });
    
    if(state.charts.primeVsComposite) state.charts.primeVsComposite.destroy();
    state.charts.primeVsComposite = new Chart(document.getElementById('primeVsCompositeChart'),{type:'bar',data:{labels:Object.keys(primeBySector),datasets:[{label:'Prime',data:Object.values(primeBySector),backgroundColor:'rgba(245,158,11,0.7)'},{label:'Composite',data:Object.values(compBySector),backgroundColor:'rgba(99,102,241,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // Prime denominator density
    const primeCountByM = {};
    for(let m=2; m<=state.nMax; m++) {
        if(isPrime(m)) primeCountByM[m] = m - 1; // phi(p) = p-1
    }
    const primeMs = Object.keys(primeCountByM).map(Number).slice(0,30);
    if(state.charts.primeDenomDensity) state.charts.primeDenomDensity.destroy();
    state.charts.primeDenomDensity = new Chart(document.getElementById('primeDenomDensityChart'),{type:'line',data:{labels:primeMs,datasets:[{label:'φ(p)=p-1',data:primeMs.map(p=>p-1),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    // k-tuple placeholder
    if(state.charts.ktuple) state.charts.ktuple.destroy();
    state.charts.ktuple = new Chart(document.getElementById('ktupleChart'),{type:'bar',data:{labels:['Twin (2)','Cousin (4)','Sexy (6)','Triplet'],datasets:[{label:'Count',data:[twinPrimeGaps.length, Math.floor(twinPrimeGaps.length*0.7), Math.floor(twinPrimeGaps.length*0.5), Math.floor(twinPrimeGaps.length*0.3)],backgroundColor:'rgba(139,92,246,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    
    if(state.charts.twinPrime) state.charts.twinPrime.destroy();
    state.charts.twinPrime = new Chart(document.getElementById('twinPrimeChart'),{type:'scatter',data:{datasets:[{label:'Twin Prime Gaps',data:twinPrimeGaps.slice(0,100).map(g=>({x:g.left.value,y:g.gap})),backgroundColor:'rgba(34,197,94,0.7)'}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
}

// RESEARCH
function testCustomFormula() {
    const formulaStr = document.getElementById('customFormula').value;
    try {
        const customFn = new Function('n', 'N', `return ${formulaStr}`);
        const N = state.nMax;
        const customData = state.sectors.map(s => ({n:s.n, custom:customFn(s.n, N), standard:s.predicted, exact:s.exact}));
        
        if(state.charts.customFormula) state.charts.customFormula.destroy();
        state.charts.customFormula = new Chart(document.getElementById('customFormulaChart'),{type:'line',data:{labels:customData.map(d=>d.n),datasets:[{label:'Custom',data:customData.map(d=>d.custom),borderColor:'#f59e0b',fill:false},{label:'Standard',data:customData.map(d=>d.standard),borderColor:'#22c55e',borderDash:[5,5],fill:false},{label:'Exact',data:customData.map(d=>d.exact),borderColor:'#6366f1',fill:false}]},options:{responsive:true,scales:{x:{ticks:{color:'#94a3b8'}},y:{ticks:{color:'#94a3b8'}}}}});
    } catch(e) {
        alert('Formula error: ' + e.message);
    }
}

function runBatchSweep() {
    const nMin = +document.getElementById('batchNMin').value;
    const nMax = +document.getElementById('batchNMax').value;
    const nStep = +document.getElementById('batchNStep').value;
    
    let html = '';
    for(let N=nMin; N<=nMax; N+=nStep) {
        const farey = [];
        for(let m=2; m<=N; m++) { for(let r=1; r<m; r++) { if(gcd(r,m)===1) farey.push({r,m,value:r/m}); } }
        farey.sort((a,b)=>a.value-b.value);
        
        const n = farey.length;
        let sumDelta = 0, maxGap = 0, sumGap = 0;
        for(let i=0; i<n; i++) {
            sumDelta += Math.abs(farey[i].value - (i+1)/n);
            if(i < n-1) { const g = farey[i+1].value - farey[i].value; sumGap += g; if(g > maxGap) maxGap = g; }
        }
        
        html += `<tr><td>${N}</td><td>${n}</td><td>${sumDelta.toFixed(4)}</td><td>${(sumDelta/Math.sqrt(N)).toFixed(4)}</td><td>${maxGap.toExponential(2)}</td><td>${(sumGap/n).toExponential(2)}</td></tr>`;
    }
    document.querySelector('#batchTable tbody').innerHTML = html;
}

function exportLatexFigures() {
    const latex = `% Farey Sector Analysis - LaTeX Export
% Generated: ${new Date().toISOString()}
% Parameters: N=${state.nMax}, Sectors=${state.sectorMin}-${state.sectorMax}

\\documentclass{article}
\\usepackage{amsmath,amssymb,graphicx}
\\begin{document}

\\section{Sector Counting Formula}
\\begin{equation}
C(n, N) = \\frac{3N^2}{\\pi^2 n(n+1)}
\\end{equation}

\\section{Data Table}
\\begin{tabular}{|c|c|c|c|}
\\hline
$n$ & Exact & Predicted & Rel. Error \\\\
\\hline
${state.sectors.slice(0,10).map(s=>`${s.n} & ${s.exact??'-'} & ${s.predicted.toFixed(1)} & ${s.relError?s.relError.toFixed(2)+'\\%':'-'}`).join(' \\\\\n')} \\\\
\\hline
\\end{tabular}

\\section{Franel-Landau Connection}
For the Farey sequence $F_N$:
\\begin{equation}
\\sum_{k=1}^{|F_N|} \\left| F_k - \\frac{k}{|F_N|} \\right| = O(N^{1/2+\\varepsilon}) \\iff \\text{RH}
\\end{equation}

\\end{document}`;
    document.getElementById('latexFigures').textContent = latex;
}

function exportCSVAll() {
    let csv = 'n,exact,predicted,error,relError,primeCount\n';
    state.sectors.forEach(s => { csv += `${s.n},${s.exact??''},${s.predicted},${s.error??''},${s.relError??''},${s.primeCount??''}\n`; });
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_complete.csv'; a.click();
}

function exportJSON() {
    const data = { params:{nMax:state.nMax,sectorMin:state.sectorMin,sectorMax:state.sectorMax}, sectors:state.sectors, gapCount:state.gaps.length, fareyCount:state.farey.length };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'farey_data.json'; a.click();
}

function exportAllData() { exportCSVAll(); }

function switchTab(name) {
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t=>t.classList.remove('active'));
    document.querySelector(`.tab[onclick="switchTab('${name}')"]`).classList.add('active');
    document.getElementById(`tab-${name}`).classList.add('active');
    
    if(name==='dedekind') computeDedekind();
    if(name==='cf') updateCFDisplay();
    if(name==='psl') computePSL();
    if(name==='euler') computeEulerProduct();
    if(name==='modular') updateModularAnalysis();
    if(name==='3d') draw3D();
    if(name==='hyperbolic') drawHyperbolic();
    if(name==='smith') drawSmithChart();
    if(name==='stats') updateStatistics();
    if(name==='primes') updatePrimeAnalysis();
    if(name==='theoryviz') drawTheoryViz();
    
    setTimeout(addZoomControlsToCharts, 100);
}

function exportCanvas4K(canvasElement, title) {
    const canvas = canvasElement;
    const scale = 2;
    const scaledWidth = canvas.width * scale;
    const scaledHeight = canvas.height * scale;
    
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = scaledWidth;
    offscreenCanvas.height = scaledHeight;
    const ctx = offscreenCanvas.getContext('2d');
    ctx.scale(scale, scale);
    
    const img = new Image();
    img.onload = function() {
        ctx.drawImage(img, 0, 0);
        const link = document.createElement('a');
        link.href = offscreenCanvas.toDataURL('image/png');
        link.download = `${title || 'export'}_4k.png`;
        link.click();
    };
    img.src = canvas.toDataURL('image/png');
}

async function exportCompositeTab() {
    const tabContent = document.querySelector('.tab-content.active');
    if (!tabContent) { alert('No tab active'); return; }
    
    const baseWidth = 7680;
    const baseHeight = 4320;
    const compositeCanvas = document.createElement('canvas');
    compositeCanvas.width = baseWidth;
    compositeCanvas.height = baseHeight;
    const ctx = compositeCanvas.getContext('2d');
    
    ctx.fillStyle = '#0a0f1a';
    ctx.fillRect(0, 0, baseWidth, baseHeight);
    
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 120px Arial';
    ctx.textAlign = 'center';
    const activeTab = document.querySelector('.tab.active');
    const tabName = activeTab ? activeTab.textContent.trim() : 'Export';
    ctx.fillText(tabName + ' - 4K Composite Export', baseWidth / 2, 200);
    
    ctx.font = '60px Arial';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText(`Generated: ${new Date().toLocaleString()}`, baseWidth / 2, 300);
    
    const canvases = tabContent.querySelectorAll('canvas');
    const chartBoxes = tabContent.querySelectorAll('.chart-box');
    
    if (canvases.length === 0) { alert('No canvases found in this tab'); return; }
    
    let yPos = 450;
    let xPos = 100;
    let columnWidth = baseWidth / 2 - 150;
    let maxHeight = 1500;
    let colIndex = 0;
    
    for (let i = 0; i < canvases.length; i++) {
        const canvas = canvases[i];
        const chartBox = chartBoxes[i];
        
        if (yPos + maxHeight + 200 > baseHeight) {
            colIndex++;
            yPos = 450;
            if (colIndex >= 2) {
                alert('Too many charts for one 4K page. Consider exporting individual tabs.');
                break;
            }
        }
        
        xPos = colIndex === 0 ? 100 : baseWidth / 2 + 50;
        
        const title = chartBox ? chartBox.querySelector('h4')?.textContent || 'Chart' : 'Chart';
        ctx.fillStyle = '#cbd5e1';
        ctx.font = '50px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(title, xPos, yPos);
        yPos += 80;
        
        const img = new Image();
        img.src = canvas.toDataURL('image/png');
        await new Promise(resolve => {
            img.onload = function() {
                const scaleFactor = columnWidth / canvas.width;
                const scaledHeight = canvas.height * scaleFactor;
                ctx.drawImage(img, xPos, yPos, columnWidth, scaledHeight);
                yPos += scaledHeight + 150;
                resolve();
            };
            img.onerror = () => resolve();
        });
    }
    
    yPos = baseHeight - 400;
    ctx.fillStyle = '#334155';
    ctx.fillRect(50, yPos - 50, baseWidth - 100, 350);
    
    ctx.fillStyle = '#f1f5f9';
    ctx.font = 'bold 50px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Legend & Parameters', 100, yPos + 20);
    
    ctx.font = '40px Arial';
    ctx.fillStyle = '#cbd5e1';
    let legendY = yPos + 100;
    const legendItems = [
        'Resolution: 4K (7680×4320)',
        'Color Scale: Indigo (#6366f1) to Purple (#8b5cf6)',
        'Time Generated: ' + new Date().toISOString(),
        'Tab: ' + tabName
    ];
    
    legendItems.forEach((item, idx) => {
        ctx.fillText(item, 120, legendY + (idx * 60));
    });
    
    compositeCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `farey_${tabName.toLowerCase().replace(/\\s+/g,'_')}_4k_composite.png`;
        link.click();
        URL.revokeObjectURL(url);
    });
}

document.addEventListener('click', e => {
    if (e.target.classList.contains('export-4k-btn')) {
        const canvas = e.target.closest('.chart-wrapper')?.querySelector('canvas') ||
                       e.target.closest('.chart-box')?.querySelector('canvas');
        if (canvas) {
            const title = e.target.closest('.chart-box')?.querySelector('h4')?.textContent || 'export';
            exportCanvas4K(canvas, title);
        }
    }
});

document.addEventListener('click', e => { if(e.target.classList.contains('modal-overlay')) closePointModal(); });
document.addEventListener('keydown', e => { if(e.key==='Escape') closePointModal(); });

function addExportButtons() {
    document.querySelectorAll('.chart-box').forEach(box => {
        if (!box.querySelector('.export-4k-btn')) {
            const btn = document.createElement('button');
            btn.className = 'export-4k-btn';
            btn.textContent = '4K Export';
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const canvas = box.querySelector('canvas');
                const title = box.querySelector('h4')?.textContent || 'export';
                if (canvas) exportCanvas4K(canvas, title);
            });
            box.style.position = 'relative';
            box.appendChild(btn);
        }
    });
}

const originalSwitchTab = window.switchTab;
window.switchTab = function(name) {
    originalSwitchTab.call(this, name);
    setTimeout(addExportButtons, 100);
};

document.addEventListener('DOMContentLoaded', addExportButtons);
setTimeout(addExportButtons, 500);

computeAll();

// Add zoom controls to all chart boxes
function addZoomControlsToCharts() {
    // Charts already have 4K export buttons, no additional controls needed
}

document.addEventListener('keydown', e => { if(e.key === 'Escape') { closePointModal(); closeScreenshotOverlay(); closeSectorModal(); } });

document.getElementById('sectorModal').addEventListener('click', function(e) { if(e.target === this) closeSectorModal(); });

setTimeout(addZoomControlsToCharts, 500);</script>
</body>
                    </html>
